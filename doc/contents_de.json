[
  {
    "id": 1,
    "title": "Logisim Referenzen",
    "url": "/de/html/guide/index.html",
    "text": "Der Leitfaden f\u00fcr Logisim-Anwender\nDer Leitfaden f\u00fcr Logisim-Anwender\nLogisim ist ein Unterrichtswerkzeug zur Entwicklung und Simulation digitaler Schaltungen. Mit seiner \u00fcbersichtlichen Benutzerschnittstelle und der laufenden Simulation der Schaltung, w\u00e4hrend Sie diese aufbauen, ist das Programm in der Lage, die Grundbegriffe digitaler Schaltungen zu vermitteln. Mit der M\u00f6glichkeit, gr\u00f6\u00dfere Schaltungen aus kleineren Teilschaltungen heraus zu konstruieren, und ganze Kabelb\u00fcndel mit einem einzigen Mausbewegung zu verlegen, kann (und wird) Logisim dazu benutzt, ganze Mikroprozessoren im Unterricht zu simulieren.\nLogisim wird von Studenten an Hochschulen und Universit\u00e4ten in der ganzen Welt f\u00fcr eine Vielzahl von Aufgaben verwendet, zum Beispiel:\nAls ein Modul allgemeinbildenden Informatikschulungen\nAls Unterrischtsblock f\u00fcr Informatikstudenten im zweiten Studienjahr\nIn ganzsemestrigen Vorlesungen zur Computerarchitektur\nDer Leitfaden f\u00fcr Logisim-Anwender, den Sie gerade lesen, ist die offizielle Referenz zu den Programmfunktionen von Logisim. Der erste Teil besteht aus einer Reihe von Abschnitten, die den Aufbau von Logisim erkl\u00e4ren. Dese Abschnitte sind so geschrieben, da\u00df Sie diese an einem St\u00fcck lesen k\u00f6nnen, um sich mit den wichtigsten Merkmalen von Logisim vertraut zu machen.\nEinf\u00fchrung f\u00fcr Anf\u00e4nger\nBibliotheken und Attribute Teilschaltungen\nLeitungsb\u00fcndel\nKombinatorische Analyse\nDie \u00fcbrigen Abschnitte sind eine bunte Mischung von Referenzmaterial und Erkl\u00e4rungen aus den Tiefen von Logisim.\nMen\u00fcreferenz Speicherbauelemente Ablaufverfolgung Benutzung der Kommandozeile Programmbezogene Einstellungen Projektbezogene Einstellungen Weiterleitung von Werten JAR-Bibliotheken \u00dcber das Programm"
  },
  {
    "id": 2,
    "title": "Leitfaden f\u00fcr Logisim-Anwender",
    "url": "/de/html/guide/index.html",
    "text": "Der Leitfaden f\u00fcr Logisim-Anwender\nDer Leitfaden f\u00fcr Logisim-Anwender\nLogisim ist ein Unterrichtswerkzeug zur Entwicklung und Simulation digitaler Schaltungen. Mit seiner \u00fcbersichtlichen Benutzerschnittstelle und der laufenden Simulation der Schaltung, w\u00e4hrend Sie diese aufbauen, ist das Programm in der Lage, die Grundbegriffe digitaler Schaltungen zu vermitteln. Mit der M\u00f6glichkeit, gr\u00f6\u00dfere Schaltungen aus kleineren Teilschaltungen heraus zu konstruieren, und ganze Kabelb\u00fcndel mit einem einzigen Mausbewegung zu verlegen, kann (und wird) Logisim dazu benutzt, ganze Mikroprozessoren im Unterricht zu simulieren.\nLogisim wird von Studenten an Hochschulen und Universit\u00e4ten in der ganzen Welt f\u00fcr eine Vielzahl von Aufgaben verwendet, zum Beispiel:\nAls ein Modul allgemeinbildenden Informatikschulungen\nAls Unterrischtsblock f\u00fcr Informatikstudenten im zweiten Studienjahr\nIn ganzsemestrigen Vorlesungen zur Computerarchitektur\nDer Leitfaden f\u00fcr Logisim-Anwender, den Sie gerade lesen, ist die offizielle Referenz zu den Programmfunktionen von Logisim. Der erste Teil besteht aus einer Reihe von Abschnitten, die den Aufbau von Logisim erkl\u00e4ren. Dese Abschnitte sind so geschrieben, da\u00df Sie diese an einem St\u00fcck lesen k\u00f6nnen, um sich mit den wichtigsten Merkmalen von Logisim vertraut zu machen.\nEinf\u00fchrung f\u00fcr Anf\u00e4nger\nBibliotheken und Attribute Teilschaltungen\nLeitungsb\u00fcndel\nKombinatorische Analyse\nDie \u00fcbrigen Abschnitte sind eine bunte Mischung von Referenzmaterial und Erkl\u00e4rungen aus den Tiefen von Logisim.\nMen\u00fcreferenz Speicherbauelemente Ablaufverfolgung Benutzung der Kommandozeile Programmbezogene Einstellungen Projektbezogene Einstellungen Weiterleitung von Werten JAR-Bibliotheken \u00dcber das Programm"
  },
  {
    "id": 3,
    "title": "Einf\u00fchrung f\u00fcr Anf\u00e4nger",
    "url": "/de/html/guide/tutorial/index.html",
    "text": "Einf\u00fchrung f\u00fcr Anf\u00e4nger\nEinf\u00fchrung f\u00fcr Anf\u00e4nger\nWillkommen zu Logisim!\nLogisim erlaubt es Ihnen, digitale Schaltungen zu entwerfen und zu simulieren. Es ist, als ein p\u00e4dagogisches Werkzeug gedacht, um Ihnen zu zeigen, wie Schaltungen funktionieren.\nUm den Umgang mit Logisim zu lernen, lassen Sie uns eine XOR-Schaltung aufbauen - eine Schaltung mit zwei EIng\u00e4ngen (die wir x und y nennen wollen), und die eine 0 ausgibt, wenn beide Eing\u00e4nge denselben Wert aufweisen, und eine 1, wenn dies nicht der Fall ist. Die folgende Wahrheitstabelle zeigt die Funktion.Wir k\u00f6nnen diese Schaltung zun\u00e4chst auf dem Papier entwerfen.Aber nur weil es jetzt auf dem Papier steht bedeutet dies noch nicht, da\u00df die Schaltung auch richtig ist. Um unseren Entwurf zu \u00fcberpr\u00fcfen, werden wir die Schaltung in Logisim zeichnen und testen. Als Bonus erhalten wir ein Schaltungsdiagramm, das vielleicht besser aussieht, als unsere Skizze von Hand.\nSchritt 0: Finden Sie sich zurecht Schritt 1: Gatter hinzuf\u00fcgen Schritt 2: Leitungen hinzuf\u00fcgen Schritt 3: Text hinzuf\u00fcgen Schritt 4: Testen der Schaltung\nViel Spa\u00df beim Schaltungsaufbau!"
  },
  {
    "id": 4,
    "title": "Schritt 0: Finden Sie sich zurecht",
    "url": "/de/html/guide/tutorial/tutor-orient.html",
    "text": "Einf\u00fchrung: Finden Sie sich zurecht\nSchritt 0: Finden Sie sich zurecht\nWenn Sie Logisim starten, werden Sie ein Fenster wie das folgende sehen. Auf einem anderen Computersystem kann das Fenster etwas anders aussehen.\nDas Programmfenster von Logisim ist in drei Bereiche gegliedert: das \u00dcbersichtsfenster, die Attribut-Tabelle und die Arbeitsfl\u00e4che. \u00dcber diesen drei Bereichen befindet sich die Men\u00fcleiste und die Werkzeugleiste.In dieser Einf\u00fchrung werden wir noch nicht auf das \u00dcbersichtsfenster und auch nciht auf die Attribut-Tabelle eingehen. Bis auf Weiteres k\u00f6nnen Sie diese beiden Bereiche einfach ignorieren. Und die Men\u00fcleiste sollte eigentlich selbsterkl\u00e4rend sein.\nSomit bleiben und hier die Werkzeugleiste und die Arbeitsfl\u00e4che. Der Arbeitsbereich ist die Fl\u00e4che, auf der Sie Ihre Schaltung zeichnen werden, und die Werkzeugleiste enth\u00e4lt alle Werkzeuge, die Sie hierf\u00fcr ben\u00f6tigen."
  },
  {
    "id": 5,
    "title": "Schritt 1: Gatter hinzuf\u00fcgen",
    "url": "/de/html/guide/tutorial/tutor-gates.html",
    "text": "Einf\u00fchrung: Gatter hinzuf\u00fcgen\nSchritt 1: Gatter hinzuf\u00fcgen\nErinnern Sie sich daran, da\u00df wir die folgende Schaltung in Logisim aufbauen wollen.\nZun\u00e4chst sollten wir die Gatter platzieren, um ein Ger\u00fcst zu erhalten. Sp\u00e4ter werden wir die Gatter mit Leitungen verbinden. Zun\u00e4chst werden wir die zwei AND-Gatter hinzuf\u00fcgen. Klicken Sie auf das AND-Werkzeug auf der Werkzeugleiste (, das vorletzte Werkzeug). Dann klicken Sie auf die Arbeitsfl\u00e4che, dort, wo Sie das erste AND-Gatter platzieren m\u00f6chten. Lassen Sie gen\u00fcgend Platz auf der linken Seite. Danach klicken Sie nochmals auf das AND-Werkezug und setzen Sie das zweite AND-Gatter unter das erste.\nSehen Sie die f\u00fcnf Punkte auf der linken Seite des AND-Gatters? Dies sind die Anschlu\u00dfpunkte, an denen Sie Leitungen befestigen k\u00f6nnen. Diesmal werden wir nur zwei dieser Punkte f\u00fcr unsere XOR-Schaltung ben\u00f6tigen, aber f\u00fcr andere Schaltungen werden Sie vielleicht mehr Eing\u00e4nge ben\u00f6tigen.\nJetzt f\u00fcgen wir die weiteren Gatter hinzu. Zun\u00e4chst klicken Sie auf das OR-Werkzeug (), und platzieren das OR-Gatter in der Schaltung. Und dann setzen Sie die zwei Inverter vor den AND-Gattern mit dem Inverter-Werkzeug ().\nHier wurde ein kleiner Abstand zwischen den Anschl\u00fcssen der Inverter und der AND-Gatter gelassen. Sie k\u00f6nnen die Anschl\u00fcsse aber auch gleich direkt aneinander setzen und ersparen sich damit das sp\u00e4tere Verdrahten dieser Anschl\u00fcsse.\nJetzt f\u00fcgen wir die beiden Eing\u00e4nge\nx und y hinzu. W\u00e4hlen Sie das Eingangs-Werkzeug () aus, und platzieren Sie die Pins. Mit dem Ausgangs-Werkzeug () sollten Sie ebenfalls einen Ausgang neben dem Ausgang des OR-Gatters platzieren. (Auch hier wurde wieder ein kleiner Abstand zwischen dem OR-Gatter und dem Ausgangsanschlu\u00df gelassen, aber Sie k\u00f6nnten diese auchn direkt aneinander setzen.)\nWenn Sie nachtr\u00e4glich etwas verschieben wollen, dann w\u00e4hlen Sie das zu verschiebende Bauelement mit Hilfe des Bearbeitungs_Werkzeugs () aus, und ziehen Sie es dann mit der Maus dorthin, wo Sie es gerne haben m\u00f6chten. Mit dem Kommando \"L\u00f6schen\" aus dem Men\u00fc \"Bearbeiten\" bzw. mit der Entf-Taste k\u00f6nnen Sie das Bauelement auch gleich aus der Schaltung entfernen.\nSie werden bemerkt haben, da\u00df Logisim nach dem Einf\u00fcgen eines neuen Bauelements automatisch zum Bearbeitungswerkzeug zur\u00fcck wechselt. Auf diese Weise k\u00f6nnen Sie das erstellte Bauelement sofort verschieben und es (wie wir gleich sehen werden) verdrahten. Wenn Sie ein soeben platziertes Bauelement kopieren wollen, so k\u00f6nnen Sie mit dem Tastaturkommando Strg-D die aktuelle Auswahl duplizieren (Einige Computer benutzen andere Tastenkombinationen f\u00fcr Men\u00fcbefehle, auf einem Mac zum Beispiel die Kommando-Taste. Diese w\u00fcrden Sie hier zusammen mit der Taste D benutzen.)"
  },
  {
    "id": 6,
    "title": "Schritt 2: Leitungen hinzuf\u00fcgen",
    "url": "/de/html/guide/tutorial/tutor-wires.html",
    "text": "Einf\u00fchrung: Leitungen hinzuf\u00fcgen\nSchritt 2: Leitungen hinzuf\u00fcgen\nNachdem Sie alle Bauelemente auf der Arbeitsfl\u00e4che abgelegt haben, ist es an der Zeit, Leitungen anzuschlie\u00dfen. W\u00e4hlen Sie das Bearbeitungswerkzeug () aus. Wenn sich der Mauszeiger \u00fcber dem Anschlu\u00dfpunkt eines Bauelements befindet, wird ein kleiner gr\u00fcner Kreis um diesen Punkt gezeichnet. Dr\u00fccken Sie dann die Maustaste und ziehen Sie die Leitung soweit Sie m\u00f6chten.\nLogisim ist zeimlich intelligent beim Hinzuf\u00fcgen von Leitungen: Immer wenn eine Leitung auf einer anderen Leitung endet, werden die beiden Leitungen verbunden. Sie k\u00f6nnen eine bestehende Leitung verl\u00e4ngern oder verk\u00fcrzen, indem Sie deren Endpunkte mit dem Bearbeitungswerkzeug verschieben.\nLeitungen in Logisim verlaufen immer horizontal oder vertikal. Um den oberen Eingang an den Inverter und die zwei AND-Gatter anzuschlie\u00dfen, wurden drei verschiedene Leitungen gezogen.\nLogisim schlie\u00dft Leitungen automatisch an Gatter an, und verbindet Leitungen automatisch untereinander. Dabei wird automatisch der Punkt an einer T-Kreuzung gezeichnet, um anzuzeigen, da\u00df die Leitungen verbunden sind.\nWenn Sie neue Leitungen zeichnen, werden Ihnen auch blaue und graue Leitungen begegnen. In Logisim zeigt Blau an, da\u00df der Wert eines Punktes \"unbekannt\" ist, und graue Leitungen sind \u00fcberhaupt noch nicht irgendwo angeschlossen. Da Sie aber noch mit dem Aufbau der Schaltung zu tun haben, mu\u00df Sie dies nicht st\u00f6ren. Aber wenn Sie Sie mit dem Zeichnen fertig sind, dann sollten keine Leitungen mehr blau oder grau sein. (Die nicht-angeschlossenen Eing\u00e4nge des OR-Gatters sind hier immer noch blau, aber das ist in Ordnung.)\nWenn Sie immer noch blaue oder graue Leitungen sehen, wenn Sie eigentlich alles angeschlossen haben, dann stimmt irgendetwas noch nicht. Es ist immer wichtig, da\u00df Sie die Leitungen an den richtigen Stellen anschlie\u00dfen. Logisim zeichnet kleine Punkte an den Stellen der Bauelemente, an denen Dr\u00e4hte angeschlossen werden sollten. W\u00e4hrend Sie mit dem Zeichnen der Schaltung vorankommen, werden Sie sehen, wie immer mehr dieser Punkte von blau zu hellgr\u00fcn oder dunkelgr\u00fcn wechseln.\nSobald Sie alle Leitungen angeschlossen haben, werden auch alle Leitungen selbst hellgr\u00fcn oder dunkelgr\u00fcn sein."
  },
  {
    "id": 7,
    "title": "Schritt 3: Text hinzuf\u00fcgen",
    "url": "/de/html/guide/tutorial/tutor-text.html",
    "text": "Einf\u00fchrung: Text hinzuf\u00fcgen\nWeitert: Schritt 4: Testen der Schaltung\nSchritt 3: Text hinzuf\u00fcgen\nDas Hinzuf\u00fcgen von Text ist f\u00fcr das Funktionieren einer Schaltung nicht notwendig. Wenn Sie aber Ihre Schaltungen an jemanden weitergeben m\u00f6chten (z.B. an einen Lehrer), dann k\u00f6nnen Beschriftungen bei der Erkl\u00e4rung helfen, wie einzelne Teile der Schaltung funktionieren.\nW\u00e4hlen Sie das Textwerkzeug () aus. Jetzt k\u00f6nnen Sie einen der Eing\u00e4nge anklicken, und diesen durch Eintippen mit einer Beschriftung versehen. (Es ist besser, direkt den Eingangspin anzuklicken und mit einer Beschriftung zu versehen, als den Text frei zu platzieren, weil die Beschriftung gegebenenfalls mit dem Pin verschoben wird.) Dasselbe k\u00f6nnen Sie auch mit dem Ausgangspin machen. Oder Sie k\u00f6nnen einfach auf einen beliebigen Platz der Arbeitsfl\u00e4che klicken, und den Text dort eintippen.\nWeitert: Schritt 4: Testen der Schaltung"
  },
  {
    "id": 8,
    "title": "Schritt 4: Testen der Schaltung",
    "url": "/de/html/guide/tutorial/tutor-test.html",
    "text": "Einf\u00fchrung: Testen der Schaltung\nSchritt 4: Testen der Schaltung\nDer letzte Schritt ist das Testen der Schaltung, um zu sehen, ob diese wirklich wie geplant funktioniert. Zu diesem Zeitpunkt simuliert Logisim bereits das Verhalten der Schaltung. Lassen Sie uns noch einmal ansehen, wo wir gerade waren.Beachten Sie, da\u00df beide Eing\u00e4nge auf 0 gesetzt sind, und auch am Ausgang haben wir eine 0. Dies zeigt uns, da\u00df unsere Schaltung schon eine 0 ausrechnet, wenn beide Eing\u00e4nge auf 0 gesetzt sind.\nJetzt probieren wir eine andere Eingangskombination. W\u00e4hlen Sie das Schaltwerkzeug () aus, und schalten Sie die Eing\u00e4nge um, indem Sie diese anklicken. Jedes Mal, wenn Sie einen Eingang anklicken, wird sich dessen Wert \u00e4ndern. Wir k\u00f6nnen also zum Beispiel den unteren Eingang anklicken.Sobald Sie den Wert am Eingang \u00e4ndern, wird Logisim Ihnen anzeigen, welche Werte auf den einzelnen Leitungen gef\u00fchrt werden. Eine hellgr\u00fcne Leitung zeigt eine 1 an, eine dunkelgr\u00fcne (fast schwarze) Leitung eine 0. Sie k\u00f6nnen auch sehen, da\u00df sich der Wert am Ausgang der Schaltung auf 1 ge\u00e4ndert hat.\nBisher haben wir somit die ersten zwei Zeilen der Wahrheitstabelle getestet, und die Ausgangswerte (0 und 1) entsprechen unseren Erwartungen.Durch Schalten der Eing\u00e4nge durch die verschiedenen Kombinationen k\u00f6nnen wir auch die restlichen zwei Zeilen \u00fcberpr\u00fcfen. Wenn alles stimmt, sind wir fertig: Die Schaltung funktioniert!\nUm unsere Arbeit zu archivieren, k\u00f6nnen Sie die Schaltung speichern oder ausdrucken. Die entsprechenden Funktionen finden Sie im Dateimen\u00fc, das auch einen Punkt zum Beenden von Logisim enth\u00e4lt. Aber warum sollten wir jetzt aufh\u00f6ren?\nNachdem Sie jetzt die Einf\u00fchrung abgeschlossen haben, k\u00f6nnen Sie weiter mit Logisim experimentieren und eigene Schaltungen aufbauen. Wenn Sie Schaltungen mit komplexeren Funktionen aufbauen wollen, dann sollten Sie auch den Rest des Hilfesystems durchbl\u00e4ttern, um zu sehen, welche M\u00f6glichkeiten Ihnen Logisim bietet. Logisim ist ein leistungsf\u00e4higes Programm, mit dem Sie riesige Schaltungen aufbauen und testen k\u00f6nnen. Diese Schritt-f\u00fcr-Schritt-Einf\u00fchrung kann nur die Oberfl\u00e4che ankratzen."
  },
  {
    "id": 9,
    "title": "Bibliotheken und Attribute",
    "url": "/de/html/guide/attrlib/index.html",
    "text": "Bibliotheken und Attribute\nBibliotheken und Attribute\nIn diesem Abschnitt wird Ihnen gezeigt, wie Sie mit den zwei Hauptregionen des Programmfensters von Logisim arbeiten k\u00f6nnen: dem \u00dcbersichtsfenster und der Attribut-Tabelle.\nDas \u00dcbersichtsfenster Die Attribut-Tabelle Werkzeug- und Bauelementattribute"
  },
  {
    "id": 10,
    "title": "Das \u00dcbersichtsfenster",
    "url": "/de/html/guide/attrlib/explore.html",
    "text": "Das \u00dcbersichtsfenster\nDas \u00dcbersichtsfenster\nLogisim verwaltet seine Werkzeuge in Bibliotheken. Diese werden als Verzeichnisse im \u00dcbersichtsfenster angezeigt. Um auf die Bauelemente einer Bibliothek zuzugreifen, brauchen Sie lediglich auf das entsprechende Verzeichnis doppelzuklicken. Hier sehen Sie die ge\u00f6ffnete Gatter-Bibliothek mit dem ausgew\u00e4hlten NAND-Gatter. Logisim ist jetzt dazu bereit NAND-Gatter zur Schaltung hinzuzuf\u00fcgen.\nWenn Sie sich jetzt die Auswahl in der Gatter-Bibliothek ansehen, so werden Sie bemerken, da\u00df wir eigentlich gar keine XOR-Schaltung h\u00e4tten entwickeln m\u00fcssen: ein solches Gatter ist bereits Bestandteil von Logisim.\nWenn Sie ein neues Projekt anlegen, so enth\u00e4lt dieses automatisch bereits die folgenden Bibliotheken:\nBasis: Werkzeuge, die fester Bestandteil von Logisim sind.\nGatter: Bauelemente, die einfache logische Funktionen durchf\u00fchren.\nAuswahlschaltungen: komplexere kombinatorische Bauelemente, wie Multiplexer und Dekoder.\nArithmetik: Bauelemente, die arithmetische Funktionen ausf\u00fchren.\nSpeicher: Bauelemente, die Daten speichern k\u00f6nnen, wie Flip-Flops, Register und RAM.\nEingabe/Ausgabe: Bauelemente zur Interaktion mit dem Anwender.\n\u00dcber das Untermen\u00fc \"Bibliothek laden\" aus dem Projektmen\u00fc k\u00f6nnen Sie weitere Bibliotheken hinzuf\u00fcgen. Logisim besitzt drei Gruppen von Bibliotheken.\nEingebaute Bibliotheken sind Bibliotheken, die fester Bestandteil von Logisim sind. Diese sind in der Bibliotheksreferenz dokumentiert.\nLogisim-Bibliotheken sind in Logisim entwickelte Projekte, die als Logisim-Projekte gespeichert wurden. Sie k\u00f6nnen eine Reihe von Schaltungen in einem einzelnen Projekt aufbauen (wie im Abschnitt Teilschaltungen dieses Leitfadens beschrieben), und diese dann sp\u00e4ter als Bibliothek f\u00fcr andere Projekte benutzen.\nJAR-Bibliotheken sind Bibliotheken, die in Java erstellt werden, aber nicht fester Bestandteil von Logisim sind. Sie k\u00f6nnen fertige JAR-Bibliotheken von anderen Autoren herunterladen, oder Ihre eigenen erstellen, wie im Abschnitt JAR-Bibliotheken dieses Leitfadens beschrieben. Die Entwicklung einer JAR-Bibliothek ist aufwendiger, als die Erstellung einer Logisim-Bibliothek, aber die damit erstellten Bauelemente sind flexibler und erlauben sowohl die Vergabe von Attributen, als auch die Interaktion mit dem Anwender. Die eingebauten Bibliotheken (mit Ausnahme der Basis-Bibliothek) sind mit demselben API entwickelt worden, das auch die JAR-Bibliotheken benutzen k\u00f6nnen. Hieran k\u00f6nnen Sie den Umfang der Funktionen erkennen, die mit JAR-Bibliotheken verwirklicht werden k\u00f6nnen.\nEinige JAR-Bibliotheken enthalten keinen Hinweis darauf, welche Java-Klasse der Bibliothek gestartet werden soll. Wenn Sie eine solche JAR-Bibliothek laden, wird Logisim Sie zur Eingabe des Namens der entsprechenden Klasse auffrodern. Der Name dieser Klasse sollte Ihnen vom Ersteller der JAR-Bibliothek mitgeteilt werden.\nUm eine Bibliothek wieder zu entfernen, w\u00e4hlen Sie den Punkt \"Bibliotheken entfernen...\" aus dem Projektmen\u00fc. Logisim erlaubt es Ihnen nicht, Bibliotheken zu entfernen, deren Bauelemente in einer Schaltung verwendet werden, die auf der Werkzeugleiste angezeigt wird, oder einer Maustaste zugeordnet ist.\nStreng genommen enth\u00e4lt eine Bibliothek \u00fcbrigens Werkzeuge, keine Bauelemente. So finden Sie in der Basis-Bibliothek das Schaltwerkzeug (), das Bearbeitungswerkzeug () und andere Werkzeuge, die keinen direkten Bezug zu einem spezifischen Bauelement aufweisen. Die meisten Bibliotheken enthalten aber Werkzeuge zum Hinzuf\u00fcgen individueller Bauelemente. Alle eingebauten Bibliotheken mit Ausnahme der Basis-Bibliothek sind auf diese Weise aufgebaut."
  },
  {
    "id": 11,
    "title": "Die Attribut-Tabelle",
    "url": "/de/html/guide/attrlib/attr.html",
    "text": "Die Attribut-Tabelle\nDie Attribut-Tabelle\nViele Bauelemente besitzen Attribute, die das Verhalten und Aussehen des Bauelements steuern. Die Attribut-Tabelle dient der Anzeige und Bearbeitung der Werte dieser Attribute.\nUm auszuw\u00e4hlen, f\u00fcr welches Bauelement die Attribiute angezeigt oder bearbeitet werden sollen, klicken Sie das Bauelemente mit dem Bearbeitungswerkzeug an (). (Sie k\u00f6nnen das Bauelemente auch mit der rechten Maustaste (Control-Klick bei Mac OS X) anklicken, und den Punkt \"Attribute anzeigen\" aus dem Kontextmen\u00fc ausw\u00e4hlen. Auch, wenn Sie das Bauelement mit dem Schaltwerkzeug () oder dem Textwerkzeug () bearbeiten, werden Ihnen die Attribute dieses Bauelements angezeigt.\nDie folgende Bildschirmkopie zeigt Ihnen, wie es aussieht, wenn Sie den oberen Eingang unserer XOR-Schaltung anklicken, und dann die Attribut-Tabelle bis zum Beschriftungsfeld durchbl\u00e4ttern.\nUm ein Attribut zu \u00e4ndern, klicken Sie auf dessen Wert. Das Aussehen der Schnittstelle zur Bearbeitung des Attributs h\u00e4ngt von der Art des jeweiligen Attributs ab: f\u00fcr das Attributfeld der Schriftart einer Beschriftung erscheint ein Dialogfenster zur Auswahl der Schriftart, f\u00fcr ein Beschriftungsfeld gibt es ein Textfeld und f\u00fcr wieder andere Felder erhalten Sie ein Ausklappmen\u00fc mit mehreren Auswahlm\u00f6glichkeiten (z.B. f\u00fcr die Ausrichtung der Beschriftung).\nJede Art von Bauelement hat einen anderen Satz von Attributen. Ein Beschreibung, was diese im Einzelnen bedeuten, finden Sie in der Bauelementereferenz der Dokumentation.Wenn mehrere Bauelemente ausgew\u00e4hlt sind, werden in der Tabelle nur die Attribute angezeigt, die diese Bauelemente gemeinsam haben. Mit ausgew\u00e4hlte Leitungen spielen hierbei keine Rolle. Wenn die ausgew\u00e4hlten Bauelemente unterschiedliche Werte f\u00fcr ein Attribut aufweisen, dann wird der Wert dieses Attributs als leer angezeigt. \u00c4nderungen eines solchen gemeinsamen Attributs wirken sich unmittelbar auf alle ausgew\u00e4hlten Bauelemente aus."
  },
  {
    "id": 12,
    "title": "Werkzeug- und Bauelementattribute",
    "url": "/de/html/guide/attrlib/tool.html",
    "text": "Werkzeugattribute\nWerkzeugattribute\nAuch jedes Werkzeug zum Hinzuf\u00fcgen von Bauelementen zu einer Schaltung hat einen Satz von Attributen, die an die mit dem Werkzeug erstellten Bauelement weitergegeben werden. Diese Attribute der Bauelemente lassen sich sp\u00e4ter \u00e4ndern, ohne die Werkzeugattribute zu beeinflussen. Wenn Sie ein Werkzeug ausw\u00e4hlen, wird Logisim die Attribute dieses Werkzeugs in der Attribut-Tabelle anzeigen.\nNehmen wir an, Sie m\u00f6chten zum Beispiel kleinere AND-Gatter erstellen. Zun\u00e4chst wird das AND-Werkzeug immer gro\u00dfe AND-Gatter erstellen. Wenn Sie aber das Attribut zur Gattergr\u00f6\u00dfe direkt \u00e4ndern (bevor Sie das AND-Gatter in der Schaltung platzieren), dann \u00e4ndern Sie das Attribut des Werkzeugs. Jedes weitere AND-Gatter, das Sie danach mit dem Werkzeug einf\u00fcgen, wird die kleinere Gr\u00f6\u00dfe aufweisen.\nJetzt k\u00f6nnen Sie die beiden existierenden AND-Gatter l\u00f6schen, und stattdessen zwei neue AND-Gatter an deren Stelle einf\u00fcgen. Diesmal handelt es sich um kleine Gatter. (Wenn Sie gleichzeitig noch die Anzahl der Eing\u00e4nge auf 3 reduzieren, dann entfallen die vertikalen Erweiterungsstriche an den Gattern. Sie m\u00fc\u00dften dann aber auch die Schaltung neu verdrahten, weil die bisherigen Leitungen die Eing\u00e4nge des Gatters nicht mehr treffen w\u00fcrden.)\nBei einigen Werkzeugen, spiegelt das Werkzeug-Symbol einige der Attribute wieder. Ein solches Beispiel ist das Pin-Werkzeug, dessen Symbol in die gleiche Richtung zeigt, wie dies durch das Ausrichtungs-Attribut vorgegeben ist.\nDie Werkzeuge auf der Werkzeugleiste haben einen separaten Satz von Attributen zu den gleichen Werkzeugen aus dem \u00dcbersichtsfenster. Daher wird das AND-Werkzeug aus der Gatter-Bibliothek auch weiterhin breite Gatter erstellen, wenn Sie jetzt das Attribut zur Gattergr\u00f6\u00dfe f\u00fcr das AND-Werkzeug der Werkzeugleiste ge\u00e4ndert haben.\nTats\u00e4chlich sind die Werkzeuge f\u00fcr Eingangs- und Ausgangs-Pins der Werkzeugleiste Instanzen des Pin-Werkzeugs aus der Basis-Bibliothek, haben aber andere S\u00e4tze von Attributen. Das Symbol des Pin-Werkzeugs wird als Kreis oder Quadrat dargestellt, abh\u00e4ngig vom Werkzeug-Attribut \"Ausgang?\".\nLogisim bietet einen bequemen Tastaturbefehl zur \u00c4nderung des Ausrichtungs-Attributs, das bestimmt, in welche Richtung ein Bauelement zeigt. Wenn Sie eine der Pfeiltasten bet\u00e4tigen, nachdem Sie das entsprechende Werkzeug ausgew\u00e4hlt haben, \u00e4ndert sich direkt die Ausrichtung des Bauelements."
  },
  {
    "id": 13,
    "title": "Teilschaltungen",
    "url": "/de/html/guide/subcirc/index.html",
    "text": "Teilschaltungen\nTeilschaltungen\nAs you build circuits that are more and more sophisticated, you will\nwant to build smaller circuits that you can use multiple times\nas a module nested within larger circuits.\nIn Logisim, such a smaller circuit that is used in a larger\ncircuit is called a subcircuit.\nIf you're familiar with computer programming, you're familiar with\nthe subprogram concept, whether it's called a subroutine,\nfunction, method, or procedure in your\nfavored language.\nThe subcircuit concept is analogous to this, and it serves the same purpose:\nTo break a large job into bite-sized pieces,\nto save the effort of defining the same concept multiple times, and to\nfacilitate debugging.\nCreating circuits\nUsing subcircuits\nEditing subcircuit appearance\nDebugging subcircuits\nLogisim libraries"
  },
  {
    "id": 14,
    "title": "Erstellen von Schaltungen",
    "url": "/de/html/guide/subcirc/creating.html",
    "text": "Erstellen von Schaltungen\nErstellen von Schaltungen\nEvery Logisim project is actually a library of circuits. In\nits simplest form, each project has only one circuit (called\n\"main\" by default), but it is easy to add more:\nSelect Add Circuit... from the Project menu, and type any name\nyou like for the new circuit you want to create.\nSuppose we want to build a 2-to-1 multiplexer named \"2:1 MUX.\"\nAfter adding the circuit, Logisim will look like this.\nIn the explorer pane, you can now see that the project now\ncontains two circuits, \"main\", and \"2:1 MUX.\" Logisim draws a\nmagnifying glass over the icon of the circuit currently being\nviewed; the current circuit name also appears in the window's\ntitle bar.\nAfter editing the circuit to appear like a 2:1 multiplexer,\nwe might end up with the following circuit."
  },
  {
    "id": 15,
    "title": "Verwendung von Teilschaltungen",
    "url": "/de/html/guide/subcirc/using.html",
    "text": "Verwendung von Teilschaltungen\nVerwendung von Teilschaltungen\nNow suppose we want to build a 4-to-1 multiplexer using\ninstances of our 2-to-1 multiplexer. Of course, we would first create\na new circuit, which we'll call \"4:1 MUX.\" To add 2-to-1 multiplexers\ninto our circuit, we click the 2:1 MUX circuit once in the\nexplorer pane to select it as a tool, and then we can add copies of\nit, represented as boxes, by clicking within the canvas.\nIf you were to double-click the 2:1 MUX circuit in the explorer pane,\nthen the window would switch to editing the 2:1 MUX circuit instead.\nAfter building up the circuit, we end up with the following.\nOur circuit for a 4-to-1 multiplexer uses three copies of the\n2-to-1 multiplexer, each drawn as a box with pins along the side.\nThe pins on this box correspond to the input and output pins in the\n2:1 MUX circuit.\nThe two pins on the west side of the box correspond\nto the two pins that face east in the 2:1 MUX circuit; the pin on\nthe box's east side corresponds to the 2:1 MUX's west-facing pin\n(which happens to be an output pin); and the pin on the box's south\nside corresponds to the 2:1 MUX's north-facing pin.\nThe order of\nthe two pins on the box's west side correspond to the same top-down\nordering from the subcircuit's design.\n(If there were several pins\non the box's north or south side, they would correspond to the same\nleft-right order in the subcircuit.)\nIf the pins in the subcircuit's layout have labels associated with\nthem, then Logisim will display that label in a tip\n(that is, a temporary text box) when the user hovers the mouse over the\ncorresponding location of the subcircuit component. (If you find these\ntips irritating, you can disable them via the\nPreferences window's Layout\ntab.)\nSeveral other components will display these tips, too: For some of the\npins of a built-in flip-flop,\nfor example, hovering over it explains what that pin does.\nIncidentally, every pin to a circuit must be either an input or\nan output. Many manufactured chips have pins that behave as an input\nin some situations and as an output in others; you cannot construct\nsuch chips within Logisim (at least, in the current version).\nLogisim will maintain different state information for all subcircuits\nappearing in a circuit. For example, if a circuit contains a\nflip-flop, and that circuit is used as a subcircuit several\ntimes, then each subcircuit's flip-flop will have its own value\nwhen simulating the larger circuit.\nNow that we have the 4-to-1 multiplexer defined, we can now use it\nin other circuits. Logisim has no limits on how deeply circuits\ncan be nested - though it will object to nesting circuits within\nthemselves!\nNote: There's nothing wrong with editing a\ncircuit that is being used as a subcircuit; in fact, this is quite\ncommon. Be aware, though, that any changes to a circuit's pins (adding,\ndeleting, or moving them) will rearrange them also in the containing\ncircuit. Thus, if you change any pins in a circuit, you will also\nneed to edit any circuits using it as a subcircuit."
  },
  {
    "id": 16,
    "title": "Aussehen von Teilschaltungen bearbeiten",
    "url": "/de/html/guide/subcirc/appear.html",
    "text": "Aussehen von Teilschaltungen bearbeiten\nAussehen von Teilschaltungen bearbeiten\nDefault appearance\nBy default, when a subcircuit is placed within a larger circuit, it is drawn\nas a rectangle with a notch indicating the north end of the subcircuit's\nlayout. Pins will be placed on the rectangle's border based on their facing:\nPins that face east in the layout (and typically appear on the west side\nof the layout) will be placed on the rectangle's west side,\naccording to their top-down ordering in the layout.\nPins that face south in the layout (typically toward the north side of the layout)\nwill be placed on the rectangle's north side, according to the left-to-right\nordering in the layout.\nThe default rectangle can optionally include some letters that will appear\nin the middle of the rectangle. To specify this, select the selection tool\n() and click the background of the circuit's\nlayout. This will show the circuit attributes in the attribute table, including\nthe Label, Label Facing, and Label Font attributes.\nThe value of the Label attribute will be drawn in the rectangle's center;\nthe Label Facing attribute customizes which direction the text is drawn,\nand of course the Label Font attribute customizes the font used.\nCustomized appearance\nThe default appearance is very usable, and indeed Logisim existed for many\nyears with no other option. If, however, you prefer that the subcircuit be\ndrawn differently, you can select Edit Circuit Appearance from the\nProject menu, and Logisim's interface will switch from its regular\nlayout-editing interface to an interface for drawing the circuit's\nappearance. Below, we are editing the 2:1 multiplexer's appearance so that\nit is drawn with the usual trapezoid rather than a rectangle.\n(You can see the project toolbar just below the regular toolbar.\nThis can be enabled through the Project menu, and it allows quick switching\nbetween editing the layout and appearance.)\nWith the appearance for the 2:1 multiplexer drawn as above,\nthe layout for the 4:1 multiplexer would then appear as the following.\nThe appearance editor is like a traditional drawing program, but there\nare a few special symbols for indicating how the drawing works when placed\ninto a circuit's layout. These special symbols cannot be removed.\nThe green circle with a line coming out of it, which we'll call the anchor.\nThere is exactly one anchor in each subcircuit appearance.\nEach component in a circuit has a single point identifying its location;\na user sees this when creating a new component:\nThe mouse click identifies just a single location, and the component is placed\nrelative to that (usually with the primary output at the mouse's location)\nThe anchor identifies the mouse's location relative to the overall drawing\nwhen the subcircuit is created.\nThe anchor also identifies the appearance's facing, as indicated by the\ndirection the anchor's line points from its circle. When placing the subcircuit\ninto a layout, the user can change the subcircuit's facing; the anchor's facing\nindicates in which direction the appearance is oriented. In our example, the\nanchor is facing east, and each instance of the subcircuit in the 4:1 multiplexer\nis also facing east, so they are all drawn in the same orientation as the 2:1\nmultiplexer's appearance.\nThe blue circles and squares with dots in them are the subcircuit's\nports. There are exactly as many ports as there are input and output\npins in the circuit.\nPorts corresponding to inputs are drawn as squares, while ports corresponding\nto outputs are drawn as circles.\nEach port indicates how a wire connecting into the\ncircuit will correspond to an input or output pin within the layout.\nWhen you select a port, Logisim will indicate the corresponding pin\nby popping up a miniature diagram of the layout in the window's bottom right\ncorner, with the corresponding pin(s) drawn in blue. This does not happen when\nall ports are selected.\nThe toolbar contains tools for adding additional shapes, as listed below\nwith descriptions of how the shift and alt key modifies the tool behavior. In\naddition, clicking or dragging the mouse with the control key pressed regularly\nsnaps the mouse position to the nearest grid point.\nSelect, move, copy, and paste shapes.\nAdd or edit text.\nCreate a line segment. Shift-drag keeps the line's angle at a multiple of 45\u00b0.\nCreate a quadratic Bezier curve.\nFor the first drag, where you specify the curve's endpoints,\nshift-drag keeps the endpoints at an angle that is a multiple of 45\u00b0.\nThen you click to indicate the control point's location;\nshift-click ensures the curve is symmetric,\nwhile alt-click draws the curve through the control point.\nCreate a sequence of connected lines, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the angle between the\nprevious vertex and the current one is a multiple of 45\u00b0.\nDouble-click or press the Enter key to complete the\nshape.\nCreate a rectangle through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate a rectangle with rounded corners through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate an oval through dragging from one corner of its bounding box to the opposite corner.\nShift-drag to create a circle, and alt-drag to create the oval starting\nfrom the center.\nCreate an arbitrary polygon, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the vertex is at a 45\u00b0\nangle from the previous one. Double-click, press the Enter key, or click the\nstarting vertex to complete the shape."
  },
  {
    "id": 17,
    "title": "Fehlersuche in Teilschaltungen",
    "url": "/de/html/guide/subcirc/debug.html",
    "text": "Fehlersuche in Teilschaltungen\nFehlersuche in Teilschaltungen\nAs you test larger circuits, you will likely find bugs. To nail down\nwhat's going wrong, exploring what's going on in the subcircuits while\nrunning the overall circuit can help. You can view the state of the subcircuit\nin two ways: First, you can bring up the subcircuit's popup menu by\nright-clicking or control-clicking it, choosing the View option.\nOr if you have the Poke tool selected, you can click the circuit,\nand a magnifying glass will appear over its center;\ndouble-clicking where the magnifying glass appears will also enter\nthe subcircuit's state.\nNotice that the pins' values in the subcircuit match the values\nbeing sent to them in its containing circuit.\nWhile in the subcircuit, you are allowed to alter the circuit. If the\nchanges affect any of the subcircuit's outputs, they are propagated into the\ncontaining circuit. One exception: The subcircuit inputs are determined based on\nthe values coming into the circuit from the supercircuit, so it doesn't make\nsense to toggle those values. If you attempt to poke a subcircuit's input,\na dialog will pop up asking, The pin is tied to the supercircuit state.\nCreate a new circuit state? Clicking No will cancel the toggle request,\nwhile clicking Yes will create a copy of the viewed state,\ndivorced from the outer circuit, with the input pin toggled.\nOnce you have completed viewing and/or editing, you can return to the parent circuit\neither by double-clicking the parent circuit in the explorer pane, or via the Go Out\nTo State submenu of the Simulate menu."
  },
  {
    "id": 18,
    "title": "Bibliotheken von Logisim",
    "url": "/de/html/guide/subcirc/library.html",
    "text": "Bibliotheken von Logisim\nBibliotheken von Logisim\nEvery Logisim project is automatically a library that can be loaded\ninto other Logisim projects: Just save it into a file and then load\nthe library within another project. All of the circuits defined in the\nfirst project will then be available as subcircuits for the second.\nThis feature allows you to reuse common components across projects\nand to share favorite components with your friends (or students).\nEach project has a designated \"main circuit,\" which can be changed\nto refer to the current circuit via the Set As Main Circuit option\nin the Project menu. The only significance of this is that\nthe main circuit is the one that is displayed when you first open\nthe project.\nThe default name of the circuit in a newly created file\n(\"main\") has no significance at all, and you can feel free to delete\nor rename that circuit.\nWith a loaded Logisim library, you are allowed to view circuits and\nmanipulate their states, but Logisim will prevent you from altering\nthe circuits' design and other data stored within the file.\nIf you want to alter a circuit in a loaded Logisim library, then\nyou need to open it separately within Logisim. As soon as you save\nit, the other project should automatically load the modified version\nimmediately; but if it does not, you can right-click the library\nfolder in the explorer pane and select Reload Library."
  },
  {
    "id": 19,
    "title": "Leitungsb\u00fcndel",
    "url": "/de/html/guide/bundles/index.html",
    "text": "Leitungsb\u00fcndel\nLeitungsb\u00fcndel\nIn einfacheren Schaltungen in Logisim werden Leitungen h\u00e4ufig nur einzelne Bits transportieren. Aber Logisim erlaubt es Ihnen auch Leitungsb\u00fcndel zu erstellen, die mehrere Bits auf einmal \u00fcbertragen. Die Anzahl der Bits, die gleichzeitig auf einem solchen B\u00fcndel transportiert werden, ist dessen Bitbreite.\nErstellen von Leitungsb\u00fcndeln Verteiler Farben der Leitungen"
  },
  {
    "id": 20,
    "title": "Erstellen von Leitungsb\u00fcndeln",
    "url": "/de/html/guide/bundles/creating.html",
    "text": "Erstellen von Leitungsb\u00fcndeln\nErstellen von Leitungsb\u00fcndeln\nJedem Eingang und jedem Ausgang eines jeden Bauelements ist eine bestimmte Bitbreite zugeordnet. H\u00e4ufig handelt es sich um eine Breite von einem Bit, die sich auch nicht \u00e4ndern l\u00e4\u00dft. Aber viele der eingebauten Bauelemente in Logisim besitzen eine einstellbare Bitbreite an ihren Ein- und Ausg\u00e4ngen.\nIn der folgenden Bildschirmkopie wird eine Testschaltung gezeigt, die die bitweise AND-Verkn\u00fcpfung zweier drei Bit breiter Eingangswerte durchf\u00fchrt. Sehen Sie, wie das drei Bit breite Ausgangssignal die bitweise Verkn\u00fcpfung der zwei Eingangssignale darstellt. In diesem Beispiel wurden alle Bauelemente \u00fcber das Datenbits-Attribut auf eine Breite von drei Bit konfiguriert. Dies sehen Sie in der Bildschirmkopie an dem Wert 3 f\u00fcr das Datenbits-Feld.\nAlle Bauelemente von Logisim legen die Bitbreite ihrer Ein- und Ausg\u00e4nge fest. Die Bitbreite einer Leitung dagegen ist undefiniert. Erst wenn die Leitung an ein Bauelement angeschlossen wird, pa\u00dft sich diese an dessen Bitbreite an. Wenn eine Leitung an zwei Komponenten mit unterschiedlicher Bitbreite angeschlossen wird, meldet Logisim dies mit der Fehlermeldung \"Breiten nicht kompatibel\" und die betroffene Leitung wird in Orange dargestellt. In dem folgenden Bild wurde die Bitbreite des Ausgangs-Pins auf 1 gesetzt, und Logisim beklagt sich entsprechend.\nLeitungen, die inkompatible Anschl\u00fcsse verbinden (und daher in Orange dargestellt werden), f\u00fchren keine Werte.\nIm Fall von Einzelbit-Leitungen sehen Sie auf einen Blick, welchen Wert die Leitung gerade f\u00fchrt, denn Logisim f\u00e4rbt diese Leitungen hellgr\u00fcn oder dunkelgr\u00fcn, abh\u00e4ngig vom aktuellen Wert auf der Leitung. F\u00fcr Mehrbit-Leitungen werden keine Werte auf diese Weise dargestellt: diese Leitungen sind immer schwarz. Sie k\u00f6nnen eine solche Leitung aber mit dem Schaltwerkzeug () anklicken.\nDiese Testfunktion ist besonders hilfreich bei der Verwendung von Mehrbit-Leitungen."
  },
  {
    "id": 21,
    "title": "Verteiler",
    "url": "/de/html/guide/bundles/splitting.html",
    "text": "Verteiler\nVerteiler\nWenn Sie mit Mehrbit-Werten arbeiten, werden Sie h\u00e4ufig den Wunsch haben, einzelne Bits in verschiedene Richtungen weiterzuleiten. Das Verteiler-Werkzeug () aus der Basisbibliothek von Logisim steht Ihnen hierf\u00fcr zur Verf\u00fcgung.\nWenn wir einmal annehmen, Sie m\u00f6chten eine Schaltung aufbauen, die die bitweise AND-Verkn\u00fcpfung der beiden Nibbles (die oberen vier Bit und die unteren vier Bit) eines acht-Bit Einganges berechnen soll. Wir haben es dann mit einem acht-Bit-Wert zu tun, der vom Eingangspin geliefert wird, und wir m\u00fcssen diesen Wert in zwei vier-Bit-Werte aufspalten. In der folgenden Schaltung benutzen wir einen Verteiler, um dies zu erreichen: der acht-Bit-Wert wird an den Verteiler geleitet (der einer Vogelkralle \u00e4hnelt). Dieser teilt den acht-Bit-Wert in zwei vier-Bit-Werte auf, die dann an ein AND-Gatter weitergeleitet werden, um das Ergebnis zu berechnen.\nIn diesem Beispiel teilt der Verteiler einen ankommenden Wert in mehrere herausgehende Werte auf. Aber Verteiler k\u00f6nnen auch dazu verwendet werden, mehrere Werte zu einem Wert zusammenzuf\u00fcgen. In der Tat haben diese Verteiler keine feste Richtung: zu einem Zeitpunkt k\u00f6nnen Werte in der einen Richtung durchgeschickt werden, und zu einem anderen Zeitpunkt in der anderen. Werte k\u00f6nnen sogar in beiden Richtungen gleichzeitig transportiert werden, wie in dem n\u00e4chsten Beispiel. Dort l\u00e4uft der Wert zun\u00e4chst in \u00f6stlicher Richtung durch die zwei Verteiler, wird dann in die umgekehrte Richtung umgelenkt, l\u00e4uft in westlicher Richtung zur\u00fcck durch die Verteiler, bevor es noch einmal umgedreht wird, und nach einem weiteren Transport in \u00f6stlicher Richtung durch die Verteiler den Ausgang erreicht.\nDer Schl\u00fcssel zum Verst\u00e4ndnis von Verteilern liegt in deren Attributen. Im Folgenden bezeichnet ein aufgespaltenes Ende eine von mehreren Leitungenauf der einen Seite, w\u00e4hrend der Ausdruck zusammengef\u00fchrtes Ende die einzelne Leitung der anderen Seite bezeichnet.\nDas Attribut Ausrichtung bezeichnet, wie die aufgespaltenen Enden im Verh\u00e4ltnis zum zusammengef\u00fchrten Ende liegen.\nDas Attribut Ausf\u00e4cherung gibt an, wieviele aufgespaltene Enden vorhanden sind.\nDas Attribut\nBitbreite gibt die Bitbreite des zusammengef\u00fchrten Endes an.\nDas Attribut Bit x bezieht sich auf das Bit x des zusammengef\u00fchrten Endes. Wenn mehrere Bits demselben aufgespaltenen Ende zugeordnet werden, dann entspricht deren relative Reihenfolge der Reihenfolge dieser Bits im zusammengef\u00fchrten Ende. Verteiler in Logisim k\u00f6nnen kein Bit des zusammengef\u00fchrten Endes auf mehrere aufgespaltene Enden gleichzeitig weiterleiten.\nBeachten Sie, da\u00df jede \u00c4nderung der Ausf\u00e4cherung oder der Bitbreite alle Bit x-Attribute so zur\u00fccksetzen wird, da\u00df diese Bits so gleichm\u00e4\u00dfig wie m\u00f6glich auf die aufgespaltenen Enden verteilt werden."
  },
  {
    "id": 22,
    "title": "Farben der Leitungen",
    "url": "/de/html/guide/bundles/colors.html",
    "text": "Farben der Leitungen\nFarben der Leitungen\nJetzt sind wir in der Lage, die gesamte Farbpalette zusammenzufassen, die Logisim f\u00fcr Leitungen verwendet. In der folgenden kleinen Schaltung sehen Sie alle diese Farben auf einen Blick.\nGrau: Die Bitbreite der Leitung ist unbekannt. Dies kommt daher, weil diese Leitung noch nicht an den Ein- oder Ausgang irgendeines Bauelements angeschlossen ist. (Alle Ein- und Ausg\u00e4nge haben eine definierte Bitbreite.)\nBlau: Die Leitung tr\u00e4gt einen Einzelbit-Wert, aber derzeit ist der Zustand der Leitung nicht festgelegt. Hier nennen wir dies ein potenzialfreies Bit; manchmal wird es auch als ein hochohmiger Wert bezeichnet. In diesem Beispiel treibt ein threestate-Ausgang die Leitung, daher kann es einen potenzialfreien Wert ausgeben.\nDunkelgr\u00fcn: Die Leitung f\u00fchrt ein einzelnes 0-Bit.\nHellgr\u00fcn: Die Leitung f\u00fchrt ein einzelnes 1-Bit.\nSchwarz: Die Leitung f\u00fchrt ein mehrere Bit breites Wort. Einige oder alle einzelnen Bits k\u00f6nnen nicht angegeben werden.\nRot: Die Leitung f\u00fchrt ein fehlerhaftes Signal. Dies kann passieren, wenn ein Gatter den richtigen Ausgangswert nicht berechnen kann, zum Beispiel weil dessen Eing\u00e4nge nicht definiert sind. Es kann auch dadurch verursacht werden, da\u00df zwei Bauelemente versuchen, verschiedene Werte gleichzeitig \u00fcber dieselbe Leitung zu senden. Dies ist in der obigen Schaltung der Fall, in der ein Eingangspin eine 0 auf die Leitung gibt, w\u00e4hrend ein anderer Eingangspin eine 1 auf dieselbe Leitung geben will, und es damit zum Konflikt kommt. Leitungen mit einer Breite von mehreren Bits werden rot dargestellt, wenn auch nur ein einzelnes Bit einen fehlerhaften Wert aufweist.\nOrange: Die an die Leitung angeschlossenen Bauelemente besitzen unterschiedliche Bitbreiten. Eine orange Leitung ist tats\u00e4chlich au\u00dfer Funktion: es werden keine Werte zwischen den Bauelementen ausgetauscht. Im Beispiel wurde ein zwei-Bit-Bauelement an ein ein-Bit-Bauelement angeschlossen."
  },
  {
    "id": 23,
    "title": "Kombinatorik",
    "url": "/de/html/guide/analyze/index.html",
    "text": "Kombinatorik\nKombinatorik\nAlle digitalen Schaltungen fallen in eine von zwei Kategorien: in kombinatorische Netzwerke, in denen alle Ausg\u00e4nge direkte logische Verkn\u00fcpfungen der Eing\u00e4nge sind, und in sequentielle Netzwerke, in denen einige Ausg\u00e4nge auf fr\u00fcheren Zust\u00e4nden der Eing\u00e4nge basieren k\u00f6nnen (in einer\nzeitlichen Sequenz).\nSchaltungen der kombinatorischen Kategorie sind die einfacheren F\u00e4lle. In der Praxis kennt man drei Hauptmethoden, das Verhalten kombinatorischer Netzwerke zu beschreiben.\nLogische SchaltungenBoolesche Ausdr\u00fccke, die eine algebraische Darstellung der Funktion der Schaltung erlaubenWahrheitstabellen, die alle m\u00f6glichen Kombinationen der Eing\u00e4nge und deren Auswirkungen auf die Ausg\u00e4nge auflistenDas Kombinatorikmodul von Logisim erlaubt es Ihnen, in allen Richtugnen zwischen diesen drei Darstellungen zu wechseln. Dies Funktion ist besonders hilfreich bei der Erstellung und f\u00fcr das Verst\u00e4ndnis von Schaltungen mit einer Handvoll von Einzelbiteing\u00e4ngen und -ausg\u00e4ngen.\nStarten der Kombinatorik Bearbeiten der Wahrheitstabelle Erstellen von Ausdr\u00fccken Erstellen einer Schaltung"
  },
  {
    "id": 24,
    "title": "Starten der Kombinatorik",
    "url": "/de/html/guide/analyze/open.html",
    "text": "Starten der Kombinatorik\nStarten der Kombinatorik\nDie Hauptfunktionen des Kombinatorikmoduls sind \u00fcber ein einziges Dialogfenster zu erreichen. In diesem Fenster lassen sich Wahrheitstabellen und boolesche Ausdr\u00fccke bearbeiten. Dieses Fenster l\u00e4\u00dft sich auf zweierlei Weise \u00f6ffnen.\n\u00dcber das Fenstermen\u00fc\nW\u00e4hlen Sie den Punkt Kombinatorik und das Fenster des Kombinatorikmoduls wird ge\u00f6ffnet. Wenn Sie das Fenster zum ersten Mal aufrufen, wird es keinerlei Schaltungsdetails enthalten.\nUnabh\u00e4ngig davon, wieviele Logisim-Projekte Sie gleichzeitig ge\u00f6ffnet haben, so wird es nur ein gemeinsames Kombinatorikfenster geben. Es gibt keine M\u00f6glichkeit, gleichzeitig mit mehreren Kombinatorikfenstern zu arbeiten.\n\u00dcber das Projektmen\u00fc\nAus dem Bearbeitungsfenster einer Schaltung heraus, k\u00f6nnen Sie Logisim dazu veranlassen, diese Schaltung zu analisieren, indem Sie die Funktion \"Schaltung analysieren\" aus dem Projektmen\u00fc aufrufen. Bevor Logisim das entsprechende Fenster \u00f6ffnet, wird das Programm die booleschen Ausdr\u00fccke und die Wahrheitstabelle der dargestellten Schaltung berechnen. Diese werden Ihnen dann im Dialogfenster angezeigt.\nDamiut diese Analyse erfolgreich durchgef\u00fchrt werden kann, mu\u00df jeder Eingang der Schaltung an einen Eingangspin und jeder Ausgang an einen Ausgangspin angeschlossen sein. Logisim ist nur in der Lage, Schaltungen mit bis zu jeweils acht Ein- und Ausg\u00e4ngen zu analysieren. Diese Pins m\u00fcssen Einzelbitanschl\u00fcsse sein. Anderenfalls wird Ihnen eine entsprechende Fehlermeldung angezeigt werden, und das Kombinatorikfenster wird nicht ge\u00f6ffnet.\nBei der Erstellung der booleschen Ausdr\u00fccke zur Funktion einer Schaltung, wird Logisim zun\u00e4chst von der exakten Abfolge der Gatter in der Schaltung ausgehen. Aber wenn die Schaltung komplexere Bauelemente (z.B. Multiplexer) enth\u00e4lt, oder wenn die Schaltung mehr als 100 Ebenen aufweist (was ziemlich unwahrscheinlich sein d\u00fcrfte), dann wird Ihnen in einem entsprechenden Fenster angezeigt, da\u00df Logisim nicht in der Lage war, die booleschen Ausdr\u00fccke herzuleiten. Stattdessen wird Logisim dann neue Ausdr\u00fccke aus der Wahrheitstabelle ableiten, die durch ein konsequentes Durchtesten aller m\u00f6glichen Eingangskombinationen erstellt wird.\nNach erfolgter Analyse der Funktion der Schaltung, existiert keine weitere Verbindung zwischen der urspr\u00fcnglichen Schaltung und dem Kombinatorikfenster mehr. Das bedeutet insbesondere, da\u00df sp\u00e4tere \u00c4nderungen an der Schaltung nicht im Kombinatorikfenster ber\u00fccksichtigt werden, und da\u00df \u00c4nderungen an der Wahrheitstabelle oder der booleschen Ausdr\u00fccke im Kombinatorikfenster keinerlei Einflu\u00df auf die urspr\u00fcngliche Schaltung haben. Nat\u00fcrlich steht es Ihnen jederzeit frei, die Schaltung erneut analysieren zu lassen. Und wie wir sp\u00e4ter sehen werden, so k\u00f6nnen Sie die bestehende Schaltung durch eine neue Schaltung ersetzen lassen, die auf den aktuellen Werten des Kombinatorikfensters basiert.\nBegrenzungen\nLogisim wird nicht versuchen, die genaue Funktion einer sequentielle Schaltung zu analysieren: wenn Sie dennoch eine solche Schaltung anaIysieren lassen, so wird das Programm zwar eine Wahrheitstabelle und die zugeh\u00f6rigen booleschen Ausdr\u00fccke erstellen, aber diese werden das wirkliche Verhalten der Schaltung nicht korrekt wiedergeben. (Es l\u00e4\u00dft sich beweisen, da\u00df eine Analyse einer sequentiellen Schaltung nicht m\u00f6glich ist, da dies einer L\u00f6sung des Halteproblems gleichkommt. Nat\u00fcrlich w\u00fcrden Sie erwarten, da\u00df Logisim zumindest versuchen w\u00fcrde, z.B. nach Flip-Flops oder r\u00fcckgef\u00fchrten Leitungen zu suchen - aber das amcht das Programm nicht.) Daher sollten Sie die kombinatorische Analyse nicht unkritisch benutzen: Nur wenn Sie sicher sind, da\u00df Ihre Schaltung wirklich kombinatorisch ist, sollten Sie diese Funktion benutzen!\nLogisim wird \u00c4nderungen an Ihrer Schaltung vornehmen, die Sie vielleicht nicht erwarten w\u00fcrden: die kombinatorische Analyse erfordert, da\u00df jeder Ein- und Ausgang einen eindeutigen Namen besitzt, der den Regeln f\u00fcr Bezeichner unter Java gen\u00fcgt. (Grob gesagt mu\u00df jedes Zeichen entweder ein Buchstabe oder eine Ziffer sein, und das erste Zeichen mu\u00df ein Buchstabe sein. Keine Leerzeichen sind erlaubt!) Das Programm versucht zun\u00e4chst, bereits vorhandene Bezeichnungen zu verwenden. Wenn keine Bezeichnung existiert, wird eine intern vorgegebene Liste mit Bezeichnungen verwendet. Wenn eine existierende Bezeichnung nicht den Anforderungen an einen Java-Bezeichner gen\u00fcgt, wird Logisim versuchen, soweit m\u00f6glich, aus der vorhandenen Bezeichnung einen g\u00fcltigen Namen zu erzeugen.\n\u00dcbrigens h\u00e4ngt die Reihenfolge der Eing\u00e4nge in der Wahrheitstabelle von der Position der Eing\u00e4nge in der Schaltung ab, von links nach rechts und von oben nach untern. (Dasselbe gilt auch f\u00fcr die Reihenfolge der Ausg\u00e4nge.)\nBearbeiten der Wahrheitstabelle\n."
  },
  {
    "id": 25,
    "title": "Bearbeiten der Wahrheitstabelle",
    "url": "/de/html/guide/analyze/table.html",
    "text": "Bearbeiten der Wahrheitstabelle\nBearbeiten der Wahrheitstabelle\nWenn Sie das Kombinatorikfenster \u00f6ffnen, werden Sie sehen, da\u00df es f\u00fcnf Registerkarten enth\u00e4lt.Diese Seite wird die ersten drei Registerkarten beschreiben: Eing\u00e4nge, Ausg\u00e4nge und Tabelle. Die n\u00e4chste Seite des Leitfadens beschreibt die letzten zwei Registerkarten: Ausdruck und Kleinstm\u00f6glich.\nDie Registerkarten Eing\u00e4nge und Ausg\u00e4nge\nDie Registerkarte der Eing\u00e4nge erlaubt es Ihnen, sich die Liste der Eing\u00e4nge anzusehen, und diese zu bearbeiten. Um neue Eing\u00e4nge hinzuzuf\u00fcgen, tragen Sie den gew\u00fcnschten Namen im Eingabefeld unten im Fensterbereich\nein, und klicken dann auf Hinzuf\u00fcgen. Wenn Sie einen bereits definierten Eingang umbenennen m\u00f6chten, so markieren Sie diesen in der Liste im oberen Bereich, dann tragen Sie den neuen Namen in das Eingabefeld ein, und klicken auf Umbenennen.\nUm einen Eingang zu entfernen, w\u00e4hlen Sie diesen in der Liste aus, und klicken auf Entfernen. Sie k\u00f6nnen auch die Reihenfolge der Eing\u00e4nge in der Tabelle \u00e4ndern (was sich auf die Reihenfolge der Spalten in der Wahrheitstabelle und auf die erzeugte Schaltung auswirken wird), indem Sie die Schaltfl\u00e4chen \"Nach oben\" und \"Nach unten\" benutzen, nachdem Sie einen Eingang in der Liste markiert haben.\nAlle Aktionen wirken sich unmittelbar auf die Wahrheitstabelle aus.\nDie Registerkarte der Ausg\u00e4nge verwenden Sie auf genau dieselbe Weise, nur bezieht sich diese nat\u00fcrlich auf die Ausg\u00e4nge.\nDie Registerkarte \"Tabelle\"\nDas einzige Element auf der Registerkarte der Wahrheitstabelle ist die aktuelle Wahrheitstabelle. Diese wird auf g\u00e4ngige Art dargestellt, mit den Spalten, die die Eing\u00e4nge repr\u00e4sentieren, auf der linken Seite und den Ausg\u00e4ngen auf der rechten Seite.\nSie k\u00f6nnen die einzelnen Werte in den Ausgangsspalten durch Anklicken mit der Maus \u00e4ndern. Die angeklickten Positionen rotieren durch die Werte\n0, 1 und x (f\u00fcr einen beliebigen Zustand, \"don't care\"). Wie wir auf der n\u00e4chsten Seite sehen werden, so geben beliebige Zust\u00e4nde eine gewisse Flexibilit\u00e4t bei der Berechnung der kleinstm\u00f6glichen Ausdr\u00fccke.\nSie k\u00f6nnen auch mit der Tastatur durch die Wahrheitstabelle navigieren. Und Sie k\u00f6nnen Werte \u00fcber die Zwischenablage kopieren und einf\u00fcgen. Die Zwischenablage kann mit jedem anderen Programm ausgetauscht werden, das durch Tabulatoren getrennten Text unterst\u00fctzt (wie z.B. eine Tabellenkalkulation).\nWenn die Wahrheitstabelle aus der Analyse einer existierenden Schaltung stammt, dann werden Sie eventuell rosa Felder mit \"!!\" in einigen Feldern der Ausgangsspalten vorfinden. Diese entsprechen Fehlern, die bei der Berechnung der Ausgangswerte der entsprechenden Zeile aufgetreten sind - entweder, weil die Schaltung offenbar oszillierte, oder weil der Ausgang einen fehlerhaften Wert aufgewiesen hat (was im Schaltbild durch eine rote Leitung angezeigt wird). Wenn Sie den Mauszeiger \u00fcber das entsprechende Feld schieben, wird Ihnen in einem Hinweis angezeigt, um was f\u00fcr einen Fehler es sich tats\u00e4chlich gehandelt hat. Wenn Sie ein solches, fehlerbehaftetes Feld einmal angeklickt haben, kommen Sie automatisch in die 0-1-x-Folge, und es gibt keinen Weg mehr zur\u00fcck.\nErstellen von Ausdr\u00fccken\n."
  },
  {
    "id": 26,
    "title": "Erstellen von Ausdr\u00fccken",
    "url": "/de/html/guide/analyze/expr.html",
    "text": "Erstellen von Ausdr\u00fccken\nErstellen von Ausdr\u00fccken\nF\u00fcr jede Ausgangsvariable enth\u00e4lt das Fenster zur kombinatorischen Analyse zwei Strukturen - die entsprechende Spalte in der Wahrheitstabelle und ein boolescher Ausdruck - die angeben, wie jede Ausgabe mit den Eing\u00e4ngen zusammenh\u00e4ngt. Sie k\u00f6nnen die Wahrheitstabelle oder den booleschen Ausdruck bearbeiten, die jeweils andere Struktur wird automatisch entsprechend aktualisiert\nWie wir auf der n\u00e4chsten Seite sehen werden, sind die booleschen Ausdr\u00fccke besonders wichtig, denn die kombinatorische Analyse von Logisim geht von diesen aus, wenn die Schaltung automatisch konstruiert werden soll.\nSie k\u00f6nnen sich die Ausdr\u00fccke mit Hilfe der letzten beiden letzten Registerkarten \"Ausdruck\" und \"Kleinstm\u00f6glich\" ansehen und bearbeiten.\nDie Registerkarte \"Ausdruck\"\nDie Registerkarte \"Ausdruck\" erlaubt es Ihnen, die booleschen Ausdr\u00fccke jeder einzelnen Ausgangsvariable anzusehen und zu bearbeiten. Im Auswahlfeld oben auf der Registerkarte \"Ausgang\" w\u00e4hlen Sie den gew\u00fcnschten Ausgang.\nDirekt unter dieser Auswahl wird Ihnen dann der Ausdruck in der g\u00e4ngigen Schreibweise dargestellt, wo eine OR-Verkn\u00fcpfung (ODER) als Addition und eine AND-Verkn\u00fcpfung (UND) als Multiplikation geschrieben wird. Eine Negation wird durch einen Strich oberhalb des entsprechenden Teilausdruckes angezeigt.\nDas Textfeld darunter stellt denselben Ausdruck in einer ASCII-Form dar. Hier wird eine Negation durch eine vorangestellte Tilde ('~') dargestellt.\nSie k\u00f6nnen den Ausdruck im Textfeld bearbeiten. Die Bearbeitung schlie\u00dfen Sie ab, indem Sie die Eingabetaste bet\u00e4tigen oder auf die entsprechende Schaltfl\u00e4che klicken. Damit wird dann auch automatisch die Wahrheitstabelle entsprechend aktualisiert. Die Schaltfl\u00e4che \"L\u00f6schen\" entfernt den Ausdruck aus dem Textfeld, und die Schaltfl\u00e4che \"Zur\u00fccknehmen\" macht die letzten \u00c4nderungen R\u00fcckg\u00e4ngig und stellt den vorhergehenden Zustand wieder her.\nBeachten Sie, da\u00df Ihre \u00c4nderungen am booleschen Ausdruck verloren gehen, wenn Sie die Wahrheitstabelle bearbeiten.\nZus\u00e4tzlich zu Multiplikation und Addition f\u00fcr AND und OR darf der von Ihnen eingegebene Ausdruck die unter C/Java \u00fcblichen, logischen Operatoren, als auch die entsprechenden W\u00f6rter selbst verwendet werden.\nh\u00f6chste Priorit\u00e4t~ ! NOT\n(kein Zeichen) & && AND\n^ XOR\nniedrigste Priorit\u00e4t+ | || OR\nDie folgenden Beispiele sind allesamt g\u00fcltige Darstellungen desselben Ausdrucks. Sie d\u00fcrfen die Ausdr\u00fccke auch mischen.\n~a (b + c)\n!a && (b || c)\nNOT a AND (b OR c)\nIm allgemeinen spielen Klammern innerhalb einer Folge von AND-Verknpfungen (oder OR oder XOR) keine Rolle. (Bei der Erstellung einer entsprechenden Schaltung wird Logisim derartige Klammern ignorieren.)\nDie Registerkarte \"Kleinstm\u00f6glich\"\nDie letzte Registerkarte stellt einen minimalen Produktsummenausdruck f\u00fcr jeweils eine Spalte der Wahrheitstabelle dar. Mit dem Auswahlfeld oben auf der Seite bestimmen Sie, f\u00fcr welchen Ausgang dieser minimale Ausdruck dargestellt werden soll.\nF\u00fcr den Fall von vier oder weniger Eing\u00e4ngen wird auch ein Karnaughdiagramm f\u00fcr die ausgew\u00e4hlte Variable dargestellt. Durch Klicken in das Karnaughdiagramm k\u00f6nnen Sie die einzelnen Eintr\u00e4ge der zugeh\u00f6rigen Wahrheitstabelle \u00e4ndern. Im Karnaughdiagramm werden die Produktterme des kleinstm\u00f6glichen Ausdrucks als halbdurchsichtige Rechtecke mit abgerundeten Ecken dargestellt.\nDarunter wird der kleinstm\u00f6gliche Ausdruck selbst angezeigt. Die Formatierung entspricht derjenigen auf der Registerkarte \"Ausdruck\". F\u00fcr mehr als vier Eing\u00e4nge wird das Karnaughdiagramm nicht angezeigt, der zugeh\u00f6rige, kleinstm\u00f6gliche Ausdruck wird aber trotzdem berechnet. (Logisim verwendet den Quine-McCluskey-Algorithmus f\u00fcr die Berechnung des kleinstm\u00f6glichen Ausdrucks. Das Ergebnis entspricht dem eines Karnaughdiagrammes, kann aber f\u00fcr eine beliebige Anzahl von Eing\u00e4ngen berechnet werden.)\nMittels der Schaltfl\u00e4che \"Als Ausdruck festlegen\" \u00fcbernehmen Sie den dargestellten, kleinstm\u00f6glichen Ausdruck als Ausdruck f\u00fcr den gew\u00e4hlten Ausgang. Normalerweise wird dies nicht notwendig sein, weil Bearbeitungen der Wahrheitstabelle automatisch zu einem kleinstm\u00f6glichen Ausdruck der entsprechenden Spalte f\u00fchren. Wenn Sie aber einen Ausdruck im \u00fcber die Registerkarte \"Ausdruck\" bearbeitet haben, so k\u00f6nnen Sie diesen in eine kleinstm\u00f6gliche Form bringen lassen."
  },
  {
    "id": 27,
    "title": "Erstellen einer Schaltung",
    "url": "/de/html/guide/analyze/gen.html",
    "text": "Erstellen einer Schaltung\nErstellen einer Schaltung\nDie Schaltfl\u00e4che \"Schaltung aufbauen\" l\u00e4\u00dft Logisim eine Schaltung entwerfen, deren Gatter den aktuellen Ausdr\u00fccken der einzelnen Ausg\u00e4nge entsprechen. Die Ein- und Ausg\u00e4nge der Schaltung werden in derselben Reihenfolge erstellt und dargestellt, mit der diese in den Registerkarten f\u00fcr Ein- und Ausg\u00e4nge festgelegt worden sind. Generell wird eine atraktive Schaltung aufgebaut werden, und tats\u00e4chlich ist eine Funktion des Kombinatorik-Moduls von Logisim, schlecht gezeichnete Schaltungsdiagramme zu versch\u00f6nern. Aber, wie immer bei einer automatischen Formatierung, wird die aufgebaute Schaltung nicht die gleichen strukturellen Details aufweisen, wie eine von Menschenhand gezeichnete.\nWenn Sie auf die Schaltfl\u00e4che zum Aufbau der Schaltung klicken, wird Ihnen ein Dialogfenster pr\u00e4sentiert. In diesem geben Sie an, in welchem Projekt und mit welchem Namen die Schaltung aufgebaut werden soll. Wenn Sie den Namen einer bereits existierenden Schaltung angeben, wird diese \u00fcberschrieben (nachdem Sie in einem weiteren Fenster best\u00e4tigt haben, da\u00df dies wirklich passieren soll).\nDer Dialog zum Aufbau der Schaltung bietet Ihnen zwei Wahlm\u00f6glichkeiten. Der Punkt \"Nur Gatter mit zwei Eing\u00e4ngen\" legt fest, da\u00df ausschlie\u00dflich Gatter mit zwei Eing\u00e4ngen verwendet werden sollen. (Inverter sind nat\u00fcrlich nicht an diese Regel gebunden.) Der Punkt \"nur NAND-Gatter\" legt fest, da\u00df ausschlie\u00dflich NAND-Gatter zur Verwirklichung der booleschen Ausdr\u00fccke verwendet werden sollen. Beide Punkte lassen sich kombinieren, so da\u00df ausschlie\u00dflich NAND-Gatter mit zwei Eing\u00e4ngen verwendet werden.\nLogisim kann keine Schaltung ausschlie\u00dflich aus NAND-Gattern aufbauen, die XOR-Terme enth\u00e4lt. Dieser Punkt ist daher deaktiviert, wenn die logischen Ausdr\u00fccke XOR-Verkn\u00fcpfungen enthalten."
  },
  {
    "id": 28,
    "title": "Men\u00fcreferenz",
    "url": "/de/html/guide/menu/index.html",
    "text": "Menu Reference\nMenu Reference\nThis section explains the six menus that accompany\nevery major Logisim window.\nThe File menu\nThe Edit menu\nThe Project menu\nThe Simulate menu\nThe Window and Help menus\nMany menu items relate specifically to a currently opened\nproject.\nBut some Logisim windows (particularly the Combinational Analysis window and the\nApplication Preferences window) are\nnot associated with projects. For these windows, the project-specific\nmenu items will be disabled."
  },
  {
    "id": 29,
    "title": "Das Dateimen\u00fc",
    "url": "/de/html/guide/menu/file.html",
    "text": "Das Dateimen\u00fc\nDas Dateimen\u00fc\nNeu\n\u00d6ffnet ein neues Projekt in einem neuen Fenster. Das neue Projekt ist zun\u00e4chst eine Kopie der gerade ausgew\u00e4hlten Vorlage.\n\u00d6ffnen...\n\u00d6ffnet eine existierende Datei als Projekt in einem neuen Fenster.\nZuletzt ge\u00f6ffnet\n\u00d6ffnet ein k\u00fcrzlich bearbeitetes Projekt in einem neuen Fenster, ohne, da\u00df der Benutzer durch einen Dateidialog navigieren mu\u00df.\nSchlie\u00dfen\nSchlie\u00dft alle Fenster des aktuell angezeigten Projekts.\nSpeichern\nSpeichert das aktuell angezeigte Projekt, und \u00fcberschreibt dabei eine eventuell vorhandene Datei.\nSpeichern unter...\nSpeichert das aktuell angezeigte Projekt, und fragt den Benutzer nach einem neuen Dateinamen.\nBild exportieren...\nErzeugt eine Bilddatei, die die Schaltung darstellt. Der zugeh\u00f6rige Konfigurationsdialog ist weiter unten beschrieben.\nDrucken...\nSendet die Schaltung an einen Drucker. Der zugeh\u00f6rige Konfigurationsdialog ist weiter unten beschrieben.\nVoreinstellungen...\n\u00d6ffnet den Dialog der\nprogrammbezogenen Einstellungen. (Auf Mac OS-Systemen wird dies im Logisim-Men\u00fc angezeigt.)\nBeenden\nSchlie\u00dft alle derzeit ge\u00f6ffneten Projekte und beendet Logisim. (Auf Mac OS-Systemen wird dies als Beenden im Logisim-Men\u00fc angezeigt.)\nExport konfigurieren\nWenn Sie den Punkt \"Bild exportieren...\" aufrufen, \u00f6ffnet Logisim ein Dialogfenster mit vier Optionen.\nSchaltungen: Eine Liste, aus der Sie eine oder mehrere Schaltungen ausw\u00e4hlen k\u00f6nnen, deren Bild exportiert werden soll. (Leere Schaltungen erscheinen nicht in dieser Liste.)\nBildformat: Hier k\u00f6nnen Sie zwischen PNG-, GIF- und JPEG-Dateien w\u00e4hlen. Das empfohlene Format sind PNG-Dateien: Das GIF-Dateiformat ist schon ziemlich betagt, und das JPEG-Format f\u00fchrt zu Komprimierungs-Artefakten, weil JPEG-Dateien eigentlich f\u00fcr fotografische Abbildungen entwickelt wurden.\nSkalierung: Sie k\u00f6nnen das Bild mit diesem Schieberegler skalieren, bevor es gespeichert wird.\nDruckeransicht: W\u00e4hlt aus, ob die \"Druckeransicht\" beim Export verwendet werden soll.\nNach dem Anklicken der Schaltfl\u00e4che OK wird Logisim einen Dateidialog anzeigen. Wenn Sie eine einzelne Schaltung ausgew\u00e4hlt haben, dann w\u00e4hlen Sie hier aus, in welcher Datei Das Bild gespeichert werden soll. Wenn Sie mehrere Schaltungen ausgew\u00e4hlt haben, dann w\u00e4hlen Sie nur das Verzeichnis aus, in das die Bilddateien gespeichert werden sollen. Logisim wird die einzelnen Bilddateien nach den Namen der Schaltungen benennen (zum Beispiel main.png).\nDrucken konfigurieren\nWenn Sie den Punkt \"Drucken...\" aufrufen, \u00f6ffnet Logisim ein Dialogfenster zur Konfiguration des Ausdrucks.\nSchaltungen: Eine Liste, aus der Sie eine oder mehrere Schaltungen ausw\u00e4hlen k\u00f6nnen, deren Bild gedruckt werden soll. (Leere Schaltungen erscheinen nicht in dieser Liste.) Logisim druckt eine Schaltung pro Druckseite. Wenn die Schaltung zu gro\u00df f\u00fcr die Seite ist, wird das Bild passend verkleinert werden.\nTitel: Der Text, der zentriert oben auf jeder einzelnen Seite erscheinen soll. Die folgenden Substitutionen werden im Text vorgenommen.\n%nName der Schaltung auf der Seite\n%pSeitennummer\n%PGesamtseitenzahl\n%%Ein einzelnes Prozentzeichen ('%')\nDrehen zum Anpassen: Wenn angekreuzt wird Logisim das Druckbild um 90 Grad drehen, wenn dies eine bessere Ausnutzung der Druckseite erlaubt.\nDruckeransicht: W\u00e4hlt aus, ob die \"Druckeransicht\" beim Drucken verwendet werden soll.\nNach dem Anklicken der Schaltfl\u00e4che OK wird Logisim den Standard-Dialog zum Einrichten der Seite vor dem Druck der Schaltungen anzeigen."
  },
  {
    "id": 30,
    "title": "Das Bearbeitungsmen\u00fc",
    "url": "/de/html/guide/menu/edit.html",
    "text": "Das Bearbeitungsmen\u00fc\nDas Bearbeitungsmen\u00fc\nXX zur\u00fccknehmen\nNimmt die zuletzt vorgenommenen \u00c4nderungen zur\u00fcck, die sich darauf beziehen, wie die Schaltung gespeichert werden w\u00fcrde. Beachten Sie, da\u00df dies keine \u00c4nderungen am Zustand der Schaltung einschlie\u00dft (wie mit dem Schaltwerkzeug durchgef\u00fchrte \u00c4nderungen).\nAusschneiden\nEntfernt die aktuell ausgew\u00e4hlten Elemente der Schaltung und platziert diese in der Zwischenablage von Logisim.\nHinweis: Diese Zwischenablage von Logisim wird unabh\u00e4ngig von der Zwischenablage von Windows verwaltet, was bedeutet, da\u00df das Ausschneiden/Kopieren/Einf\u00fcgen nicht zwischen Logisim und anderen Programmen funktioniert, noch nicht einmal zwischen verschiedenen Instanzen von Logisim.\nWenn aber verschiedene Projekte in ein und demselben Logisim-Prozess ge\u00f6ffnet sind, dann sollte\ndas Ausschneiden/Kopieren/Einf\u00fcgen zwischen diesen Projekten m\u00f6glich sein.\nKopieren\nKopiert die aktuell ausgew\u00e4hlten Elemente der Schaltung in die Zwischenablage von Logisim. (Beachten Sie die Hinweise unter dem Punkt Ausschneiden.)\nEinf\u00fcgen\n\u00dcbernimmt den Inhalt der Zwischenablage von Logisim als aktuelle Auswahl in die Schaltung. (Beachten Sie die Hinweise unter dem Punkt Ausschneiden.)\nDie eingef\u00fcgten Elemente werden nicht unmittelbar eingef\u00fcgt, vielmehr erscheinen Sie als hellgraue Auswahl. Die Elemente werden erst dann in die Schaltung ``eingef\u00fcgt'', wenn Sie die Auswahl verschieben oder \u00e4ndern, so da\u00df die Elemente sich nicht mehr innerhalb der Auswahl befinden.\nDer Grund f\u00fcr dieses Verhalten liegt in einer anderen Eigenschaft von Logisim: Logisim mu\u00df alle Verbindungsleitungen unmittelbar zusammenf\u00fchren, sobald diese in eine Schaltung eingef\u00fcgt werden, und dies \u00e4ndert die bereits in der Schaltung befindlichen Leitungen. Aber wenn Sie Leitungen aus der Zwischenablage einf\u00fcgen, m\u00f6chten Sie diese eventuell an einer anderen Stelle einf\u00fcgen, und das unmittelbare Zusammenf\u00fchren k\u00f6nnte Ihren Vorstellungen widersprechen.\nL\u00f6schen\nEntfernt alle Elemente der aktuellen Auswahl, ohne diese in die Zwischenablage zu \u00fcbernehmen.\nDuplizieren\nErstellt eine Kopie aller Elemente in der aktuellen Auswahl. Der Effekt ist derselbe, wie das Ausf\u00fchren von Kopieren und Einf\u00fcgen, abgesehen davon, da\u00df hier die Zwischenablage nicht ver\u00e4ndert wird.\nAlles ausw\u00e4hlen\nW\u00e4hlt alle Elemente der aktuellen Schaltung aus.\nAuswahl anheben\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und erlaubt das Anheben der ausgew\u00e4hlten Objekte, so da\u00df diese \u00fcber anderen, \u00fcberlappenden Objekten gezeichnet werden. Wenn das ausgew\u00e4hlte Objekt durch mehrere andere Objekte verdeckt ist, so wird es mit jedem Aufruf dieser Funktion nur um eine Ebene angehoben. Verwenden Sie die Funktion mehrmals, bis das Objekt so dargestellt wird, wie Sie es w\u00fcnschen.\n(Festzustellen, ob zwei beliebige Objekte \u00fcberlappen, ist schwierig. Logisim benutzt einen Algorithmus zur zuf\u00e4lligen Auswahl mehrerer Punkte in jedem der beiden Objekte, um dann zu \u00fcberpr\u00fcfen, ob der Punkt sich auch in dem anderen Objekt befindet. Wenn die \u00dcberlappung nur klein ist, weniger als 5% von beiden Objekten, kann diese Methode versagen.)\nAuswahl absenken\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und erlaubt das Absenken der ausgew\u00e4hlten Objekte, so da\u00df diese unter anderen, \u00fcberlappenden Objekten gezeichnet werden. Wenn das ausgew\u00e4hlte Objekt durch mehrere andere Objekte \u00fcberschneidet, so wird es mit jedem Aufruf dieser Funktion nur um eine Ebene abgesenkt. Verwenden Sie die Funktion mehrmals, bis das Objekt so dargestellt wird, wie Sie es w\u00fcnschen.\nNach oben\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und erlaubt das Anheben der ausgew\u00e4hlten Objekte, so da\u00df diese \u00fcber allen anderen, \u00fcberlappenden Objekten gezeichnet werden. (Ankerpunkte und Pins sind Ausnahmen \u2014 diese sind immer ganz oben.)\nNach unten\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und erlaubt das Absenken der ausgew\u00e4hlten Objekte, so da\u00df diese unter allen anderen, \u00fcberlappenden Objekten gezeichnet werden.\nKnoten hinzuf\u00fcgen\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und wenn ein Punkt auf einer Linie, einem Linienzug oder Vieleck ausgew\u00e4hlt ist. Dann f\u00fcgt diese Funktion einen neuen Knotenpunkt zu dieser Struktur hinzu. Vor dem Hinzuf\u00fcgen wird der Punkt als Rhombus gezeichnet.\nKnoten entfernen\nDiese Funktion ist nur bei der Bearbeitung des Aussehens einer Schaltung verf\u00fcgbar, und wenn ein Punkt auf einer Linie, einem Linienzug oder Vieleck ausgew\u00e4hlt ist. Dann l\u00f6scht diese Funktion den aktuell markierten Knotenpunkt. Vor dem Entfernen wird der ausgew\u00e4hlte Knotenpunkt als Rhombus in einem Quadrat angezeigt. Logisim l\u00e4\u00dft es nicht zu, einen Knotenpunkt aus einem Vieleck mit nur drei Punkten oder einem Linienzug mit nur zwei Punkten zu entfernen."
  },
  {
    "id": 31,
    "title": "Das Projektmen\u00fc",
    "url": "/de/html/guide/menu/project.html",
    "text": "Das Projektmen\u00fc\nDas Projektmen\u00fc\nAdd Circuit...\nAdds a new circuit into the current project. Logisim will\ninsist that you name the new circuit. The name must not match\nany existing circuits in the project.\nLoad Library\nLoads a library into the\nproject. You can load three types of libraries, as explained elsewhere in the User's\nGuide.\nUnload Libraries...\nUnloads current libraries from the project. Logisim will\nnot permit you to unload any libraries currently being used,\nincluding libraries containing components appearing in any\nproject circuits, as well as those with tools that appear in\nthe toolbar or that are mapped to the mouse.\nMove Circuit Up\nMoves the currently displayed circuit one step up the list of\ncircuits within the project, as displayed in the explorer pane.\nMove Circuit Down\nMoves the currently displayed circuit one step down the list of\ncircuits within the project, as displayed in the explorer pane.\nSet As Main Circuit\nSets the currently displayed circuit to be the project's\nmain circuit. (This menu item will be grayed out if the\ncurrent circuit is already the project's main circuit.)\nThe only significance of the main circuit is that it is the\ncircuit that first appears when a project file is opened.\nEdit Circuit Layout\nSwitches to allow you to edit how the layout of components that\ndetermines how the circuit works. This is what the program does when it starts,\nand you will edit circuit layouts most often using Logisim, so this menu item\nis normally disabled.\nEdit Circuit Appearance\nSwitches to allow you to edit how the circuit will be represented\nwhen it is used as a subcircuit within another circuit. By default, the circuit\nis represented as a rectangle with a gray notch on its north end, but\nthis menu option allows you to draw a different appearance for the\nsubcircuit.\nRevert To Default Appearance\nIf you've edited the circuit's appearance, this menu item reverts\nthe appearance back to the default rectangle-with-notch appearance.\nThe menu item is enabled only when editing the circuit's appearance.\nRemove Circuit\nRemoves the currently displayed circuit from the project.\nLogisim will prevent you from removing circuits that are used as\nsubcircuits, and it will prevent you from removing the final\ncircuit in a project.\nAnalyze Circuit\nComputes a truth table and Boolean expressions corresponding\nto the current circuit, displaying them in\nthe Combinational Analysis window.\nThe analysis process will only be valid for combinational circuits.\nA full description of the analysis process is described\nin the\nCombinational Analysis section.\nGet Circuit Statistics\nShows a dialog containing statistics about components used by the\ncurrently viewed circuit. The dialog includes a table with five columns:\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nSimple: The number of times that component appears directly within the viewed circuit.\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nThe distinction between Unique and Recursive is easiest to\nexplain by considering the 4:1 multiplexer built using three 2:1 multiplexers\nas in the Using subcircuits section.\nThe 2:1 multiplexer contains two AND gates (and the 4:1 circuit includes none),\nso the Unique count\nof AND gates would be 2; but if you were to build the 4:1 multiplexer using this\ndiagram, you would actually need 2 AND gates for each of the three 2:1 multiplexers,\nso the Recursive count is 6.\nIf you are using circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\nOptions...\nOpens the Project Options\nwindow."
  },
  {
    "id": 32,
    "title": "Das Simulationsmen\u00fc",
    "url": "/de/html/guide/menu/simulate.html",
    "text": "Das Simulationsmen\u00fc\nDas Simulationsmen\u00fc\nSimulation Enabled\nIf checked, circuits viewed will be \"live:\" That is, the\nvalues propagating through the circuit will be updated with each\npoke or change to the circuit.\nThe menu option will be automatically unchecked if\ncircuit oscillation is\ndetected.\nReset Simulation\nClears everything about the current circuit's state, so that it\nis as if you have just opened the file again. If you are viewing a\nsubcircuit's state, the entire hierarchy is cleared.\nStep Simulation\nAdvances the simulation one step forward. For example, a signal may end up\nentering a gate during one step, but the gate won't show a different signal\nuntil the next simulation step. To help identify which points in the overall\ncircuit have changed, any points whose values change are indicated with a blue\ncircle; if a subcircuit contains any points that have changed in it (or its\nsubcircuits, recursively), then it will be drawn with a blue\noutline.\nGo Out To State\nWhen you delve into a\nsubcircuit's state via its pop-up menu, the Go Out To State\nsubmenu lists the\ncircuits above the currently viewed circuit's state. Selecting\none displays the corresponding circuit.\nGo In To State\nIf you have delved into a subcircuit's state and then moved\nback out, this submenu lists the subcircuits below the current\ncircuit. Selecting one of the circuits displays the\ncorresponding circuit.\nTick Once\nSteps one tick forward into the simulation. This can be useful\nwhen you want to step the clocks manually, particularly when the clock\nis not in the same circuit that you are currently viewing.\nTicks Enabled\nStarts automatically ticking the clock. This will have an\neffect only if the circuit contains any clock devices (in the Base\nlibrary). The option is disabled by default.\nTick Frequency\nAllows you to select how often ticks occur.\nFor example, 8 Hz\nmeans that ticks will occur eight times a second.\nA tick is the\nbase unit of measurement for the speed of clocks.\nNote that the clock cycle speed will be slower than the tick\nspeed: The fastest possible clock will have a one-tick up cycle\nand a one-tick down cycle; such a clock would have up/down cycle\nrate of 4 Hz if the ticks occur at 8 Hz.\nLogging...\nEnters the logging module, which\nfacilitates automatically noting and saving values in a circuit as a\nsimulation progresses.\nand Help menus."
  },
  {
    "id": 33,
    "title": "Die Fenster- und Hilfe-Men\u00fcs",
    "url": "/de/html/guide/menu/winhelp.html",
    "text": "Die Fenster- und Hilfe-Men\u00fcs\nThe Window menu\nMinimize\nMinimizes (iconifies) the current window.\nMaximize (Zoom on MacOS)\nResizes the current window to its preferred size.\nCombinational Analysis\nShows the current\nCombinational Analysis\nwindow, without changing any of its contents.\nindividual window titles\nBrings the respective window to the front.\nThe Help menu\nTutorial\nOpens the help system to the\n\"Beginner's Tutorial\" section of the\nGuide to Being a Logisim User.\nUser's Guide\nOpens the help system to the\nGuide to Being a Logisim User.\nBibliotheksreferenz\nOpens the help system to the\nLibrary Reference.\nAbout...\nDisplays a window containing the version number, mixed among the splash\nscreen graphics. (On MacOS, this menu item is under the Logisim menu.)"
  },
  {
    "id": 34,
    "title": "Speicherbauelemente",
    "url": "/de/html/guide/mem/index.html",
    "text": "Speicherbauelemente\nSpeicherbauelemente\nDie RAM- und ROM-Bauelemente sind zwei sehr n\u00fctzliche Bestandteile der eingebauten Bibliotheken von Logisim. Aufgrund der Menge an Daten, die in diesen gespeichert werden kann, sind es aber auch zwei der komplexesten Bauelemente.\nEine Beschreibung, wie diese Bauelemente in einer Schaltung verwendet werden k\u00f6nnen, finden Sie auf den Seiten RAM und ROM der Bibliotheksreferenz. Dieser Abschnitt des Leitfadens erl\u00e4utert die Verwendung der Schnittstelle zur Anzeige und Bearbeitung von Speicherinhalten.\nSpeicherinhalte bearbeiten Kontextmen\u00fcs und Dateien Der Hex-Editor von Logisim"
  },
  {
    "id": 35,
    "title": "Speicherinhalte bearbeiten",
    "url": "/de/html/guide/mem/poke.html",
    "text": "Speicherinhalte bearbeiten\nSpeicherinhalte bearbeiten\nSie k\u00f6nnen Speicherinhalte mit dem Schaltwerkzeug bearbeiten, dies ist aber durch den vorhandenen Platz eingeschr\u00e4nkt: abgesehen von den einfachsten \u00c4nderungen, werden Sie wohl auf den eingebauten Hex-Editor zur\u00fcckgreifen.\nNichtsdestoweniger bietet das Schaltwerkzeug zwei M\u00f6glichkeiten zum Zugriff auf den Speicher: Sie k\u00f6nnen die angezeigte Adresse ausw\u00e4hlen, und Sie k\u00f6nnen einzelne Werte \u00e4ndern.\nUm die dargestellte Adresse zu \u00e4ndern, klicken Sie au\u00dferhalb des Anzeigerechtecks. Logisim wird dann ein rotes Rechteck um die oberste Adresse zeichnen.\nDurch Eintippen hexadezimaler Ziffern k\u00f6nnen Sie diese Adresse entsprechend \u00e4ndern.\nDr\u00fccken der Eingabetaste wird eine Zeile weiter rollen.\nDr\u00fccken der R\u00fcckschritttaste wird eine Zeile nach oben rollen.\nDie Leertaste bl\u00e4ttert eine Seite weiter (vier Zeilen).\nUm einen bestimmten Wert zu \u00e4ndern, klicken Sie auf diesen Wert innerhalb des Anzeigerechtecks. Logisim wird dann einen roten Rahmen um diesen Wert zeichnen.\nDer dargestellte Wert l\u00e4\u00dft sich dann durch Eintippen hexadezimaler Ziffern ab\u00e4ndern.\nDas Bet\u00e4tigen der Eingabetaste wird Sie zum n\u00e4chsten Wert unter der aktuellen Position bringen (eine Zeile weiter).\nDie R\u00fcckschritttaste w\u00e4hlt den vorangehende Wert zur Bearbeitung aus.\nDie Leertaste geht zur folgenden Speicheradresse."
  },
  {
    "id": 36,
    "title": "Kontextmen\u00fcs und Dateien",
    "url": "/de/html/guide/mem/menu.html",
    "text": "Kontextmen\u00fcs und Dateien\nKontextmen\u00fcs und Dateien\nAbgesehen von den \u00fcblichen Punkten enth\u00e4lt das Kontextmen\u00fc f\u00fcr Speicherbauelemente vier weitere Optionen:\nInhalt bearbeiten...: \u00d6ffnet den Hex-Editor um den Speicherinhalt zu bearbeiten.\nInhalt l\u00f6schen: Setzt alle Werte im Speicher auf 0.\nSpeicherabbild laden...: Setzt alle Werte des Speichers auf die Werte aus einer Datei. Das Dateiformat ist weiter unten beschrieben.\nSpeicherabbild speichern...: Speichert alle Daten aus dem Speicher in dem unten beschriebenen Dateiformat.\nDas Dateiformat f\u00fcr Speicherabbilder wurde bewu\u00dft einfach gehalten. Dies erlaubt es Ihnen, eigene Programme, wie z.B. einen Assembler, zu schreiben, das Speicherabbilder erzeugt. Als ein Beispiel f\u00fcr das Dateiformat k\u00f6nnen wir den Fall eines Speichers mit 256 Byte betrachten, dessen f\u00fcnf erste Speicherstellen auf 2, 3, 0, 20 und -1 gesetzt sind, w\u00e4hrend alle folgenden Speicherstellen Nullen enthalten. Ein entsprechendes Speicherabbild sieht dann wie folgt aus:\nv2.0 raw\n02\n03\n00\n14\nff\nDie erste Zeile identifiziert das benutzte Dateiformat (zur Zeit gibt es nur ein unterst\u00fctztes Dateiformat). Die folgenden Eintr\u00e4ge bilden eine Liste der hexadezimalen Werte, die beginnend mit der Adresse 0 in den Speicher geschrieben werden. Mehrere Werte d\u00fcrfen in einer Zeile stehen. Wenn der Speicher mehr Speicherstellen hat, als Werte in der Datei vorhanden sind, f\u00fcllt Logisim die verbleibenden Positionen mit Nullen.\nDas Dateiformat unterst\u00fctzt eine Laufl\u00e4ngenkodierung: anstatt sechzehn Mal nacheinander den Wert 00 zu schreiben, k\u00f6nnen Sie dies mit 16*00 abk\u00fcrzen. Beachten Sie, da\u00df die Anzahl der Wiederholungen im Dezimalformat (mit der Basis 10) dargestellt wird. Beim Speichern von Dateien verwendet Logisim diese Laufl\u00e4ngenkodierung ab einer viermaligen Wiederholung desselben Wertes.\nMit dem '#'-Zeichen k\u00f6nnen Sie Kommentare in die Dateien einbetten: Alle Zeichen, die in einer Zeile auf eine solche Raute folgen, werden von Logisim ignoriert."
  },
  {
    "id": 37,
    "title": "Hex-Editor",
    "url": "/de/html/guide/mem/hex.html",
    "text": "Hex-Editor\nHex-Editor\nLogisim enth\u00e4lt einen eingebauten Hex-Editor zur Anzeige und Bearbeitung von Speicherinhalten. Dieser wird \u00fcber den Punkt \"Inhalt bearbeiten...\" aus dem Kontextmen\u00fc der Speicher-Bauelemente aktiviert. F\u00fcr ROM-Bauelemente, deren Speicherinhalt ein Teil der Attributwerte sind, kann der Hex-Editor auch \u00fcber einen Klick auf diesen Attributwert gestartet werden.\nDie kursiven hexadezimalen Zahlen auf der linken Seite geben die Speicheradresse an. Die restlichen Zahlen geben die Inhalte der jeweils auf diese Adresse folgenden Speicherzellen an. Je nach Breite des Fensters werden vier, acht oder sechzehn Werte pro Zeile angezeigt. Um das Abz\u00e4hlen zu erleichtern, ist nach jeweils vier Werten eine gr\u00f6\u00dfere L\u00fccke.\nMit Hilfe des Rollbalkens und mit der Tastatur (Pfeiltasten, Pos1, Ende, Bild hoch und Bild runter) k\u00f6nnen Sie durch den Speicher navigieren. Durch Eintippen von hexadezimalen Werten l\u00e4\u00dft sich der aktuelle Wert \u00e4ndern.\nSie k\u00f6nnen auch einen Bereich von Werten durch Ziehen mit der Maus oder durch Gedr\u00fcckhalten der Umschalttaste beim Klicken mit der Maus bzw. beim Navigieren mit der Tastatur ausw\u00e4hlen. \u00dcber das Men\u00fc \"Bearbeiten\" lassen sich Werte kopieren und einf\u00fcgen. Die dabei benutzte Zwischenablage l\u00e4\u00dft sich auch mit anderen Programmen austauschen."
  },
  {
    "id": 38,
    "title": "Ablaufverfolgung",
    "url": "/de/html/guide/log/index.html",
    "text": "Ablaufverfolgung\nAblaufverfolgung\nBeim Testen einer gr\u00f6\u00dferen Schaltung und zur Dokumentation des Verhaltens einer Schaltung, gibt es die M\u00f6glichkeit, das Verhalten der Schaltung zu protokollieren. Dies geschieht durch das Log-Modul von Logisim, das es Ihnen erlaubt, die Bauelemente auszuw\u00e4hlen, deren Werte protokolliert werden sollen. Dar\u00fcber hinaus k\u00f6nnen Sie ausw\u00e4hlen, in welche Datei diese Daten geschrieben werden sollen.\nWichtig: Das Log-Modul befindet sich in einer Alpha-Testphase: es kann Fehler enthalten und wird sich vermutlich in zuk\u00fcnftigen Versionen erheblich ver\u00e4ndern. W\u00e4hrend Fehlerberichte und Vorschl\u00e4ge zu Logisim immer willkommen sind, so gilt dies insbesondere v\u00fcr diese relativ neue Funktion. Wenn Sie keine Kommentare einschicken, wird sich vermutlich nicht viel \u00e4ndern.\nSie erreichen das Log-Modul \u00fcber den Punkt \"Loggen...\" aus dem Simulationsmen\u00fc. Dies wird ein Fenster mit drei Registerkarten \u00f6ffnen.Hier werden wir diese Registerkarten im Einzelnen beschreiben.\nDie Registerkarte \"Auswahl\"\nDie Registerkarte \"Tabelle\"\nDie Registerkarte \"Datei\"\nJedes Projekt besitzt nur ein einzelnes Log-Fenster. Wenn Sie zu einer anderen Schaltung desselben Projekts wechseln, wird auch das Log-Fenster automatisch zum Protokollieren der anderen Schaltung wechseln. Dies passiert jedoch nicht, wenn Sie in derselben Simulation auf- oder absteigen, dann wird sich das Log-Modul nicht ver\u00e4ndern.\nBeachten Sie, da\u00df das Loggen automatisch gestoppt wird, wenn das Log-Fenster zur Protokollierung einer anderen Simulation umschaltet. Wenn Sie danach zur vorigen Simulation zur\u00fcckkommen, dann werden zwar die entsprechenden Werte f\u00fcr diese Simulation wieder hergestellt, aber Sie m\u00fcssen die eigentliche Protokollierung manuell wieder starten..\nDie Registerkarte \"Auswahl\"\n."
  },
  {
    "id": 39,
    "title": "Die Registerkarte \"Auswahl\"",
    "url": "/de/html/guide/log/selection.html",
    "text": "Die Registerkarte \"Auswahl\"\nDie Registerkarte \"Auswahl\"\nAuf der Registerkarte \"Auswahl\" k\u00f6nnen Sie festlegen, welche Werte in das Protokoll aufgenommen werden sollen. Das unten abgebildete Fenster entspricht der folgenden Schaltung.\nDie Registerkarte ist in drei vertikale Bereiche aufgeteilt. Der linke Bereich ist eine Liste aller Bauelemente in der Schaltung, deren Werte geloggt werden k\u00f6nnen. Von der eingebauten Bibliothek unterst\u00fctzen die folgenden Bauelemente das Loggen von Werten:Basisbibliohtek: Pin-, Testpunkt- und Takt-Bauelemente Ein/Ausgabebibliothek: Taster- und LED-Bauelemente Speicherbibliothek: alle Bauelemente, abgesehen vom ROMDie Namen von Bauelementen mit Beschriftungen entsprechen dem Text der Beschriftung, anderenfalls gibt der Name den Typ und die Position des Bauelements in der Schaltung an. Auch alle Teilschaltungen werden in der Liste auftauchen. Diese k\u00f6nnen zwar nicht selbst geloggt werden, aber unterst\u00fctzte Bauelemente in den Teilschaltungen. Beachten Sie, da\u00df das RAM-Bauelement eine Angabe ben\u00f6tigt, der Inhalt welcher Speicheradresse(n) geloggt werden soll. Unterst\u00fctzt wird nur das Loggen der ersten 256 Adressen.\nDer rechte Bereich zeigt die ausgew\u00e4hlten Bauelemente. Es wird auch angezeigt, zu welcher Basis Mehrbit-Werte der Bauelemente geloggt werden. Die Angabe der Basis hat keinen Einflu\u00df auf Einzelbit-Werte.\nDie Schaltfl\u00e4chen in der Mitte erlauben die Manipulation der ausgew\u00e4hlten Elemente.\nHinzuf\u00fcgen f\u00fcgt die aktuell auf der linken Seite ausgew\u00e4hlte Elemente zur Auswahl hinzu.Basis \u00e4ndern wechselt f\u00fcr die ausgew\u00e4hlten Elemente zyklisch zwischen den Basen 2 (bin\u00e4r), 10 (dezimal) und 16 (hexadezimal).Nach oben bewegt die aktuell ausgew\u00e4hlte Komponente einen Platz nach oben.Nach unten bewegt die aktuell ausgew\u00e4hlte Komponente einen Platz nach unten.Entfernen entfernt die aktuell ausgew\u00e4hlte Komponente aus der Auswahl."
  },
  {
    "id": 40,
    "title": "Die Registerkarte \"Tabelle\"",
    "url": "/de/html/guide/log/table.html",
    "text": "Die Registerkarte \"Tabelle\"\nDie Registerkarte \"Tabelle\"\nDie Registerkarte \"Tabelle\" zeigt graphisch das aktuelle Protokoll.\nDie Tabelle enth\u00e4lt eine Spalte f\u00fcr jede Komponente in der Auswahl. Jede Zeile in der Tabelle zeigt eine Momentaufnahme der Simulation nachdem die Weiterleitung aller Signale abgeschlossen ist. Doppelte Zeilen werden nicht ins Protokoll aufgenommen. Beachten Sie auch, da\u00df nur die 400 neuesten Zeilen angezeigt werden. Einige Zeilen k\u00f6nnen auch leere Eintr\u00e4ge enthalten, wenn die entsprechende Komponente zu dem jeweiligen Zeitpunkt noch nicht in die Auswahl aufgenommen wurde.\nDie angezeigte Tabelle kann nicht ge\u00e4ndert werden, sie dient ausschlie\u00dflich der Anzeige."
  },
  {
    "id": 41,
    "title": "Die Registerkarte \"Datei\"",
    "url": "/de/html/guide/log/file.html",
    "text": "Die Registerkarte \"Datei\"\nDie Registerkarte \"Datei\"\nDie Registerkarte \"Datei\" erlaubt es, die Datei anzugeben, die das Protokoll aufnehmen soll.\nOben wird angezeigt, ob die Ablaufverfolgung aktiviert ist, und eine Schaltfl\u00e4che um das Loggen zu aktivieren und zu deaktivieren. (Beachten Sie, da\u00df vor der Aktivierung eine Datei ausgew\u00e4hlt sein mu\u00df.) Die Schaltfl\u00e4che erlaubt es, das Loggen zeitweise anzuhalten und fortzusetzen. Wenn Sie im Projektfenster auf eine andere Simulation wechseln, wird das Loggen automatisch angehalten. Wenn Sie danach wieder zur urspr\u00fcnglichen Simulation zur\u00fcckschalten, dann m\u00fcssen Sie das Loggen \u00fcber diese Schaltfl\u00e4che manuell wieder starten.\nIn der Mitte wird angezeigt, in welche Datei protokolliert wird. Um diese zu \u00e4ndern, benutzen Sie die Schaltfl\u00e4che \"Ausw\u00e4hlen...\". Nach der Auswahl einer Datei startet das Loggen automatisch. Wenn die ausgew\u00e4hlte Datei bereits existiert, wird Logisim fragen, ob Sie die Datei \u00fcberschreiben, oder das neue Protokoll am Ende der Datei anh\u00e4ngen m\u00f6chten.\nUnten k\u00f6nnen Sie ausw\u00e4hlen, ob eine Kopfzeile in die Datei geschrieben werden soll, die angibt, welche Elemente sich in der Auswahl befinden. Wenn Kopfzeilen abgespeichert werden, dann wird jeweils eine neue Kopfzeile geschrieben, wenn sich die Auswahl \u00e4ndert.\nDateiformat\nEintr\u00e4ge werden in einem durch Tabulatoren abgegrenzten Format geschrieben, das dem Inhalt der Registerkarte \"Tabelle\" \u00e4hnelt. (Ein Unterschied ist, da\u00df eine Kopfzeile den vollst\u00e4ndigen Pfad zu Bauelementen angeben w\u00fcrde, die sich in Teilschaltungen befinden.) Das Format ist absichtlich sehr einfach gehalten, damit Sie die Daten leicht in ein anderes Programm zur Auswertung \u00fcbernehmen k\u00f6nnen, wie z.B. ein Python/Perl-Skript oder eine Tabellenkalkulation.\nDamit ein anderes Programm gleichzeitig auf die Daten zugreifen kann, w\u00e4hrend die Simulation in Logisim l\u00e4uft, werden die Daten alle 500 ms weggeschrieben. Beachten Sie auch, da\u00df Logisim die Datei zwischenzeitlich schlie\u00dfen und sp\u00e4ter wieder \u00f6ffnen kann, insbesondere dann, wenn mehrere Sekunden vergehen, bevor neue Daten hinzugef\u00fcgt werden."
  },
  {
    "id": 42,
    "title": "Benutzung der Kommandozeile",
    "url": "/de/html/guide/verify/index.html",
    "text": "Benutzung der Kommandozeile\nBenutzung der Kommandozeile\nSubsections:\nSubstituting libraries\nOther verification options\nTesting multiple files\nLogisim includes basic support for executing circuits from the command-line.\nThis is intended both to help with scripted verification of circuit designs\nand to help instructors perform automated testing of students' solutions.\nWe'll start by seeing how to execute a circuit from the command line.\nFor our example, we'll suppose we've built the below circuit in a file named adder-test.circ.\nIt uses a two-bit adder as a subcircuit\nand iterates using a counter through all 16 possible inputs to it.\nAfter this circuit has been built, we then execute Logisim from the command line,\nproviding the filename of the project\nand the -tty option with the table parameter.\njava -jar logisim-filename.jar adder-test.circ -tty table\nWithout bringing up any windows, Logisim loads the circuit and begins to execute it,\nticking any clocks as fast as it can while completing the propagation between each tick.\nAfter each propagation is completed, Logisim loads the current values of the output pins;\nif any have changed from the previous propagation,\nthen all values are displayed in tab-delimited format.\nIf there is an output pin labeled with the special word halt,\nits output is not displayed \u2014 but once the pin's value reaches 1 after\na propagation is completed, Logisim ends the simulation.\nFor our example, Logisim displays the table below. Because we have two output\npins corresponding to the two inputs a and b into the\ntwo-bit adder, these outputs are included as the first two columns of the output.\nAnd there is another output pin corresponding to the two-bit adder's output,\nso it is the third column.\nThe columns are ordered left-to-right according to the top-down ordering within\nthe circuit.\n00\n00\n000\n01\n00\n001\n10\n00\n010\n11\n00\n011\n00\n01\n001\n01\n01\n010\n10\n01\n011\n11\n01\n100\n00\n10\n010\n01\n10\n011\n10\n10\n100\n11\n10\n101\n00\n11\n011\n01\n11\n100\n10\n11\n101\n11\n11\n110"
  },
  {
    "id": 43,
    "title": "Bibliotheken austauschen",
    "url": "/de/html/guide/verify/sub.html",
    "text": "Bibliotheken austauschen\nBibliotheken austauschen\nNow suppose we have two Logisim circuits that are supposed to do the same thing.\nAs an instructor, you might have had students complete an assignment:\nYou have one file containing your solution, but you have several student files\ncontaining their work. Maybe the assignment was to build a two-bit adder.\nI'll imagine that we have two files, named adder-master.circ\nand adder-query.circ. Each file contains a circuit named\n2-bit adder (it's important that the circuit to test be named exactly the same),\nwhose appearance is the following.\nadder-master.circ\nadder-query.circ\nAs you can see, the master circuit uses Logisim's built-in adder,\nwhile the query circuit uses two subcircuits representing a half adder and\na full adder (which themselves are built up of simple gates).\nFor the purpose of our example, the query circuit has a stupid error:\nThe carry from the half adder is not connected into the full adder.\nWe build our testing circuit into a different file. There, we load\nadder-master.circ as a Logisim Library\n(Project > Load Library > Logisim Library\u2026), and we insert its\n2-bit adder as a subcircuit. We could execute this circuit directly to get\nthe desired output for a perfect solution.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\nBut we want to execute the circuit using adder-query.circ\nrather than adder-master.circ as the loaded library.\nThe naive approach would be to open Logisim and load that library instead;\nor you might simply remove the adder-master.circ file and rename\nadder-query.circ to be named adder-master.circ instead.\nBut Logisim includes a handy -sub option that temporarily replace\none file by another during that session \u2014 without making any changes on disk.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\nThe output you would see from this is shown below; it is of course different\nfrom what we saw in the previous section since now it is\nexecuting using the erroneous adder-query.circ.\n00\n00\n0E0\n01\n00\n0E1\n10\n00\nEE0\n11\n00\nEE1\n00\n01\n0E1\n01\n01\n0E0\n10\n01\nEE1\n11\n01\nEE0\n00\n10\nEE0\n01\n10\nEE1\n10\n10\n1E0\n11\n10\n1E1\n00\n11\nEE1\n01\n11\nEE0\n10\n11\n1E1\n11\n11\n1E0"
  },
  {
    "id": 44,
    "title": "Andere Pr\u00fcfungseinstellungen",
    "url": "/de/html/guide/verify/other.html",
    "text": "Andere Pr\u00fcfungseinstellungen\nAndere Pr\u00fcfungseinstellungen\nThere are a some additional options related to command-line execution.\nThe -load command-line parameter\nA more complex circuit might include a RAM component that needs to\nbe loaded with a program in order for the circuit to have anything to do.\nYou can specify a memory image file at the command line, which will be loaded\ninto any RAM component in the circuit before simulation begins.\n(This does not work when loading the GUI - it is only for command-line execution.)\njava -jar logisim-filename.jar cpu.circ -tty table -load mem-image.txt\nThe order of the parameters is not important (except the table\nparameter must be immediately after -tty, and the memory image's filename\nmust be immediately after -load).\nThe memory image file should be in\nLogisim's memory image format.\nLogisim searches for RAM recursively, so this will still work if RAM is\nnested within a subcircuit.\nThere is no way, though, to distinguish different RAM components:\nLogisim will attempt to load the same file into every RAM that it can find.\nOptions for the -tty parameter\nIn our examples thus far, we've always used -tty\u00a0table\nto indicate that a table of output values should be displayed. You can\ncustomize the behavior in other ways by listing one or more options,\nseparated by commas. For instance, you might write\n-tty\u00a0table,halt,speed,\nand the program will perform all three behaviors listed below.\n(The order in which they are listed does not matter.)\nhalt\nAfter the simulation ends, a one-line message is displayed explaining\nwhy the simulation ended. Error conditions - such as a detected oscillation -\nare displayed in any case.\nspeed\nIf you use speed in conjunction with -tty,\nthen after completing the simulation Logisim will display a summary of\nhow quickly the circuit was simulated, such as:\n714 Hz (509 ticks in 712 milliseconds)\nNote that displaying information during the simulation\nmakes the simulation go much slower. As just one comparison, the same circuit and image\nran at 714\u00a0Hz above with just the speed option\nbut 490\u00a0Hz with the table option as well.\nstats\nShows a tab-delimited table containing statistics about components\nused by the top-level main circuit in the project. The table includes\nfour columns:\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nThe distinction between Unique and Recursive is explained\nfurther under Project menu section.\nIf the file uses circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\n(This feature can be useful for instructors who assign students to build\nprojects using a subset of Logisim's libraries.)\ntable\n(as already discussed)\ntty\nAny TTY components send their output to the display (standard output),\nand any information typed at the keyboard is sent to all Keyboard components\nin the circuit.\nThese components are included even if they are nested deeply\nin the subcircuit hierarchy."
  },
  {
    "id": 45,
    "title": "Testen mehrerer Dateien",
    "url": "/de/html/guide/verify/multi.html",
    "text": "Testen mehrerer Dateien\nTesten mehrerer Dateien\nIn the classroom example, you will have many files that you wish to test\nfor their equivalence, and you won't want to read the output for each\nof the student's solutions.\nBuilding comparison into the circuit\nOne approach is to build a test circuit that does the comparison directly.\nHere, we create an additional circuit within the testing file that contains\nour solution circuit. In our overall testing circuit, we include both the\nsubcircuit from adder-master.circ and the subcircuit from the solution\ncircuit located directly into the nested circuit. We wire it so that there is\njust one output, which is 1 as long as the two subcircuits agree.\nNow we can simply run Logisim substituting each query file. For any correct\nsolution, the only output will be 1.\nUsing redirection and shell scripts\nIf you're quite comfortable with the command line,\nyou can build your own shell script to accomplish this.\nHere, we'll use redirection (the > operator) to save the output of each\ncircuit into a file.\nFor instance, we might issue the following two commands to collect the output\nof the master circuit and the query circuit.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0>\u00a0output-master.txt\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\u00a0>\u00a0output-query.txt\nNow we've created two different files.\nWe can then compare the two output files using a program built for that purpose.\nUnder Linux or MacOS X, you might want to use the cmp or diff\ncommand-line utilities. Under Windows, you might want to use WinMerge.\nTo process several query files, you would like want to build a simple program\nsuch as a shell script to iterate through each and comparing the output.\nHere is how I would do it under Linux's bash:\nRUN_TEST=\"java\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\"\n${RUN_TEST}\u00a0>\u00a0output-master.txt\nfor\u00a0QUERY_FILE\u00a0in\u00a0adder-query*.circ\ndo\nif\u00a0${RUN_TEST}\u00a0-sub\u00a0adder-master.circ\u00a0${QUERY_FILE}\u00a0|\u00a0cmp\u00a0-s\u00a0output-master.txt\nthen\necho\u00a0\"${QUERY_FILE}\u00a0OK\"\nelse\necho\u00a0\"${QUERY_FILE}\u00a0different\"\nfi\ndone"
  },
  {
    "id": 46,
    "title": "Programmbezogene Einstellungen",
    "url": "/de/html/guide/prefs/index.html",
    "text": "Application Preferences\nApplication Preferences\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses application preferences;\nproject options are described in another\nsection.\nYou can view and edit application preferences via the Preferences...\noption from the File menu (or, under Mac OS, the Logisim menu),\na window will appear with several tabs.\nWe will discuss these tabs\nseparately, and then we will see how preferences can be configured\nfrom the command line.\nThe Template tab\nThe International tab\nThe Window tab\nThe Layout tab\nThe Experimental tab\nThe command line"
  },
  {
    "id": 47,
    "title": "Die Registerkarte \"Vorlage\"",
    "url": "/de/html/guide/prefs/template.html",
    "text": "Die Registerkarte \"Vorlage\"\nDie Registerkarte \"Vorlage\"\nA template is a Logisim file that is used as a starting\npoint whenever Logisim creates a new project. Also, if you have an\nexisting Logisim file with a strangely configured environment, you\ncan \"reset\" the environment using the Revert All To Template\nbutton in the window for editing Project Options.\nAlthough templates are useful in other situations also, they are\nparticularly suited for classroom use, where an instructor might\nwant to distribute a template for students to start from. This is\nparticularly likely if the class uses Logisim heavily, including\nmany of the more advanced features, in which case the simple default\nconfiguration may prove too simple. Templates can also be useful in\nthe classroom setting when the instructor opens a file submitted by\na student who has configured the environment significantly.\nBy default, the \"Plain template\" option will be selected,\nusing the default template shipped with Logisim. If you want a\nbare-bones configuration, you might choose \"Empty template.\"\nBut if you want to designate another file to use as the template,\nselect a template via the Select...\nbutton, and then choose the\n\"Custom template\" option."
  },
  {
    "id": 48,
    "title": "Die Registerkarte \"Internationalisierung\"",
    "url": "/de/html/guide/prefs/intl.html",
    "text": "Die Registerkarte \"Internationalisierung\"\nDie Registerkarte \"Internationalisierung\"\nThis tab allows configuration of Logisim according to\nregional preferences.\nGate shape: Logisim supports three standards for drawing gates:\nshaped gates, rectangular gates, and DIN 40700\ngates. The following table illustrates the\ndistinction.\nShaped\nRectangular\nDIN 40700\nAND\nOR\nBecause the shaped style tends to be more popular in the U.S., while the\nrectangular style tends to be more popular in Europe, some people refer to\nthese styles according to these regions; but the region-neutral terms\nshaped and rectangular are preferred.\nThe DIN 40700 standard was a standard for drafting digital and analog\nelectronic components adopted by DIN, a German standards organization. DIN\nadopted the rectangular standard for digital components in 1976, but some\nengineers continue to use the older style; they appear to be increasingly\nrare.\nLogisim does not follow any standard exactly; it steers a middle\nground to allow switching between them. In particular, the shaped gates\nare more square than the dimensions defined by the relevant IEEE\nstandard. And, although XOR and XNOR gates really ought to be the same\nwidth as OR and NOR gates with the rectangular style, they are not\nbecause of difficulties compressing the shaped-XOR gate.\nLanguage:\nChange between languages. The current version is supplied with\nEnglish, Spanish, Russian, and German translations.\nThe German translation was introduced with Logisim 2.6.1 and remains current.\nIt is by Uwe Zimmermann, a faculty member at Uppsala University in Sweden.\nThe Russian translation was introduced with Logisim 2.4.0 and remains current.\nIt is by Ilia Lilov, from Russia.\nThe Spanish translation was complete as of Logisim 2.1.0,\nbut subsequent Logisim versions have added new options that remain untranslated.\nIt was contributed by Pablo Leal Ramos, from Spain.\nTranslations of Logisim into other languages are welcome! If you\nare interested, contact me, Carl Burch. This will not be a commitment:\nI will be happy to hear of your interest, and I will tell\nyou whether I know of somebody who is working on it already,\nprepare a version for you to work with, and send you instructions.\nThe translation process does not require an understanding of Java.\nReplace accented characters:\nSome platforms have poor support for characters (such as\n\u00f1 or \u00f6) that do not appear in the 7-bit ASCII character\nset. When this is checked, Logisim will replace all instances of the\ncharacters with the appropriate equivalent 7-bit ASCII characters.\nThe checkbox is disabled when the current language does not have\nany equivalents available (as with English)."
  },
  {
    "id": 49,
    "title": "Die Registerkarte \"Fenster\"",
    "url": "/de/html/guide/prefs/window.html",
    "text": "Die Registerkarte \"Fenster\"\nDie Registerkarte \"Fenster\"\nThis tab includes preferences affecting the appearance of the main window used\nfor Logisim.\nShow tick rate: If checked, then when ticks are enabled, Logisim\ndisplays a measurement of the rate at which it has been able to complete ticks.\nThe tick rate is measured by averaging over the previous 1,000 ticks.\n(Disabling ticks or changing the maximum tick rate will clear its history.)\nThis actual tick rate may be much less than the selected tick rate, because\nLogisim cannot simulate larger circuits at a very fast rate. For example,\nLogisim's maximum speed for a\nreasonably large circuit might be 16 Hz; you can select a faster tick rate,\nbut the actual speed will not exceed 16 Hz.\nShow project toolbar:\nWhen checked, a small toolbar\nis available above the explorer pane. This toolbar allows the user\neasy access to adding, renaming, reordering, and removing circuits\nfrom a project, and it supports switching between editing a circuit's\nlayout and its appearance.\nToolbar location: This drop-down menu configures the location of\nthe toolbar within the overall window. The toolbar may be placed\non any of the window's four borders, described as north, south,\neast, and west. It may also be hidden, or it can be placed \"down the\nmiddle\" - that is, to the left of the canvas but to the right of\nthe explorer pane and attribute table."
  },
  {
    "id": 50,
    "title": "Die Registerkarte \"Layouteditor\"",
    "url": "/de/html/guide/prefs/layout.html",
    "text": "Die Registerkarte \"Layouteditor\"\nDie Registerkarte \"Layouteditor\"\nThis tab includes preferences affecting\nthe behavior of the circuit layout editor.\nPrinter view: Specifies whether\nto display the circuit on the screen in the same way it is displayed\nthrough the printer. Normally this is off, and Logisim displays the on-screen\ncircuit with indications of the current circuit state, and it displays some\nhints about component interface (most notably, it draws legs on OR\ngates to indicate where they would connect). The printer view, though,\nomits indications of state, and it omits such interface hints.\nShow attribute halo: Specifies whether to draw the pale teal oval\naround the component or tool whose attributes are currently displayed in\nthe attribute table.\nShow component tips: Specifies\nwhether to display the \"tool tips\" that will temporarily appear when\nthe mouse hovers over components supporting them. For example, if you hover\nover a subcircuit component's pin, it will display the label of the\ncorresponding pin within the subcircuit. Hovering over one of the\nends of a splitter will tell you the bits to which that end corresponds.\nIn addition, all components in the Plexers, Arithmetic, and Memory libraries will\nprovide information about their inputs and outputs via tips.\nKeep connections while moving: Indicates whether\nLogisim should add new wires when components are moved\nto preserve their connections. By default this is on \u2014 though it can\nbe turned off temporarily by pressing the shift key while moving the components.\nIf this box is unchecked, then the default will be not to add wires during a move\n\u2014 though you can turn it on temporarily by pressing the shift key during the move.\nShow Ghosts while adding: When checked, and when a tool for adding\na new component is selected, a light-gray outline of a component to be added\nis drawn as the mouse moves across the canvas. For example, if you select\nthe AND gate tool and move the mouse into the window (without\npressing the mouse's button), a gray outline of an AND gate will display\nwhere the AND gate will appear when the mouse is clicked.\nAfter adding component: By default, after adding each individual\ncomponent, Logisim switches back to the Edit Tool to allow you to move\ncomponents around and to add wires. The drop-down box allows you to change this\nbehavior so that Logisim stays at the same tool for adding more of the same\ncomponent, until you yourself opt to choose the Edit Tool. (This was Logisim's\ndefault behavior prior to Logisim 2.3.0. While more intuitive, this behavior\nrequires more mouse movement to switch between tools.)\nFirst radix when wire poked:\nConfigures how values are displayed when a wire is clicked using the Poke Tool.\nClicking a wire displays temporarily the value, staying until the user clicks\nelsewhere in the circuit.\nSecond radix when wire poked:\nConfigures the second part of how wire values are displayed."
  },
  {
    "id": 51,
    "title": "Die Registerkarte \"Experimentell\"",
    "url": "/de/html/guide/prefs/exp.html",
    "text": "Die Registerkarte \"Experimentell\"\nDie Registerkarte \"Experimentell\"\nThese preferences enable features that are considered experimental,\ninserted to garner user feedback.\nGraphics acceleration: One Logisim user observed\nthat adding -Dsun.java2d.d3d=True to the command line seemed\nto improve Logisim's graphics performance by telling it to use hardware graphics\nacceleration. This drop-down box attempts to\nconfigure Logisim to set this up; reports about whether this drop-down box has\nany effect on performance would be welcome. It won't have\nany effect until Logisim is restarted."
  },
  {
    "id": 52,
    "title": "Die Kommandozeile",
    "url": "/de/html/guide/prefs/cmdline.html",
    "text": "Command-line options\nCommand-line options\nYou can configure many of Logisim's application preferences via command\nline options.\nThis can be particularly useful in a laboratory of\nsingle-student computers where you want Logisim to start up the same\nfor students every time, regardless of how previous students may have\nconfigured the program.\nThe overall command-line syntax is as follows.\njava -jar jarFileName [options] [filenames]\nThe optional additional files named on the command line will be\nopened as separate windows within Logisim.\nThe following example starts Logisim in its basic configuration.\njava -jar jarFileName -plain -gates shaped -locale en\nSupported options include the following.\n-plain\n-empty\n-template templateFile\nConfigures the template for Logisim to use.\n-gates [shaped|rectangular]\nConfigures which type of gate to use.\n-locale localeIdentifier\nConfigures which translation to use. As of this writing, the\nsupported locales include:\ndeGerman\nenEnglish\nesSpanish\nruRussian\n-accents [yes|no]\nThis is only relevant for languages that use characters\noutside the 7-bit ASCII character set; this would include\nlanguages using accented characters, and it would not\ninclude English.\nIf no, characters outside the 7-bit ASCII character\nset are replaced with equivalents appropriate to the language;\nthis would be useful for Java/OS combinations where such characters\nare not supported well.\n-clearprops\nClear all application preferences at startup, so Logisim will act as\nif it were being executed on the host system for the first time.\n-nosplash\nHides the initial Logisim splash screen.\n-help\nDisplays a summary of the command line options.\n-version\nDisplays the Logisim version number."
  },
  {
    "id": 53,
    "title": "Projektbezogene Einstellungen",
    "url": "/de/html/guide/opts/index.html",
    "text": "Project Options\nProject Options\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses project options;\napplication preferences are described in another\nsection.\nYou can view and edit project options via the Options...\noption from the Project menu. It brings up the Options window,\nwhich has four tabs.\nHier werden wir diese Registerkarten im Einzelnen beschreiben.\nThe Simulation tab\nThe Toolbar tab\nThe Mouse tab\nAt the bottom of the window is the Revert All To Template\nbutton. When clicked, all the options and tool attributes change\nto the settings in the current template (as selected under the\napplication preferences)."
  },
  {
    "id": 54,
    "title": "Die Registerkarte \"Simulation\"",
    "url": "/de/html/guide/opts/simulate.html",
    "text": "Die Registerkarte \"Simulation\"\nDie Registerkarte \"Simulation\"\nThe Simulation tab allows configuration of the algorithm used for\nsimulating circuits. These parameters apply to all circuits being\nsimulated in the same window, even for circuits that exist in other\nlibraries loaded within the project.\nThe Iterations Until Oscillation drop-down menu\nspecifies how long to simulate a circuit before deciding that it is\noscillating. The number represents the number of clicks of the internal\nhidden clock (a simple gate takes just one click). The default of 1,000\nis good enough for almost all purposes, even for large circuits. But you\nmay want to increase the number of iterations if you are working with a\ncircuit where Logisim reports false oscillations. This is unlikely to be a\nproblem in practice, but one such a circumstance is a circuit that incorporates\nmany of the below latch circuits with random noise enabled. You may want to\ndecrease the number of iterations if you are working with a circuit that is\nprone to oscillating and you are using an unusually slow processor.\nThe Gate Output When Undefined drop-down menu configures\nhow the built-in logic gates behave when some inputs are unconnected or are\nfloating. By default, Logisim ignores such inputs, allowing a gate to work over\nfewer inputs than it was designed for. However, in real life, a gate will behave\nunpredictably in such a situation, and so this drop-down menu allows one to\nchange the gates so that they treat such disconnected inputs as errors.\nThe Add Noise To Component Delays checkbox\nallows you to enable or disable the random noise that is added to the\ndelays of components. The internal simulation uses a hidden clock for\nits simulation, and to provide a somewhat realistic simulation, each\ncomponent (excluding wires and splitters) has a delay between when it\nreceives an input and when it emits an output. If this option is\nenabled, Logisim will occassionally (about once every 16\ncomponent reactions) make a component take one click longer than\nnormal.\nThis randomness is added specifically for handling latch\ncircuit (as below): Without the random noise, the circuit oscillates,\nsince the two gates will work in lockstep; but with random noise added,\none gate will eventually outrun the other.\nI recommend keeping this option off, as this technique does introduce rare\nerrors with normal circuits."
  },
  {
    "id": 55,
    "title": "Die Registerkarte \"Werkzeugleiste\"",
    "url": "/de/html/guide/opts/toolbar.html",
    "text": "Die Registerkarte \"Werkzeugleiste\"\nDie Registerkarte \"Werkzeugleiste\"\nThe Toolbar tab allows you to configure what tools appear in\nthe toolbar.\nThe left side is an explorer listing all the tools available,\nand the list on the right side displays the current contents of the\ntoolbar.\n(Three dashes \"---\" indicate a\nseparator, which is drawn as a gray line.)\nBetween the explorer and the list are five buttons and a combo box:\nAdd Tool adds the currently selected\ntool in the explorer at left to the end of the toolbar.\nAdd Separator adds a separator\nto the end of the toolbar.\nMove Up moves the currently selected\nitem of the toolbar up/left one spot.\nMove Down moves the currently selected\nitem of the toolbar down/right one spot.\nRemove removes the currently selected\nitem from the toolbar.\nThe attributes associated with the tools are not displayed in\nthis window; instead, you can view and edit them within the main\ndrawing window."
  },
  {
    "id": 56,
    "title": "Die Registerkarte \"Maus\"",
    "url": "/de/html/guide/opts/mouse.html",
    "text": "Die Registerkarte \"Maus\"\nDie Registerkarte \"Maus\"\nBy default, when you click the mouse in Logisim's drawing area,\nthe currently selected tool will be used. If you right-click or\ncontrol-click, it will display a pop-up menu for the current component\nbelow the mouse.\nLogisim allows you to modify this behavior, relieving you of the\nneed to go to the toolbar and/or the explorer all the time.\n(This may\nalso be handy if you are left-handed.) Each combination of a mouse\nbutton and a modifier key (any subset of shift, control, and alt) can be mapped to a\ndifferent tool.\nThe Mouse tab allows you to configure these mappings.\nOn the left side is an explorer where you can choose the tool\nyou want to map.\nOn the right top side is a rectangle in which you can click\nusing the mouse combination you want to click. For example, if you\nwant to create new wires by shift-dragging, then you would first\nselect the Wiring Tool in the Explorer (under the Base library); and\nthen you would shift-click where it says \"Click Using Combination\nTo Map Wiring Tool.\" If that combination is already being used,\nthen the mapping would be replaced with the new tool.\nBelow this area is a list of current mappings.\nNote that\nany combinations that aren't listed simply use the currently selected\ntool.\nBelow is the Remove button, where you can delete the mapping\nthat is currently selected in the table above the button.\nIn the\nfuture, then, that mouse combination would map to whatever tool\nis currently selected in the toolbar or the explorer pane.\nBelow this is a list of attributes for the tool currently selected\nin the list of mappings. Each mouse-mapped tool has its own set of\nattributes, different from the attributes used in the explorer pane\nand in the toolbar. You can edit those attribute values here."
  },
  {
    "id": 57,
    "title": "Weiterleitung von Werten",
    "url": "/de/html/guide/prop/index.html",
    "text": "Weiterleitung von Werten\nWeiterleitung von Werten\nLogisim's algorithm for simulating the propagation of values through\ncircuits is not something that you normally need to worry about. Suffice\nit to say that the algorithm is sophisticated enough to account for gate\ndelays, but not realistic enough to account for more difficult\nphenomena like varying voltages or race conditions.\nDo you still want to know more?\nGate delays\nOscillation errors\nShortcomings"
  },
  {
    "id": 58,
    "title": "Gatterlaufzeiten",
    "url": "/de/html/guide/prop/delays.html",
    "text": "Gatterlaufzeiten\nGatterlaufzeiten\nAs an example of the level of sophistication of Logisim's algorithm,\nconsider the following circuit.\nThis \"obviously\" always outputs 0. But NOT gates don't react\ninstantaneously to their inputs in reality, and neither do they in\nLogisim. As a result, when this circuit's input changes from 0 to 1, the\nAND gate will briefly see two 1 inputs, and it will emit a 1 briefly.\nYou won't see it on the screen. But the effect is observable when we\nuse the AND gate's output as an input into the clock of a D flip-flop.\nPoking the 0 input to become 1 leads to an instantaneous 1 going\ninto the D flip-flop, and thus the flip-flop's value will toggle\nevery time the circuit input goes from 0 to 1.\nEvery component has a delay associated with it. More sophisticated\ncomponents built into Logisim tend to have larger delays, but\nthese delays are somewhat arbitrary and may not reflect reality.\nFrom a technical point of view, it is relatively easy to deal with\nthis level of sophistication in a single circuit.\nDealing with gate\ndelays well across subcircuits, though, is a bit more complex;\nLogisim does attempt to address this correctly by placing all primitive\ncomponent's propagation values into a single schedule regardless of the\nsubcircuit in which the component lies.\n(Via the Project Options window's\nSimulation tab, you can configure Logisim\nto add a random, occasional delay to a component's propagation. This is intended\nto simulate the unevenness of real circuits. In particular, an R-S latch built\nusing two NOR gates will oscillate without this randomness, as both gates will\nprocess their inputs in lockstep. This randomness is disabled by default.)\nNote that I'm stopping short of saying that Logisim\nalways addresses gate delays well.\nBut at least it tries."
  },
  {
    "id": 59,
    "title": "Fehler durch Oszillationen",
    "url": "/de/html/guide/prop/oscillate.html",
    "text": "Fehler durch Oszillationen\nFehler durch Oszillationen\nThe propagation algorithm, which normally works silently without any\nproblems, will become very visible\nwhen you create a circuit that oscillates.\nThis circuit is currently in a stable condition. But if you change the\ninput to 1, the circuit will effectively enter an infinite loop. After\na while, Logisim will simply give up and show an \"Oscillation apparent\" message\ntelling you that it believes that the circuit is oscillating.\nIt will display the values it has at the time it gives up. These values\nwill look wrong - in this screen shot, the AND gate is emitting 1\nalthough one of its inputs is 0, but it could be that the NOT gate\nhas a 1 input and a 1 output.\nLogisim helpfully circles in red each location that seems to be\ninvolved in the oscillation. If an involved point lies within a\nsubcircuit, Logisim will draw that subcircuit's outline in red.\nWhen Logisim detects oscillation, it shuts down all\nfurther simulation. You can re-enable simulation using the\nSimulate menu's Simulation Enabled option.\nLogisim detects oscillation using a fairly simple technique: If the\ncircuit simulation seems to many iterations, then it will simply give up\nand report oscillation. (The points it identifies as being involved are\nthose that were touched in the last 25% of the iterations.)\nThus, it could erroneously report oscillation,\nparticularly if you are working with an exceptionally large circuit; but\nit would be one that is larger than any I have built using Logisim.\nIn any case, if you are confident that the reporting is in error, you\ncan configure the number of iterations\ncompleted before oscillation occurs via the\nProject Options window's\nSimulation tab."
  },
  {
    "id": 60,
    "title": "Schwachstellen",
    "url": "/de/html/guide/prop/shortcome.html",
    "text": "Schwachstellen\nSchwachstellen\nLogisim's propagation algorithm is more than sophisticated enough\nfor almost all educational purposes; but it is not sophisticated\nenough for industrial circuit design. In order from most damning to\nleast damning, the shortcomings of Logisim's propagation technique\ninclude:\nExcept for the issue of gate delays, Logisim does not particularly\nconcern itself with timing issues. It is very idealized, so that a pair of NOR\ngates in an S-R latch configuration will toggle in lockstep infinitely, rather\nthan the circuit eventually settle into a stable state.\nLogisim cannot simulate subcircuits whose pins sometimes behave\nas inputs and sometimes behave as outputs. Components built using\nJava can have such pins, though: Within the built-in libraries,\nthe Memory library's RAM circuit contains a D pin that can act both\nas an input and as an output.\nLogisim cuts off its simulation after a fixed number of iterations\nassuming that there is an oscillation error.\nConceivably, a large circuit that does not oscillate could lead to\ntrouble.\nLogisim does nothing with respect to discriminating between\nvoltage levels: A bit can be only on, off, unspecified, or error.\nThere are additional shortcomings, too, that I have omitted because\nthey are so obscure that if you were aware of them, it would be obvious\nthat Logisim comes nowhere close to that level. As an extreme example,\nI have a friend who works for a major chip manufacturer, and his\njob is to worry about \"bubbles\" in chips' nanometer-wide wires growing\nand leading to random disconnection.\nEven beyond this, I am not a circuit design specialist; thus,\nthere may well be errors in the propagation technique of which I am\nnot aware. I welcome corrections from experts."
  },
  {
    "id": 61,
    "title": "JAR-Bibliotheken",
    "url": "/de/html/guide/jar/index.html",
    "text": "JAR-Bibliotheken\nJAR-Bibliotheken\nVerwendung von JAR-Bibliotheken\nLogisim kennt zwei Arten von Bauelementen: solche, die in Logisim als Kombination anderer Bauelemente konstruiert wurden, und die in Java programmierten Grundbauelemente. Schaltungen in Logisim sind einfacher zu entwerfen, aber diese unterst\u00fctzen keine anspruchsvollen Interaktionen mit dem Anwender. Au\u00dferdem sind sie als Bauelement verh\u00e4ltnism\u00e4\u00dfig ineffizient.\nLogisim enth\u00e4lt eine ziemlich umfangreiche Bibliothek von eingebauten Java-Bauelementen, es lassen sich aber auch Bibliotheken laden, die von Ihnen selbst oder anderen erstellt worden sind. Wenn Sie eine Bibliothek heruntergeladen haben, k\u00f6nnen Sie diese in Ihr aktuelles Projekt importieren, indem Sie im \u00dcbersichtsfenster Ihr Projekt anklicken (die oberste Zeile) und dort den Punkt \"Bibliothek laden &gt; JAR-Bibliothek\" ausw\u00e4hlen. Diesen Punkt erreichen Sie auch \u00fcber \"Projekt &gt; Bibliothek laden\" aus dem Hauptmen\u00fc. Dann wird Logisim Sie auffordern, die entsprechende JAR-Datei auszuw\u00e4hlen. (In einigen F\u00e4llen werden Sie aufgefordert, den Namen der Startklasse in der Bibliothek anzugeben. Diese Angabe sollten Sie vom Programmierer bekommen haben. Meistens aber wird der Entwickler die JAR-Bibliothek bereits so konfiguriert haben, da\u00df dies nicht n\u00f6tig ist (indem eine manifest-Datei im JAR-Archiv angelegt wurde, dessenLibrary-Class-Attribut den Namen der Hauptklasse angibt).)\nErstellen von JAR-Bibliotheken\nDer Rest dieses Abschnitts widmet sich einer Serie gut dokumentierter Beispiele, die aufzeigen, wie Sie eigene Logisim-Bibliotheken entwickeln k\u00f6nnen. Um erfolgreich eigene Bibliotheken zu entwickeln, sollten Sie sich in der Java-Programmierung auskennen. Die Dokumentation, die \u00fcber diese Beispiele hinausgeht ist etwas d\u00fcrftig.\nEin JAR-Archiv mit den folgenden Beispielen k\u00f6nnen Sie von der Homepage von Logisim herunterladen, Sie finden die Datei im Abschnitt \"Links\". Diese JAR-Datei enth\u00e4lt auch den Quellkode zu den folgenden Beispielen.\nGray-Kode-Inkrementierer\nZeigt die wesentlichen Teile eines Bauelements an einem einfachen Beispiel. Dieses Bauelement nimmt einen Mehrbit-Wert an einem Eingang entgegen und berechnet den darauf folgenden Gray-Kode.\nBibliotheksklasse\nZeigt, wie eine Bibliothek definiert wird. Dieses ist der Einstiegspunkt f\u00fcr jede JAR-Datei - die Klasse, deren Name der Anwender angibt, wenn er die JAR-Datei l\u00e4dt.\nEinfacher Gray-Kode-Z\u00e4hler\nZeigt, wie ein Bauelement mit einem internen Zustand aufgebaut ist, am Beispiel eines 8-Bit-Z\u00e4hlers mit Gray-Kode-Ausgabe.\nGray-Kode-Z\u00e4hler\nVeranschaulicht ein komplettes und ziemlich anspruchsvolles Bauelement mit Interaktion mit dem Benutzer. Es wird ein Gray-Kode-Z\u00e4hler mit variabler Bitbreite implementiert, dessen Bitbreite konfiguriert werden kann. Au\u00dferdem kann der Benutzer den aktuellen Wert mit dem Schaltwerkzeug und durch Eingabe eines Wertes ver\u00e4ndern.\nRichtlinien\nAllgemeine Informationen f\u00fcr die Entwicklung externer Bibliotheken\nLizenz\nDer Kode in diesem Beispiel einer JAR-Bibliothek ist unter der MIT-Lizenz ver\u00f6ffentlicht, einer gro\u00dfz\u00fcgigeren Lizenz als die GPL, welche f\u00fcr den Rest von Logisim gilt.\nCopyright (c) 2009, Carl Burch.\nHiermit wird die Erlaubnis erteilt, kostenlos, f\u00fcr jede Person, eine Kopie dieser Software und der zugeh\u00f6rigen Dokumentationen (die \"Software\") zu erhalten, die Software uneingeschr\u00e4nkt zu benutzen, einschlie\u00dflich und ohne Einschr\u00e4nkung der Rechte zur Verwendung, dem Kopieren, \u00c4ndern, Zusammenf\u00fchren, Ver\u00f6ffentlichen, Verbreiten, Lizenzieren und / oder Verkaufen von Kopien der Software, sowie Personen, denen die Software geliefert wird, dies unter den folgenden Bedingungen zu gestatten:\nDer obige Urheberrechtsvermerk und diese Genehmigung soll in alle Kopien oder Teile der Software aufgenommen werden.\nDIE SOFTWARE WIRD WIE BESEHEN AUSGELIEFERT, OHNE GARANTIE JEGLICHER ART, EINSCHLIESSLICH, ABER NICHT BESCHR\u00c4NKT AUF DIE GARANTIE DER EIGNUNG F\u00dcR EINEN BESTIMMTEN ZWECK UND NICHTVERLETZUNG DER RECHTE DRITTER. IN KEINEM FALL SIND DIE AUTOREN ODER URHEBERRECHTSINHABER VERANTWORTLICH F\u00dcR ANSPR\u00dcCHE, SCH\u00c4DEN ODER ANDERE HAFTUNGEN, ALS FOLGE VON ODER IM ZUSAMMENHANG MIT DER SOFTWARE, DEREN BENUTZUNG ODER IN ANDEREM BEZUG ZUR SOFTWARE."
  },
  {
    "id": 62,
    "title": "Gray-Kode-Inkrementierer",
    "url": "/de/html/guide/jar/incr.html",
    "text": "Gray-Kode-Inkrementierer\nGray-Kode-Inkrementierer\nJedes Bauelement in ein einer Bibliothek wird durch die Erstellung einer Unterklasse von InstanceFactory aus dem com.cburch.logisim.instance Paket definiert. Diese Unterklasse enth\u00e4lt den gesamten, ben\u00f6tigten Kode.\n(An dieser Stelle beschreiben wir die API der aktuellen Version von Logisim. Es gibt Bibliotheken, die f\u00fcr fr\u00fchere Versionen von Logisim entwickelt wurden, wo Bauelemente durch die Definition von zwei Klassen erstellt wurden: eine Erweiterung von Component und eine Erweiterung von ComponentFactory. Die Version 2.3.0 f\u00fchrte die sehr viel einfachere InstanceFactory-API ein, die andere Methode ist seitdem veraltet.)\nDrei Pakete von Logisim definieren die meisten Klassen, die f\u00fcr die Erstellung von Bauelementbibliotheken ben\u00f6tigt werden.\ncom.cburch.logisim.instance\nEnth\u00e4lt Klassen, die speziellen Bezug zur Erstellung von Bauelementen haben, darunter die Klassen InstanceFactory, InstanceState, InstancePainter und Instance.\ncom.cburch.logisim.data\nEnth\u00e4lt Klassen zu Datenelementen, die mit den Bauelementen verkn\u00fcpft sind, wie die Klasse Bounds f\u00fcr begrenzende Rechtecke oder die Klasse\nValue f\u00fcr die Werte, die auf einer Leitung existieren k\u00f6nnen.\ncom.cburch.logisim.tools\nEnth\u00e4lt Klassen zur Definition von Bibliotheken.\n\u00dcber Gray-Kodes\nBevor wir weitergehen, soll an dieser Stelle kurz auf die Gray-Kodes eingegangen werden, auf denen die Beispiele aufbauen. Es ist nicht unbedingt wichtig zu verstehen, wie diese Beispiele im Detail funktionieren. Daher k\u00f6nnen Sie auch den folgenden Kode \u00fcberspringen - nat\u00fcrlich auch dann, wenn Sie sich bereits mit Gray-Kodes auskennen.\nDer Gray-Kode (benannt nach Frank Gray) ist eine Methode eine Gruppe von n-Bits zu durchlaufen, wobei sich immer nur ein Bit pro Schritt \u00e4ndert. Als Beispiel k\u00f6nnen Sie den folgenden 4-bit Gray-Kode betrachten.\n0000\n0001\n0011\n0010\n0110\n0111\n0101\n0100\n1100\n1101\n1111\n1110\n1010\n1011\n1001\n1000\nIn jeder Zeile ist jeweils das Bit unterstrichen, das sich im n\u00e4chsten Schritt \u00e4ndern wird. Zum Beispiel folgt auf 0000 der Wert 0001, in dem das letzte Bit umgeschaltet wurde, daher ist das letzte Bit unterstrichen.\nKeines der eingebauten Bauelemente in Logisim arbeitet mit Gray-Kodes. Aber manchmal sind Gray-Kodes f\u00fcr Elektroniker von Bedeutung. Ein solches Beispiel findet sich l\u00e4ngs der Achsen von Karnaughdiagrammen.\nGrayIncrementer\nDies ist ein minimales Beispiel zur Veranschaulichung der wesentlichen Bestandteile der Definition eines Bauelements. Dieses Bauelement ist ein Inkrementierer, das einen Wert von einem Mehrbit-Eingang nimmt und den n\u00e4chsten Gray-Kode der Sequenz berechnet.\npackage com.cburch.gray;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\n/** Dieses Bauelement nimmt einen Mehrbit-Wert und berechnet den darauf folgenden Wert aus\n* im Gray-Kode. Zum Beispiel folgt auf 0100 der Wert 1100. */\nclass GrayIncrementer extends InstanceFactory {\n/* Beachten Sie, da\u00df es keine Instanyvariablen gibt. Es wird nur eine Instanz dieser\n* Klasse erzeugt, die alle Instanzen des Bauelements verwaltet. Alle\n* Informationen die mit individuellen Instanzen zusammenh\u00e4ngen, sollten durch\n* Attribute behandelt werden. F\u00fcr den GrayIncrementer besitzt jede Instanz eine Bitbreite\n* mit der gearbeitet wird, daher gibt es ein entsprechendes Attribut. */\n/ ** Der Konstruktor konfiguriert die Fabrik. */\nGrayIncrementer() {\nsuper(\"Gray Code Incrementer\");\n/* Auf diese Weise k\u00f6nnen die Attribute des GrayIncrementers initialisiert werden. Hier\n* haben wir nur ein Attribut - die Bitbreite - deren Vorgabe\n* 4 ist. Die Klasse StdAttr definiert zahlreiche gebr\u00e4uchliche\n* Attribute, einschlie\u00dflcih der Bitbreite. wenn m\u00f6glich\n* empfiehlt es sich, die Attribute aus StdAttr zu verwenden: Ein Anwender kann dann mehrere\n* Bauelemente (selbst aus verschiedenen Bibliotheken) mit gemeinsamen Attributen ausw\u00e4hlen,\n* und dann diese dann gleichzeitig ver\u00e4ndern. */\nsetAttributes(new Attribute[] { StdAttr.WIDTH },\nnew Object[] { BitWidth.create(4) });\n/* Die \"offset bounds\" bezeichnen die Lage des umgrenzenden Rechtecks\n* relativ zur Position der Maus. Hier wird unser Bauelement\n* 30x30 gro\u00df, und wir verankern es an dessen prim\u00e4ren Ausgang\n* (wie f\u00fcr Logisim typisch), der sich in der Mitte der\n* \u00f6stlichen Kante befindet. Daher befindet sich die obere linke Ecke des umgrenzenden Rechtecks 30 Punkte\n* westlich und 15 Punkte n\u00f6rdlich der Mausposition. */\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\n/* Die Ports sind die Positionen, an denen Leitungen an dem Bauteil\n* angeschlossen werden k\u00f6nnen. Jedes Port-Objekt besagt, wo dieser Port relativ zum Ankerpunkt des\n* Bauelements befindet, ob es sich um einen\n* Eingang/Ausgang/Beides handelt, und schlie\u00dflich die erwartete Bitbreite des Ports.\n* Die Bitbreite kann eine Konstante (wie 1) oder ein Attribut (wie in diesem Beispiel) sein.\n*/\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, StdAttr.WIDTH),\nnew Port(0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n}\n/** Berechnet den aktuellen Ausgabewert des Bauelements. Diese Methode wird jedes Mal aufgerufen,\n* wenn einer der Eing\u00e4nge seinen Wert \u00e4ndert. Sie kann auch unter anderen Umst\u00e4nden\n* aufgerufen werden, auch wenn es keinen Grund gibt, eine \u00c4nderung zu\n* erwarten. */\npublic void propagate(InstanceState state) {\n// Zun\u00e4chst wird der Wert vom Eingang eingelesen. Beachten Sie, da\u00df beim Aufruf\n// von setPorts der Eingang am Index 0 des Parameterfeldes\n// definiert wurde, daher benutzen wir hier 0 als Parameter.\nValue in = state.getPort(0);\n// Jetzt wir der Ausgangswert berechnet. Dies wurde in eine Hilfsmethode ausgelagert,\n// weil die anderen Bauelemente dieser Bibliothek dieselben Routinen ben\u00f6tigen.\nValue out = nextGray(in);\n// Schlie\u00dflich wird dieser Wert an den Ausgang weitergegeben. Der erste Parameter\n// ist 1, weil der Ausgang in unserer Liste der Ports am Index 1 definiert worden ist\n// (siehe setPorts weiter oben). Der zweite Parameter ist hier der\n// Wert, der an den Ausgang gesendet werden soll. Und der letzte Parameter ist die Verz\u00f6gerung\n//\n- die Anzahl der Schritte, die bis zur Aktualisierung des Ausgangs vergehen sollen,\n// nach der \u00c4nderung am Eingang.\nstate.setPort(1, out, out.getWidth() + 1);\n}\n/** Bezeichnet, wie eine einzelne Instanz auf der Arbeitsfl\u00e4che dargestellt wird. */\npublic void paintInstance(InstancePainter painter) {\n/ /\nInstancePainter enth\u00e4lt mehrere bequeme Methoden\n// zum Zeichnen, die wir hier benutzen. H\u00e4ufig w\u00fcrden Sie\n// dessen Objekt Graphics (painter.getGraphics) aufrufen, so da\u00df Sie direkt\n// aus der Arbeitsfl\u00e4che zeichnen k\u00f6nnen.\npainter.drawRectangle(painter.getBounds(), \"G+1\");\npainter.drawPorts();\n}\n/** Berechnet den n\u00e4chsten Gray-Wert nach prev aus der Folge. Diese statische\n* Methode dreht nur einige Bits um, es hat nicht viel mit Logisim\n* zu tun, abgesehen von der Manipulation der Objekte Value und BitWidth */\nstatic Value nextGray(Value prev) {\nBitWidth bits = prev.getBitWidth();\nif(!prev.isFullyDefined()) return Value.createError(bits);\nint x = prev.toIntValue();\nint ct = (x >> 16) ^ x; // compute parity of x\nct = (ct >> 8) ^ ct;\nct = (ct >> 4) ^ ct;\nct = (ct >> 2) ^ ct;\nct = (ct >> 1) ^ ct;\nif((ct & 1) == 0) { // if parity is even, flip 1's bit\nx = x ^ 1;\n} else { // ansonsten kippe das Bit gerade oberhalb der letzten 1\nint y = x ^ (x & (x - 1)); // berechne die letzte 1\ny = (y << 1) & bits.getMask();\nx = (y == 0 ? 0 : x ^ y);\n}\nreturn Value.createKnown(bits, x);\n}\n}\nDieses Beispiel alleine ist nicht genug, um ein funktionierendes JAR-Archiv zu erstellen. Sie m\u00fcssen dar\u00fcberhinaus eine Bibliotheksklasse erstellen, wie auf der n\u00e4chsten Seite n\u00e4her erkl\u00e4rt wird."
  },
  {
    "id": 63,
    "title": "Bibliotheksklasse",
    "url": "/de/html/guide/jar/library.html",
    "text": "Bibliotheksklasse\nBibliotheksklasse\nDer Startpunkt einer JAR-Bibliothek ist eine Klasse, die die Library-Klasse erweitert. Die Hauptaufgabe ist es, die Werkzeuge aufzulisten, die durch die Bibliothek zur Verf\u00fcgung gestellt werden. Meistens wird es sich um Werkzeuge handeln, die verschiedene Bauelemente zu einer Schaltung hinzuf\u00fcgen, d.h. Instanzen der\nAddTool-Klasse, die mit verschiedenen Komponentenfabriken zusammenarbeiten.\nComponents\npackage com.cburch.gray;\nimport java.util.Arrays;\nimport java.util.List;\nimport com.cburch.logisim.tools.AddTool;\nimport com.cburch.logisim.tools.Library;\n/** Die Bauteilebibliothek, die f\u00fcr den Anwender zug\u00e4nglich ist. */\npublic class Components extends Library {\n/** Die Liste aller Werkzeuge in der Bibliothek. Technisch\n* enthalten Bibliotheken Werkzeuge, was ein etwas allgemeinerer Begriff als\n* Bauelemente ist. In der Praxis werden Sie aber wohl am h\u00e4ufigsten\n* AddTools zum Einf\u00fcgen neuer Bauelemente in die Schaltung erstellen wollen.\n*/\nprivate List<AddTool> tools;\n/** Erstellt eine Instanz dieser Bibliothek. \u00dcber diesen Konstruktor\n* greift Logisim zuerst zu, wenn eine JAR-Datei geladen wird: Es sucht nach\n* einer Konstruktormethode ohne Argumente f\u00fcr die vom Benutzer angegebene Klasse.\n*/\npublic Components() {\ntools = Arrays.asList(new AddTool[] {\nnew AddTool(new GrayIncrementer()),\nnew AddTool(new SimpleGrayCounter()),\nnew AddTool(new GrayCounter()),\n});\n}\n/** Gibt den Namen der Bibliothek zur\u00fcck, der dem Benutzer angezeigt wird. */\npublic String getDisplayName() {\nreturn \"Gray Tools\";\n}\n/** Gibt eine Liste aller Werkzeuge der Bibliothek zur\u00fcck. */\npublic List<AddTool> getTools() {\nreturn tools;\n}\n}"
  },
  {
    "id": 64,
    "title": "Einfacher Gray-Kode-Z\u00e4hler",
    "url": "/de/html/guide/jar/simpctr.html",
    "text": "Einfacher Gray-Kode-Z\u00e4hler\nEinfacher Gray-Kode-Z\u00e4hler\nH\u00e4ufig ben\u00f6tigt man Bauelemente, die nicht rein-kombinatorisch sind - mit anderen Worten, Bauelemente, die einen internen Speicher besitzen. Es gibt hier aber eine Kleinigkeit bei der Erstellung dieser Bauelemente zu beachten: diese Bauelemente k\u00f6nnen ihren Zustand nicht direkt selber speichern, denn ein und dasselbe Bauelement kann mehrfach in einer Schaltung auftauchen. Zwar kann es nicht direkt mehrmals in einer Schaltung auftauchen, aber es kann mehrmals vorhanden sein, wenn es in einer Unterschaltung benutzt wird, die ihrerseits mehrmals verwendet wird.\nDie L\u00f6sung ist es, hier eine neue Klasse zu erstellen, die den aktuellen Zustand des Objekts repr\u00e4sentiert, und Instanzen hiervon mit den Bauelementen \u00fcber den Zustand der Mutterschaltung zu verkn\u00fcpfen. In diesem Beispiel werden wir einen flankengetriggerten 4-Bit-Gray-Kode-Z\u00e4hler konstruieren. Hierzu definieren wir eine Klasse CounterData, die den Zustand des Z\u00e4hlers repr\u00e4sentiert, zus\u00e4tzlich zur InstanceFactory Unterklasse, die wir gerade betrachtet haben. Das Objekt CounterData merkt sich sowohl den aktuellen Wert des Z\u00e4hlers, als auch den letzten Zustand des Takteingangs (um steigende Flanken zu erkennen).\nCounterData\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceData;\nimport com.cburch.logisim.instance.InstanceState;\n/** Repr\u00e4sentiert den aktuellen Zustand des Z\u00e4hlers. */\nclass CounterData implements InstanceData, Cloneable {\n/** Fragt den Zustand ab, der mit diesem Z\u00e4hler im aktuellen Zustand der Schaltung verkn\u00fcpft ist,\n* wenn notwendig wird dieser Zustand erstellt.\n*/\npublic static CounterData get(InstanceState state, BitWidth width) {\nCounterData ret = (CounterData) state.getData();\nif(ret == null) {\n// Wenn es noch nicht existiert, werden wir es mit unseren Vorgabewerten\n// initialisieren und im aktuellen Zustand der Schaltung einf\u00fcgen, so da\u00df\n// in weiteren Aufrufen abgefragt werden kann.\nret = new CounterData(null, Value.createKnown(width, 0));\nstate.setData(ret);\n} else if(!ret.value.getBitWidth().equals(width)) {\nret.value = ret.value.extendWidth(width.getWidth(), Value.FALSE);\n}\nreturn ret;\n}\n/** Der zuletzt gesehene Zustand des Takteingangs */\nprivate Value lastClock;\n/** Der aktuelle Wert, den der Z\u00e4hler ausgibt. */\nprivate Value value;\n/** Erstelle einen Zustand mit den gegebenen Werten. */\npublic CounterData(Value lastClock, Value value) {\nthis.lastClock = lastClock;\nthis.value = value;\n}\n/** Liefert eine Kopie des Objekts zur\u00fcck. */\npublic Object clone() {\n// Wir k\u00f6nnen benutzen, was super.clone() zur\u00fcckliefert: die einzigen Instanzenvariablen sind\n// Value-Objekte, die unver\u00e4nderlich sind, daher ist es unwesentlich, da\u00df Kopie und\n// Original auf dieselben Value-Objekte verweisen. H\u00e4tten wir ver\u00e4nderliche Instanzen-\n// variables, dann m\u00fc\u00dften wir diese nat\u00fcrlich klonen.\ntry { return super.clone(); }\ncatch(CloneNotSupportedException e) { return null; }\n}\n/** Aktualisiert das vorige Taktsignal und liefert true zur\u00fcck, wenn getriggert. */\npublic boolean updateClock(Value value) {\nValue old = lastClock;\nlastClock = value;\nreturn old == Value.FALSE && value == Value.TRUE;\n}\n/** Liefert den aktuellen Wert des Z\u00e4hlers zur\u00fcck. */\npublic Value getValue() {\nreturn value;\n}\n/** Aktualisiert den aktuellen Wert des Z\u00e4hlers. */\npublic void setValue(Value value) {\nthis.value = value;\n}\n}\nSimpleCounter\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Erzeugt einen einfachen Z\u00e4hler, der einen vierstelligen Gray-Kode durchl\u00e4uft. Dieses\n* Beispiel zeigt, wie ein Bauelement den eigenen internen Zustand verwalten kann. Der\n* gesamte auf den Zustand bezogene Kode findet sich in der Klasse CounterData. */\nclass SimpleGrayCounter extends InstanceFactory {\nprivate static final BitWidth BIT_WIDTH = BitWidth.create(4);\n// Beachten Sie bitte wieder, da\u00df wir keine Instanzenvariablen haben, die sich auf den Zustand\n// einer individuellen Instanz beziehen. Wir k\u00f6nnen dies hier nicht unterbringen, weil nur ein einziges\n// Objekt SimpleGrayCounter erzeugt werden wird, dessen Aufgabe es ist, alle\n// Instanzen in allen Schaltungen zu verwalten.\npublic SimpleGrayCounter() {\nsuper(\"Gray Counter (Simple)\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, BIT_WIDTH.getWidth()),\n});\n}\npublic void propagate(InstanceState state) {\n// Hier besorgen wir uns den Zustand dieses Bauelements durch eine\n// Hilfsmethode. Der Zusatnd befindet sich in einem CounterData-Objekt, wo auch\n// die Hilfsmethode definiert wurde. Die Hilfsmethode wird ein\n// CounterData-Objekt erzeugen, falls dieses noch nicht existiert.\nCounterData cur = CounterData.get(state, BIT_WIDTH);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n// (Sie k\u00f6nnten versucht sein, den Wert des Z\u00e4hlers \u00fcber\n// state.getPort(1) zu ermitteln. DIes w\u00e4re aber falsch, denn ein anderes Bauelement\n// k\u00f6nnte einen Wert an denselben Punkt zwingen, was\n// den tats\u00e4chlichen Wert korrumpieren w\u00fcrde. Wir m\u00fcssen den aktuellen Wert wirklich in\n// der Instanz speichern.)\n}\npublic void paintInstance(InstancePainter painter) {\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST); // zeichne ein Dreieck an Port 0\npainter.drawPort(1); // Zeichne Port 1 als einfachen Punkt\n// Zeige den aktuellen Wert zentriert im Rechteck an.\n// Wenn jedoch der Kontext besagt, da\u00df der Wert nicht angezeigt werden soll, (z.B. beim Drucken)\n// dann \u00fcberspringe dies.\nif(painter.getShowState()) {\nCounterData state = CounterData.get(painter, BIT_WIDTH);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(BIT_WIDTH.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}"
  },
  {
    "id": 65,
    "title": "Gray-Kode-Z\u00e4hler",
    "url": "/de/html/guide/jar/counter.html",
    "text": "Gray-Kode-Z\u00e4hler\nGray-Kode-Z\u00e4hler\nWir setzen diese Einf\u00fchrung in die Bibliotheken von Logisim jetzt mit einem recht anspruchsvollen Gray-Kode-Z\u00e4hler fort. Bei diesem l\u00e4\u00dft sich der Wert mit dem Schaltwerkzeug \u00e4ndern, und es l\u00e4\u00dft sich eine Beschriftung auf dem Bauelement anbringen. Das Beispiel zeigt auch, wie das Symbol f\u00fcr das Werkzeug im \u00dcbersichtsfenster bearbeitet werden kann.\nGrayCounter\npackage com.cburch.gray;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.Instance;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Erzeugt einen Z\u00e4hler, der Gray-Kodes durchl\u00e4uft. Hier werden\n* mehrere weitere Funktionen gezeigt, die \u00fcber die Klasse SimpleGrayCounter hinausgehen. */\nclass GrayCounter extends InstanceFactory {\npublic GrayCounter() {\nsuper(\"Gray Counter\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n// Der Z\u00e4hler hat Attribute f\u00fcr Bitbreite, Beschriftung und Zeichensatz der Beschriftung. Die letzteren beiden\n// Attribute erlauben es uns, dem Bauelement eine Beschriftung zu geben (auch wenn\n// wir au\u00dferdem noch configureNewInstance ben\u00f6tigen, um die Position der Beschriftung\n// anzugeben).\nsetAttributes(\nnew Attribute[] { StdAttr.WIDTH, StdAttr.LABEL, StdAttr.LABEL_FONT },\nnew Object[] { BitWidth.create(4), \"\", StdAttr.DEFAULT_LABEL_FONT });\n// Der folgende Methodenaufruf schafft die Voraussetzungen daf\u00fcr, da\u00df der Zustand\n// der Instanz mit demSchaltwerkzeug g\u00e4ndert werden kann.\nsetInstancePoker(CounterPoker.class);\n// Die zwei n\u00e4chsten Zeilen sorgen daf\u00fcr, da\u00df\n// das Bauelement mit einem individuellen Symbol dargestellt wird. Hierbei sollte es sich um ein\n// 16x16 Punkte gro\u00dfes Bild handeln.\nURL url = getClass().getClassLoader().getResource(\"com/cburch/gray/counter.gif\");\nif(url != null) setIcon(new ImageIcon(url));\n}\n/** Die Methode configureNewInstance wird jedes Mal aufgerufen, wenn eine neue Instanz\n* erstellt wird. In der \u00dcberklasse macht diese Methode nichts, weil die neue\n* Instanz schon per Voreinstellung gr\u00fcndlich konfiguriert wird. Aber\n* manchmal m\u00fcssen spezielle Operationen f\u00fcr jede Instanz durchgef\u00fchrt werden, und\n* dann w\u00fcrden Sie diese Methode \u00fcberschreiben. In diesem Beispiel soll die Position der Beschriftung\n* festgelegt werden. */\nprotected void configureNewInstance(Instance instance) {\nBounds bds = instance.getBounds();\ninstance.setTextField(StdAttr.LABEL, StdAttr.LABEL_FONT,\nbds.getX() + bds.getWidth() / 2, bds.getY() - 3,\nGraphicsUtil.H_CENTER, GraphicsUtil.V_BASELINE);\n}\npublic void propagate(InstanceState state) {\n// Dieser Abschnitt ist genauso wie beim SimpleGrayCounter, abgesehen davon, da\u00df wir das\n// StdAttr.WIDTH Attribut benutzen, um die zu verwendende Bitbreite zu bestimmen.\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nCounterData cur = CounterData.get(state, width);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n}\npublic void paintInstance(InstancePainter painter) {\n// Im Prinzip genauso, wie bei dem SimpleGrayCounter, abgesehen vom\n// Aufruf von painter.drawLabel um die Beschriftung zu zeichnen.\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST);\npainter.drawPort(1);\npainter.drawLabel();\nif(painter.getShowState()) {\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nCounterData state = CounterData.get(painter, width);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(width.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}\nCounterPoker\npackage com.cburch.gray;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstancePoker;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.StdAttr;\n/** Wenn der Anwender den Z\u00e4hler mit dem Schaltwerkzeug anklickt, wird ein CounterPoker-Objekt\n* erzeugt, da\u00df die Benutzerereignisse behandelt. Beachten Sie, da\u00df\n* CounterPoker eine spezifische Klasse von GrayCounter ist, und da\u00df es eine\n* Unterklasse von InstancePoker aus dem\ncom.cburch.logisim.instance-Paket sein mu\u00df. */\npublic class CounterPoker extends InstancePoker {\npublic CounterPoker() { }\n/** Legt fest, ob die Position des Mausklicks eine Bearbeitung\n* zur Folge haben soll.\n*/\npublic boolean init(InstanceState state, MouseEvent e) {\nreturn state.getInstance().getBounds().contains(e.getX(), e.getY());\n// Ein Mausklick irgendwo im Hauptrechteck l\u00f6st eine Bearbeitung aus. Der Anwender hat vielleicht auf die Beschriftung geklickt,\n// dies l\u00e4ge aber au\u00dferhalb der Begrenzung.\n}\n/ ** Zeichnet einen Indikator daf\u00fcr, da\u00df der Eingabebereich ausgew\u00e4hlt wurde. Jetzt zeichnen wir\n* ein rotes Rechteck um den Wert. */\npublic void paint(InstancePainter painter) {\nBounds bds = painter.getBounds();\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nint len = (width.getWidth() + 3) / 4;\nGraphics g = painter.getGraphics();\ng.setColor(Color.RED);\nint wid = 7 * len + 2; // width of caret rectangle\nint ht = 16; // height of caret rectangle\ng.drawRect(bds.getX() + (bds.getWidth() - wid) / 2,\nbds.getY() + (bds.getHeight() - ht) / 2, wid, ht);\ng.setColor(Color.BLACK);\n}\n/** Bearbeitet einen Tastendruck, indem es diesen einfach an das Ende des aktuellen Wertes stellt. */\npublic void keyTyped(InstanceState state, KeyEvent e) {\n// wandelt um in eine hexadezimale Ziffer, wenn es keine g\u00fcltige Ziffer ist, wird abgebrochen.\nint val = Character.digit(e.getKeyChar(), 16);\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nif(val < 0 || (val & width.getMask()) != val) return;\n// berechne den n\u00e4chsten Wert\nCounterData cur = CounterData.get(state, width);\nint newVal = (cur.getValue().toIntValue() * 16 + val) & width.getMask();\nValue newValue = Value.createKnown(width, newVal);\ncur.setValue(newValue);\nstate.fireInvalidated();\n// Sie k\u00f6nnten versucht sein, den Wert jetzt direkt \u00fcber\n// state.setPort auszugeben. Aber die Schaltung k\u00f6nnte gerade an einer Stelle besch\u00e4ftigt sein\n// und der direkte Zugriff auf setPort k\u00f6nnte hier\n// st\u00f6rend eingreifen. Die Benutzung von fireInvalidated benachrichtigt die Aktualisierungsroutine\n// den Wert des Z\u00e4hlers bei n\u00e4chster Gelegenheit weiterzuleiten.\n}\n}"
  },
  {
    "id": 66,
    "title": "Richtlinien",
    "url": "/de/html/guide/jar/guide.html",
    "text": "Richtlinien\nRichtlinien\nLernen Sie mehr\n\u00dcber die Reihe dieser Beispiele hinaus, so bietet der Quellkode von Logisim eine Vielzahl weiterer Beispiele, auch wenn diese nicht immer denselben Grad an Lesbarkeit und gutem Design aufweisen.\nUm die \u00dcbertragbarkeit auf k\u00fcnftige Versionen sicherzustellen, sollten Sie sich soweit m\u00f6glich an die Klassen in den ...instance, ...data und ...tools-Paketen halten. Nat\u00fcrlich d\u00fcrfen Sie auch die APIs anderer Pakete benutzen, diese sind aber anf\u00e4lliger f\u00fcr \u00c4nderungen in k\u00fcnftigen Versionen von Logisim.\nDer Autor ist grunds\u00e4tzlich bereit, gelegentliche Bitten um Hilfe zu beantworten. Und Fehlerberichte und Verbesserungsvorschl\u00e4ge sind nat\u00fcrlich jederzeit willkommen.\nVerbreitung\nVon Ihnen erstellte JAR-Archive d\u00fcrfen Sie ohne jede Einschr\u00e4nkung weitergeben. Die Regelungen der GPL gelten aber, soweit Teile Ihrer Arbeit aus dem Quellkode von Logisim abgeleitet sind, der unter der GPL ver\u00f6ffentlicht wurde. Eine Ableitung aus den Beispielen in diesem Abschnitt des Leitfadens unterliegt nicht diesen Einschr\u00e4nkungen, da diese unter der MIT-Lizenz ver\u00f6ffentlicht worden sind.\nWenn Sie Ihre Bibliothek anderen Anwendern von Logisim zug\u00e4nglich machen m\u00f6chten, so ist der Autor immer dazu bereit, einen Link auf eine Webseite oder auch das JAR-Archiv selbst auf der Homepage von Logisim bereitszustellen. Wenn Sie der Meinung sind, Ihre Bibliothek sollte ein Teil der normalen Ausgabe von Logisim werden, dann freut sich der Autor \u00fcber Ihre VorschI\u00e4ge, und wird gerne Ihren Beitrag zu Ausgaben von Logisim anerkennen, die Ihre Arbeit enthalten."
  },
  {
    "id": 67,
    "title": "\u00dcber das Programm",
    "url": "/de/html/guide/about/index.html",
    "text": "\u00dcber das Programm\n\u00dcber das Programm\nLogisim ist Software mit offenem Quellkode. Der vollst\u00e4ndige Quellkode ist im Unterverzeichnis src des JAR-Archives enthalten.\nBitte teilen Sie dem Programmautoren mit, wenn Sie Logisim brauchbar finden und benutzen. Insbesondere, wenn Sie Logisim f\u00fcr Schulungs- und Ausbildungszwecke einsetzen. Diese Information kann dem Autoren helfen, weitere Unterst\u00fctzung f\u00fcr die Arbeit an Logisim zu bekommen.\nDer Autor begr\u00fc\u00dft alle Emails \u00fcber Logisim, einschlie\u00dflich Berichte \u00fcber Fehler, Vorschl\u00e4ge und Verbesserungen. Wenn Sie sich per Email an den Autoren wenden, dann vergessen Sie bitte nicht, da\u00df dieser hart an dem Programm gearbeitet hat, ohne irgendeine Bezahlung von Ihnen bekommen zu haben. Wenn Sie das Recht f\u00fcr eine Beschwerde w\u00fcnschen, dann empfehlen wir Ihnen, das Geld f\u00fcr eine Lizenz eines konkurrierenden Programmes auszugeben. (Uns sind derzeit keine kommerziellen Programme bekannt, die an den Funktionsumfang von Logisim herankommen.) Auf jeden Fall aber ist der Programmautor daran interessiert, das Programm weiter zu verbessern, und Ihre Vorschl\u00e4ge dazu sind sehr willkommen.\nCopyright-Hinweis\nCopyright (c) 2005, Carl Burch.\nLogisim ist kostenlose Software. Sie k\u00f6nnen das Programm in \u00dcbereinstimmung mit der GNU General Public License weiterverbreiten und/oder modifizieren. Es gilt die Version 2 der Lizenz, oder (wie Sie w\u00fcnschen) eine beliebige, neuere Version.\nLogisim wird mit der Hoffnung herausgegeben, da\u00df es n\u00fctzlich ist, aber es kommt OHNE JEDE GARANTIE; dies schlie\u00dft auch die Abwesenheit einer Garantie f\u00fcr MARKTREIFE oder EIGNUNG F\u00dcR EINEN BESTIMMTEN ZWECK mit ein. Bitte sehen Sie sich die GNU General Public License f\u00fcr weitere Einzelheiten an.\nDanksagungen\nDer Quellkode zu Logisim ist im Wesentlichen das Werk des Autoren. Der Autor m\u00f6chte an dieser Stelle seinen Arbeitgebern danken, die seine Arbeit als Professor, inklusive der Programmierung finanzieren: die Entwicklung wurde an der Saint John's University (Collegeville, Minnesota, USA) in den Jahren 2000-2004 angefangen und seit 2004 bis zum jetzigen Zeitpunkt am\nHendrix College (Conway, Arkansas, USA) weitergef\u00fchrt. Der Autor ist beiden Hochschulen zu Dank verpflichtet, da\u00df ihm die Zeit und Ressourcen f\u00fcr dieses Projekt zur Verf\u00fcgung gestellt worden sind. Wenn nur alle Hochschulen und Universit\u00e4ten sich \u00e4hnlich um die F\u00f6rderung von exzellentem Unterricht k\u00fcmmern w\u00fcrden, wie diese beiden Schulen!\nEinige weitere Menschen, die besonders hilfreich gewesen sind:\nIlia Lilov, Pablo Leal Ramos und Uwe Zimmermann, die zu den \u00dcbersetzungen von Logisim beigetragen haben. Weitere Informationen zu den \u00dcbersetzungen finden Sie im Abschnitt zur Internationaliserung.\nDie CS61C-Klasse der University of California, Berkeley aus dem Fr\u00fchjahr 2005, die die Beta-Versionen von Logisim 2.0 \u00fcber sich ergehen lassen mu\u00dften. Diese Studenten mu\u00dften mit\nvielen Fehlern leben, und der Autor ist sehr dankbar f\u00fcr die Geduld und die Anregungen der Studenten!\nDie CSCI 150-Klassen am College of Saint Benedict und an der Saint John's University vom Fr\u00fchjahr 2001, die die elementarsten Versionen von Logisim benutzt haben, als es gerade entwickelt wurde.\nMehrere Teile von Logisim stammen aus Softwarepaketen, die von anderen Autoren entwickelt worden sind. Von diesen werden einige als Teil von Logisim verbreitet.\ndie Java API von Sun (nat\u00fcrlicherweise)\ndas JavaHelp-Projekt von Sun\nStellt das eingebaute Hilfesystem aus dem Hilfemen\u00fc zur Verf\u00fcgung.\nMRJAdapter von Steve Roy\nZur Integration auf der Macintosh OS X-Plattform.\nlaunch4j von Grzegorz Kowalt\nErlaubt die Verbreitung von Logisim als ausf\u00fchrbare Datei unter Windows.\nGIFEncoder von Adam Doppelt\nSpeichert Bilder als GIF-Dateien. Dies wiederum ist auf C-Kode von Sverre H. Huseby aufgebaut.\nColorPicker von Jeremy Wood\nStellt den Farbauswahldialog zur Verf\u00fcgung, der bei der Konfigurationen von Farben erscheint (zum Beispiel beim LED-Bauelement).\nJFontChooser von Christos Bohoris\nStellt den Schriftartendialog zur Verf\u00fcgung, der bei der Auswahl der Schriftart erscheint (zum Beispiel beim Schriftartenattribut der Beschriftung vieler Bauelemente).\nTableSorter, zugeschrieben Philip Milne, Brendon McLean, Dan van Enckevort, Parwinder Sekhon und ouroborus@ouroborus.org\nErlaubt es, die Tabelle im Dialogfenster zur Schaltungsstatistik durch Klicken der Spalten\u00fcberschriften zu sortieren.\nUnd schlie\u00dflich m\u00f6chte der Autor allen Anwendern danken, die sich bei ihm gemeldet haben - sei es mit Fehlerberichten, mit Voraschl\u00e4gen, oder mit der Mitteilung, da\u00df sie Logisim im Unterricht einsetzen. Da der Autor nicht die ausdr\u00fcckliche Einverst\u00e4ndniserkl\u00e4rung besitzt, verbleiben diese Personen an dieser Stelle anonym, aber trotzdem: Danke!"
  },
  {
    "id": 68,
    "title": "GNU General Public License",
    "url": "/de/html/guide/about/gpl.html",
    "text": "\u00dcber das Programm\nGNU GENERAL PUBLIC LICENSE\nVersion 2, June 1991\nCopyright (C) 1989, 1991 Free Software Foundation, Inc.\n51 Franklin St, Fifth Floor, Boston, MA\n02110-1301\nUSA\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\nPreamble\nThe licenses for most software are designed to take away your\nfreedom to share and change it.\nBy contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.\nThis\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.\n(Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)\nYou can apply it to\nyour programs, too.\nWhen we speak of free software, we are referring to freedom, not\nprice.\nOur General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\nTo protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.\nYou must make sure that they, too, receive or can get the\nsource code.\nAnd you must show them these terms so they know their\nrights.\nWe protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\nAlso, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.\nIf the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\nFinally, any free program is threatened constantly by software\npatents.\nWe wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.\nTo prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\nThe precise terms and conditions for copying, distribution and\nmodification follow.\nGNU GENERAL PUBLIC LICENSE\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.\nThe \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.\n(Hereinafter, translation is included without limitation in\nthe term \"modification\".)\nEach licensee is addressed as \"you\".\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.\nThe act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\na) You must cause the modified files to carry prominent notices\nstating that you changed the files and the date of any change.\nb) You must cause any work that you distribute or publish, that in\nwhole or in part contains or is derived from the Program or any\npart thereof, to be licensed as a whole at no charge to all third\nparties under the terms of this License.\nc) If the modified program normally reads commands interactively\nwhen run, you must cause it, when started running for such\ninteractive use in the most ordinary way, to print or display an\nannouncement including an appropriate copyright notice and a\nnotice that there is no warranty (or else, saying that you provide\na warranty) and that users may redistribute the program under\nthese conditions, and telling the user how to view a copy of this\nLicense.\n(Exception: if the Program itself is interactive but\ndoes not normally print such an announcement, your work based on\nthe Program is not required to print an announcement.)\nThese requirements apply to the modified work as a whole.\nIf\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.\nBut when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\na) Accompany it with the complete corresponding machine-readable\nsource code, which must be distributed under the terms of Sections\n1 and 2 above on a medium customarily used for software interchange; or,\nb) Accompany it with a written offer, valid for at least three\nyears, to give any third party, for a charge no more than your\ncost of physically performing source distribution, a complete\nmachine-readable copy of the corresponding source code, to be\ndistributed under the terms of Sections 1 and 2 above on a medium\ncustomarily used for software interchange; or,\nc) Accompany it with the information you received as to the offer\nto distribute corresponding source code.\n(This alternative is\nallowed only for noncommercial distribution and only if you\nreceived the program in object code or executable form with such\nan offer, in accord with Subsection b above.)\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.\nFor an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.\nHowever, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.\nAny attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n5. You are not required to accept this License, since you have not\nsigned it.\nHowever, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.\nThese actions are\nprohibited by law if you do not accept this License.\nTherefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.\nYou may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.\nIf you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.\nFor example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.\nMany people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.\nIn such case, this License incorporates\nthe limitation as if written in the body of this License.\n9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.\nSuch new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\nEach version is given a distinguishing version number.\nIf the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.\nIf the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.\nFor software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.\nOur decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\nNO WARRANTY\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\nTHE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.\nSHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\nEND OF TERMS AND CONDITIONS"
  },
  {
    "id": 69,
    "title": "Bibliotheksreferenz",
    "url": "/de/html/libs/index.html",
    "text": "Bibliotheksreferenz\nBibliotheksreferenz\nA Logisim library holds a set of tools that allow you to\ninteract with a circuit via clicking and dragging the mouse in the\ncanvas area. Most often, a tool is intended for adding components of a\nparticular type into a circuit; but some of the most important tools,\nsuch as the Poke Tool and the Select Tool, allow you to interact with\ncomponents in other ways.\nAll of the tools included in Logisim's built-in libraries are\ndocumented in this reference material.\nBasisbibliothek\nSchaltwerkzeug\nBearbeitungswerkzeug\nAuswahlwerkzeug\nVerbindungswerkzeug\nTextwerkzeug\nMen\u00fcwerkzeug\nVerteiler\nPin\nTunnel\nPull Resistor\nTestpunkt\nTakt\nBit-Erweiterung\nLabel\nGatterbibliothek\nKonstante\nInverter\nPuffer\nAND/OR/NAND/NOR-Gatter\nXOR/XNOR/Odd Parity/Even Parity Gate\nTristate-Puffer/Inverter\nAuswahlschaltungsbibliothek\nMultiplexer\nDemultiplexer\nDekoder\nPriorit\u00e4tsenkoder\nBit-W\u00e4hler\nArithmetikbibliothek\nAddierer\nSubtrahierer\nMultiplizierer\nTeiler\nNegator\nKomparator\nBitschieber\nBit-Addierer\nBit-Finder\nSpeicherbibliothek\nD/T/J-K/S-R Flip-Flop\nRegister\nZ\u00e4hler\nSchieberegister\nZufallsgenerator\nRAM\nROM\nEingabe/Ausgabe-Bibliothek\nTaster\nJoystick\nTastatur\nLED\n7-Segmentanzeige\nHexadezimale Anzeige\nLED-Matrix\nTerminal\nAltlasten\nLogisim 1.0 D/J-K Flip-Flop\nLogisim 1.0 8-Bit Register"
  },
  {
    "id": 70,
    "title": "Wiring library",
    "url": "/en/html/libs/wiring/index.html",
    "text": "Wiring Library\nWiring Library\nThe Wiring library includes basic elements that are needed for most circuits.\nSplitter \u2014 join or split wires into buses\nPin \u2014 input to and output from a circuit\nProbe \u2014 display values on wires\nTunnel \u2014 make connections without drawing wires\nClock \u2014 oscillates between zero and one\nConstant \u2014 like an input, but with a fixed value\nBit Extender \u2014 zero-extend or sign-extend binary numbers\nUp to Library Reference"
  },
  {
    "id": 71,
    "title": "Splitter",
    "url": "/en/html/libs/wiring/splitter.html",
    "text": "Splitter\nSplitter\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe splitter creates a correspondence between a multi-bit value and several\nseparate subsets of those bits. Despite its name, it can either\nsplit a multi-bit value into component parts, or it can combine\ncomponent parts into a multi-bit value; or it can do both at once.\nA more complete description of splitters is found in the 'Splitters' section of the\nUser's Guide.\nLogisim treats splitters specially when propagating values within a\ncircuit: Whereas all other components have a computed delay for purposes\nof simulating their behavior, values propagate through splitters (as\nwell as wires) instantaneously.\nNote: The term splitter is a non-standard\nterm, which is unique to Logisim as far as I know. I am unaware of any\nstandard term for such a concept; the only term I have heard used is\nbus ripper, but this term is unnecessarily violent for my\ntastes.\nPins\nTo distinguish the several connecting points for a splitter, we refer\nto the single connecting point one side as its combined end,\nand we refer to the multiple connecting points on the other side as its\nsplit ends.\nCombined end (input/output bit width matches Bit Width In attribute)\nA value holding all of the bits traveling through the splitter.\nSplit ends (input/output, bit width computed based on Bit x attributes)\nThe number of split ends is specified in the Fan Out attribute, and\neach split end has an index that is at least 0 and less than the Fan Out\nattribute. For each split end, all bits for which Bit x\nrefers to its index travels through that split end; the order of these\nbits is the same as their order within the combined end.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Fan Out attribute,\nAlt-0 through Alt-9 alter both the Fan Out and Bit Width In attributes,\nand the arrow keys alter its Facing attribute.\nFacing\nThe location of the split ends relative to the combined end.\nFan Out\nThe number of split ends.\nBit Width In\nThe bit width of the combined end.\nAppearance\nSupports different ways of depicting the splitter in the circuit.\nThe Left-handed option (the default) draws a spine going left from the\ncombined end, with a labeled line coming from the spine for each split end.\nThe Right-handed option is the same except the spine goes right (if you're\nfacing according to the Facing attribute).\nThe Centered option centers the spine so it goes in roughly equal directions\nleft and right.\nAnd the Legacy option draws diagonal lines to each split end, without labels;\nthis option is primarily for compatibility with versions\nolder than 2.7.0, when this was the only option for splitter appearance.\nSpacing\nControls how far appart the split end pins are placed.\nBit x\nThe index of the split end to which bit x of the combined\nend corresponds. The split ends are indexed starting from 0 at the top\n(for a splitter facing east or west) or from 0 at the left/west (for a\nsplitter facing north or south). A bit can be specified to correspond to\nnone of the split ends. There is no way for a bit to correspond to\nmultiple split ends.\nSometimes you can avoid twiddling each individual Bit x attribute\nby bringing up the pop-up menu for a splitter (usually by right-clicking or\ncontrol-clicking it). The pop-up menu includes options labeled Distribute Ascending\nand Distribute Descending. The Distribute Ascending option distributes the bits\nso that each split end receives the same number of bits, starting from end 0.\n(If the number of split ends doesn't divide exactly into the number of bits,\nthen the bits are distributed as evenly as possible.)\nDistribute Descending does the same but starts from the highest-numbered end.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 72,
    "title": "Pin",
    "url": "/en/html/libs/wiring/pin.html",
    "text": "Pin\nPin\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA pin serves as an output from a circuit or as an input to a circuit, depending on the value\nof its 'Type' attribute. Logisim represents output\npins using a circle or rounded rectangle, and input pins are represented\nusing squares or rectangles. In either case, the individual bits of the\nvalue being sent or received is displayed within the component (except\nin printer view, when the bit width is shown instead).\nA pin is a convenient component for interacting with a circuit, and\nbeginning Logisim users need not use them in any other way. But a\nuser building a circuit using several subcircuits (as described in the\n`Subcircuits' section of\nthe User's Guide) will use pins also\nto specify the interface between an outer\ncircuit and the subcircuits it contains. In particular, a circuit layout's pin\ncomponents define the pins that appear on the subcircuit component when\nthe layout is used within another circuit. In such a circuit, the values\nsent and received to those locations on the subcircuit component are\ntied to the pins within the subcircuit layout.\nPins\nA pin component has only one pin. Counterintuitively, when the Pin\ncomponent's type is set to 'input', the pin will actually be an output\u2014\nthe Pin component in this case is taking input from the user (or from some other\ncircuit in which this layout is embedded) and outputting that value to the\nconnected wire. Conversely, when the Pin's type is set to 'output' the pin takes\ninput from the connected wire and outputs it to the screen for the user to see\n(or to some other circuit in which thhis layout is embedded). In either case,\nits bit width matches the Data Bits attribute, and its location depends on the\nFacing attribute.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nthe arrow keys alter its Facing attribute,\nand Alt with an arrow key alters its Label Location attribute.\nFacing\nThe side of the component where its input/output pin should be.\nType\nSpecifies whether the component is used to input values into the circuit, or\nto output values from the circuit.\nData Bits\nThe number of bits for the value that the pin handles.\nBehavior\nControls how an input pin behaves in several special cases, mostly involving\nerror and unknown values. Output pins do not have a Behavior attribute, as they\nwork the same in all circumstances: whatever value is carried by the connected\nwire is shown to the user and passed up to any parent circuit, and if no wire is\nconnected, an 'X' is used instead to indicate a floating value. For input pins,\nseveral behaviors are available:\nSimple. In most cases \"Simple\" behavior should be sufficient.\nFor an input controled by the user, the user can select either zero or one\n(or any combination of zeros and ones for a multi-bit input pin). For an\ninput controlled by a parent circuit, whatever value the parent sends (0, 1,\nE, or X, or some combination of them) is passed to the circuit, or zero is\nused if the parent does not have a wire connected to that pin. Note that\nwith \"Simple\" behavior, an input pin will never create a new floating value\n(X) or error value (E), though it can passes them along from a parent\ncircuit.\nTri-State. This behavior is nearly identical to \"Simple\"\nbehavior, except that for input pins controlled by the user, the user can\nadditional select \"X\" to indicate a floating input.\nPull Down and Pull Up. This behavior is nearly identical\nto \"Simple\" behavior, except that for input pins controlled by a parent\ncircuit: if the parent circuit attempts to send an unknown value (X) to this\npin, it will be converted automatically to either zero (for Pull Down) or one (for Pull\nUp) before being sent into the circuit. Note that this does not affect the\nparent circuit in any way\u2014the parent circuit wire will still show X,\nwhile the subcircuit will receive a zero or one.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nRadix\nThe number base used for displaying values (and entering values for input\npins).\nPoke Tool Behavior\nClicking an output pin has no effect, although the pin's attributes\nwill be displayed.\nClicking an input pin will toggle the bit that is clicked or, when the\n'Radix' is set to something other than binary, iterate through different\npossible values. The keyboard can also be used to enter values using the Poke\ntool.\nWhen viewing the state of a subcircuit\nas described in the `Debugging\nSubcircuits' of the User's Guide,\nthe value of each input pin is tied (\"pinned\") to whatever value the subcircuit\nis receiving from the containing parent circuit. Manually change the value of\nthe input pin break this link between the subcircuit's state and the containing\ncircuit's state, essentially creating a new isolated simulation of just this one\ncircuit, independent from any parent circuit. In this situation, any attempting\nto change the input pin's value using the Poke Tool will cause Logisim to warn\nthe user and confirm whether breaking this link is actually desired.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 73,
    "title": "Probe",
    "url": "/en/html/libs/wiring/probe.html",
    "text": "Probe\nProbe\nLibrary:\nWiring\nIntroduced:\n2.0.3 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA probe is an element that simply displays the value at a given point\nin a circuit. It does not itself interact with other components.\nIn most respects, the probe component duplicates the functionality found in a\nPin component configured as an output pin. The difference\nis that if the circuit is used as a subcircuit component, then an output pin\nwill be a part of that interface, whereas a probe is not. They also are\ndifferent in that the probe automatically adapts its width to whatever it is\nconnected to. Graphically, a probe looks like a pin but has a thinner, gray\nborder and a yellow background.\nPins\nA probe component has only one pin, which acts as an input to\nthe probe. The width that this pin accepts is adaptive: The probe will\nadapt to inputs of any width.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe side of the component where its input pin should be.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nRadix\nThe base (for example, binary, decimal, or hexadecimal) in which\nthe value is displayed.\nPoke Tool Behavior\nNone.\nFPGA SynthesisNone, but Probe components will be silently\nignored during FPGA synthesis.\nUp to Library Reference"
  },
  {
    "id": 74,
    "title": "Tunnel",
    "url": "/en/html/libs/wiring/tunnel.html",
    "text": "Tunnel\nTunnel\nLibrary:\nWiring\nIntroduced:\n2.5.0 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA tunnel acts like a wire in that it binds points together,\nbut unlike a wire the connection is not explicitly drawn.\nThis is helpful when you need to connect points far apart in the circuit\nand a network of wires would make the circuit much more ugly.\nThe below illustration illustrates how this works.\nHere, all three tunnels have the same label, a, and so\nthe three points to which the tunnels point are connected.\n(If one of the tunnels were labeled something else, like b,\nthen it would be part of a different set of tunnels.)\nThe tristate buffer at top emits a floating output\nsince its lower input is 0.\nThis normally leads the wire coming from the tristate buffer to be blue;\nbut here it is dark green because the floating output combines\nthrough the tunnel with the 0 from the pin at bottom.\nIf the control input into the tristate buffer changes to 1,\nthen the tristate buffer would feed 1 into the tunnel,\nwhich would combine with 0 from the pin at bottom to result in an error value; thus, we would then see red wires feeding through all three tunnels.\nPins\nA tunnel has only one pin, whose bit width matches the tunnel's\nData Bits attribute. This pin is bidirection, allowing values to flow in either\ndirection through the tunnel.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction toward which the tunnel points.\nData Bits\nThe number of bits for the tunnel.\nLabel\nThe text within the label associated with the tunnel.\nThis tunnel is connected to all other tunnels with exactly the same label.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 75,
    "title": "Pull Resistor",
    "url": "/en/html/libs/wiring/pull.html",
    "text": ""
  },
  {
    "id": 76,
    "title": "Clock",
    "url": "/en/html/libs/wiring/clock.html",
    "text": "Clock\nClock\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 13 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe clock toggles its output value on a regular schedule as long as\nauto-ticks are enabled via the\nSimulate menu, or when a manual\nhalf-tick or full-tick is selected from the same menu.\n(Auto-ticking are disabled by default.)\nA \"tick\" is Logisim's unit of time; the speed at which ticks occur can\nbe selected from the Simulate menu's Auto-Tick Frequency submenu.\nEach clock component's duty cycle can be independently configured using its High\nDuration and Low Duration attributes.\nNote that Logisim's simulation of clocks is quite unrealistic: In\nreal circuits, multiple clocks will drift from one another and will\nnever move in lockstep. But in Logisim, all clocks experience ticks at\nthe same rate.\nWarning: The auto-tick frequency is best-effort\u2014Logisim will\nattempt to toggle the clocks at the selected frequency, but does not provide\nany guarantees. Complex circuits will necessarily require more actual time\nto simulate, and will not be able to keep up with high clock frequencies.\nThe actual simulated frequency can be displayed (see the 'Window' tab of the\nLogisim Preferences).\nPins\nA clock has only one pin, an output with a bit width of 1, whose\nvalue will represent the current value of the clock. The location of\nthis pin is specified in the Facing attribute. The clock's value\nwill toggle on its schedule whenever ticks are enabled, and it will\ntoggle whenever it is clicked using the Poke\nTool.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe side of the component where its output pin should be.\nHigh Duration\nThe length of time within each cycle that the clock's output should\nbe 1.\nLow Duration\nThe length of time within each cycle that the clock's output should\nbe 0.\nLabel\nThe text within the label associated with the clock component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nClicking a clock component will toggle its current output value\nimmediately. Note that all clocks are tied to the same simulated notion\nof time, so poking any one clock will toggle all clocks in the current\nsimulation.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 77,
    "title": "Constant",
    "url": "/en/html/libs/wiring/constant.html",
    "text": "Constant\nConstant\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Gates library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nEmits the value specified in its Value attribute.\nPins\nThere is only one pin, an output whose bit width matches the Data Bits\nattribute. The location of this pin is specified in the Facing\nattribute. The component constantly outputs on this pin whatever\nvalue specified in the Value attribute.\nAttributes\nWhen the component is selected or being added,\nthe hexademical digits '0' through '9' and 'a' through 'f' alter its Value attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction in which the pin is located relative to where the\nvalue is drawn.\nData Bits\nThe bit width of the value placed onto the wire.\nValue\nThe value, written in hexademical, that is emitted by the component.\nThe number of bits used to specify the value cannot exceed the\ncomponent's bit width.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 78,
    "title": "Power/Ground",
    "url": "/en/html/libs/wiring/const01.html",
    "text": ""
  },
  {
    "id": 79,
    "title": "Transistor",
    "url": "/en/html/libs/wiring/transist.html",
    "text": ""
  },
  {
    "id": 80,
    "title": "Transmission Gate",
    "url": "/en/html/libs/wiring/transmis.html",
    "text": ""
  },
  {
    "id": 81,
    "title": "Bit Extender",
    "url": "/en/html/libs/wiring/extender.html",
    "text": "Bit Extender\nBit Extender\nLibrary:\nWiring\nIntroduced:\n2.5.0 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe bit extender transforms a value into a value of another bit width.\nFor values being transformed into a smaller bit width,\nthe value is simply truncated to keep the lowest-order bits.\nFor values being transformed into a large bit width,\nthe lowest-order bits are kept the same,\nand you have a choice about what the additional high-order bits will be:\nThey can all be 0, all be 1, all match the input's sign bit\n(its highest-order bit), or the bit extender component can have an additional one-bit\ninput that determines the value for the upper bits.\nPins\nWest edge (input, bit width from Bit Width In attribute)\nThe multi-bit input whose value is to be transformed.\nEast edge (output, bit width from Bit Width Out attribute)\nThe computed output.\nNorth edge (input, bit width 1)\nSpecifies what the additional bits in the output should be.\nThis pin is available only when the Extension Type attribute is Input.\nAttributes\nWhen the component is selected or being added,\nthe digits 0 through 9 alter the Bit Width In attribute\nand Alt-0 through Alt-9 alter its Bit Width Out attribute.\nBit Width In\nThe input's bit width.\nBit Width Out\nThe output's bit width.\nExtension Type\nAssuming the output bit width exceeds the input bit width,\nthis attribute configures what the additional output bits should be.\nIf Zero or One, the additional bits are 0 or 1 accordingly.\nIf Sign, the additional bits are taken to match the highest-order bit in the input.\nAnd if Input, the component has a second input on its north side whose one-bit value is used for the additional bits.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\nUp to Library Reference"
  },
  {
    "id": 82,
    "title": "Gatterbibliothek",
    "url": "/de/html/libs/gates/index.html",
    "text": "Gates Library\nGatterbibliothek\nThe Gates library includes a variety of simple\ncomponents, all of which have a single output whose value is\ndictated entirely by the current inputs.\nKonstante\nInverter\nPuffer\nAND/OR/NAND/NOR-Gatter\nXOR/XNOR/Odd Parity/Even Parity Gate\nTristate-Puffer/Inverter"
  },
  {
    "id": 83,
    "title": "Inverter",
    "url": "/de/html/libs/gates/not.html",
    "text": "Inverter\nInverter\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nShaped:\nRectangular:\nVerhalten\nThe NOT Gate emits the complement of whatever input\nit receives.\nThe truth table for a NOT gate is the following.\nxout\n01\n10\nIf the input is unspecified (i.e., floating), then the output will also be\nunspecified - unless the \"Gate Output When Undefined\" option is \"Error for\nundefined inputs,\" in which case the output is an error. If the input is an\nerror value, then the output will also be.\nA multi-bit NOT gate will perform the above transformation bitwise on\nits input.\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (input, bit width according to Data Bits attribute)\nThe component's input.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, whose value is the complement of the input value.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nData Bits\nThe bit width of the component's input and output.\nGate Size\nDetermines whether to draw a larger or a smaller version of the\ncomponent.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 84,
    "title": "Puffer",
    "url": "/de/html/libs/gates/buffer.html",
    "text": "Puffer\nPuffer\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nThe buffer simply passes through to its right output whatever input\nit receives on the left side.\nThe truth table for a one-bit buffer is the following.\nxout\n00\n11\nIf the input is unspecified (i.e., floating), then the output will also be\nunspecified - unless the \"Gate Output When Undefined\" option is \"Error for\nundefined inputs,\" in which case the output is an error. If the input is an\nerror value, then the output will also be.\nBuffers are the most useless of the gate components\nprovided in Logisim; its presence in the Gates library is just as much a\nmatter of completeness (a component for each possible\none-input truth table) as it is a matter of providing useful\nfunctionality. Still, it can be occasionally useful to ensure that\nvalues propagate in only one direction along a wire.\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (input, bit width according to Data Bits attribute)\nThe input into the component.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, which always matches the input into the left side.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nData Bits\nThe bit width of the component's inputs and outputs.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 85,
    "title": "AND/OR/NAND/NOR-Gatter",
    "url": "/de/html/libs/gates/basic.html",
    "text": "AND/OR/NAND/NOR-Gatter\nAND/OR/NAND/NOR-Gatter\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nAND\nOR\nNAND\nNOR\nShaped:\nRectangular:\nDIN 40700:\nVerhalten\nThe AND, OR, NAND, and NOT gates each compute the respective\nfunction of the inputs, and emit the result on the output.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value X.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates is the following.\n(The letter X represents the error value,\nand the letter Z represents the floating value.)\nAND\n01X/Z\n0000\n101X\nX/Z0XX\nOR\n01X/Z\n001X\n1111\nX/ZX1X\nNAND\n01X/Z\n0111\n110X\nX/Z1XX\nNOR\n01X/Z\n010X\n1000\nX/ZX0X\nIn short, these components work as expected as long as all inputs\nare either 0 or 1.\nIf an input is neither 0 nor 1 (it is floating or it is the error value)\nthen the component treats it as both 0 and 1:\nIf the output would be the same both ways\n(as when an AND gate has one input that is definitely 0\nand a questionable second input), that will be the output value;\nbut if the output changes depending on whether it is 0 or 1,\nthe output is the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of OR and NOR\ngates will be curved. Nonetheless, the input pins are in a line. Logisim\nwill draw short stubs illustrating this; and if you overshoot a stub, it\nwill silently assume that you did not mean to overshoot it. In \"printer\nview\", these stubs will not be drawn unless they are connected to\nwires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nAusrichtung\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute. However, if shaped gates are selected,\nthen the gate will be drawn with wings to accommodate additional inputs\nbeyond what the shape naturally accommodates.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nNegate x\nIf yes, the input is negated before it is fed into the gate.\nThe inputs are counted top-down if the facing is east or west,\nand they are counted left-to-right if the facing is north or south.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 86,
    "title": "XOR/XNOR/Even/Odd-Gatter",
    "url": "/de/html/libs/gates/xor.html",
    "text": "XOR/XNOR/Odd Parity/Even Parity Gate\nXOR/XNOR/Odd Parity/Even Parity Gate\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1 for XOR/Odd/Even; 2.0 Beta 6 for XNOR\nAussehen:\nXOR\nXNOR\nOddParity\nEvenParity\nShaped:\nRectangular:\nVerhalten\nThe XOR, XNOR, Even Parity, and Odd Parity gates each compute\nthe respective function of the inputs, and emit the result on the\noutput.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value X.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates is the following.\nxyXOR\nXNOROddEven\n00\n01\n01\n01\n10\n10\n10\n10\n10\n11\n01\n01\nAs you can see, the Odd Parity gate and the XOR gate behave identically\nwith two inputs; similarly, the even parity gate and the XNOR gate\nbehave identically.\nBut if there are more than two specified inputs, the XOR gate will emit\n1 only when there is exactly one 1 input, whereas the Odd Parity gate\nwill emit 1 if there are an odd number of 1 inputs.\nThe XNOR gate will emit 1 only when there is not exactly one 1\ninput, while the Even Parity gate will emit 1 if there are an even\nnumber of 1 inputs. The XOR and XNOR gates include an attribute titled\nMultiple-Input Behavior that allow them to be configured to use the\nOdd Parity and Even Parity behavior.\nIf any of the\ninputs are the error value (e.g., if conflicting values are coming into\nthe same wire) or floating, then the output will be the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nNote: Many authorities contend that the shaped XOR\ngate's behavior should correspond to the odd parity gate, but there is\nnot agreement on this point.\nLogisim's default behavior for XOR gates is based\non the IEEE 91 standard. It is also consistent with the intuitive\nmeaning underlying the term exclusive or: A waiter asking\nwhether you want a side dish of mashed potatoes, carrots, peas, or cole\nslaw will only accept one choice, not three, whatever some authorities\nmay tell you. (I must admit, though, that I have not subjected this\nstatement to a rigorous test.) You can configure the XOR and XNOR gates\nto use parity by changing its Multiple-Input Behavior attribute.\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of XOR and\nXNOR gates will be curved. Nonetheless, the input pins are in a line.\nLogisim will draw short stubs illustrating this; and if you overshoot a\nstub, it will silently assume that you did not mean to overshoot it. In\n\"printer view\", these stubs will not be drawn unless they are connected\nto wires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nAusrichtung\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute; however, if the number of inputs exceeds 3 (for a\nnarrow component) or 5 (for a wide component), then the gate will\nbe drawn with \"wings\" to be able to accommodate the number of inputs\nrequested.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nMultiple-Input Behavior (XOR and XNOR only)\nWhen three or more inputs are provided, the XOR/XNOR gate's output will\neither be based on whether exactly one input is 1 (the default) or an odd number\nof inputs are 1.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 87,
    "title": "Tristate-Puffer/Inverter",
    "url": "/de/html/libs/gates/controlled.html",
    "text": "Tristate-Puffer/Inverter\nTristate-Puffer/Inverter\nBibliothek:\nGates\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nThe controlled buffer and inverter, often called three-state\nbuffers/inverters, each have a one-bit \"control\"\ninput pin on the south side. The value at this control pin affects how\nthe component behaves:\nWhen the value on this pin is 1,\nthen the component behaves just like the respective component (a buffer or a inverter (NOT\ngate)).\nWhen the value is 0 or unknown (i.e., floating), then the\ncomponent's output is also floating.\nWhen the value is an error value (such as would occur when two\nconflicting values are being fed into the input), then the output is an\nerror value.\nControlled buffers can be useful when you have a wire (often called a\nbus) whose value should match the output of one of several\ncomponents.\nBy placing a controlled buffer between each component\noutput and the bus, you can control whether that component's output is\nfed onto the bus or not.\nPins (assuming component faces east, control line right-handed)\nWest edge (input, bit width matches Data Bits attribute)\nThe component input that will be used to compute the output if the\ncontrol input is 1.\nS\u00fcdseite (Eingang, Bitbreite 1)\nThe component's control input.\nEast edge (output, bit width matches Data Bits attribute)\nThe component's output, which will be floating if the control input\nis 0 or floating, the error value if the control input is the error\nvalue, and will be computed based on the west-side input if the control\ninput is 1.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\n(Controlled inverter only) Determines whether to draw a larger or a smaller\nversion of the component.\nControl Line Location\nThe location of the control line, imagining we are facing the output\nfrom the input: If the component faces east and is right-handed,\nthe control line is to the south; but if it is left-handed,\nthe control line is to the north.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 88,
    "title": "Auswahlschaltungsbibliothek",
    "url": "/de/html/libs/plexers/index.html",
    "text": "Plexers Library\nAuswahlschaltungsbibliothek\nThe Plexers library includes control components.\nLike the components of the Gates library, all are combinational,\nbut their purpose is generally for routing values.\nMultiplexer\nDemultiplexer\nDekoder\nPriorit\u00e4tsenkoder\nBit-W\u00e4hler"
  },
  {
    "id": 89,
    "title": "Multiplexer",
    "url": "/de/html/libs/plexers/mux.html",
    "text": "Multiplexer\nMultiplexer\nBibliothek:\nAuswahlschaltungen\nEingef\u00fchrt:\n2.0 Beta 11\nAussehen:\nVerhalten\nCopies an input on the west edge onto the output on\nthe east edge; which of the inputs to copy is specified via the\ncurrent value received through the input on the south edge.\nI find it useful to think of a multiplexer as analogous to a railroad\nswitch, controlled by the select input.\n(Incidentally, some authorities spell this\nmultiplexor,\nbut multiplexer is the predominant\nspelling.)\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge, variable number (inputs, bit width matches Data Bits attribute)\nData values, one of which is to be routed to the output.\nEach input data value is numbered, starting with 0 on the north.\nEast edge (output, bit width matches Data Bits attribute)\nThe output value will match the input values on the west\nedge whose number is the same as the value currently received\nthrough the select input on the south.\nIf the select input contains any unspecified (i.e., floating) bits,\nthen the output is completely floating.\nSouth edge (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which input\non the west edge to route to the output on the east edge.\nAttribute\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nAuswahlleitungen\nThe bit width of the component's select input on its south edge.\nThe number of inputs to the multiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the multiplexer.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 90,
    "title": "Demultiplexer",
    "url": "/de/html/libs/plexers/demux.html",
    "text": "Demultiplexer\nDemultiplexer\nBibliothek:\nAuswahlschaltungen\nEingef\u00fchrt:\n2.0 Beta 11\nAussehen:\nVerhalten\nCopies the input on the west edge onto exactly one of the outputs on\nthe east edge; which of these outputs is specified via the\ncurrent value received through the input on the south edge.\nI find it useful to think of a demultiplexer as analogous to a railroad\nswitch, controlled by the select input.\n(Incidentally, some authorities spell this\ndemultiplexor,\nbut demultiplexer is the predominant\nspelling.)\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (input, bit width matches Data Bits attribute)\nThe value to be routed to one of the outputs on the east edge.\nEast edge, variable number (outputs, bit width matches Data Bits\nattribute)\nThe outputs are numbered starting with 0 on the north. An output\nwill match the west input if its number matches the value currently\nreceived through the select input on the south; otherwise, its value\nwill be either all-zeroes or all-floating, depending on the value of\nthe Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines to which output on\nthe east edge to route the value received on the west edge.\nAttribute\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nAusrichtung\nThe direction of the component (specifying which side has the outputs).\nAuswahlleitungen\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the demultiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the demultiplexer.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 91,
    "title": "Dekoder",
    "url": "/de/html/libs/plexers/decoder.html",
    "text": "Dekoder\nDekoder\nBibliothek:\nAuswahlschaltungen\nEingef\u00fchrt:\n2.0 Beta 11\nAussehen:\nVerhalten\nEmits 1 on exactly one output; which output is 1 depends on the\ncurrent value received through the input on the south edge.\nPins (wenn das Bauelement nach Osten zeigt)\nEast edge, variable number (outputs, bit width 1)\nThe outputs are numbered starting with 0 on the north. Each output\nwill be 1 if its number matches the value currently received through the\nselect input on the south; otherwise, its value will be either zero or\nfloating, depending on the value of the Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which of the\noutputs is 1.\nAttribute\nWenn das Bauelement ausgew\u00e4hlt ist oder gerade hinzugef\u00fcgt wird, dann \u00e4ndern die Ziffern 1 bis 4 das Attribut\nAuswahlleitungen, und die Pfeiltasten \u00e4ndern das Attribut Ausrichtung.\nAusrichtung\nThe direction of the component (specifying which side has the outputs).\nAuswahlleitungen\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the decoder will be\n2selectBits.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 92,
    "title": "Priorit\u00e4tsenkoder",
    "url": "/de/html/libs/plexers/priencod.html",
    "text": "Priorit\u00e4tsenkoder\nPriorit\u00e4tsenkoder\nBibliothek:\nAuswahlschaltungen\nEingef\u00fchrt:\n2.3.0\nAussehen:\nVerhalten\nDas Bauelement hat eine Anzahl von Eing\u00e4ngen auf der westlichen Seite, der erste Eingang ist markiert mit\n0\nund die anderen sind fortlaufend nummeriert. Das Bauelement ermittelt alle Eing\u00e4nge, die auf 1 gesetzt sind und gibt den h\u00f6chsten auf diese Weise gefundenen Index weiter. Angenommen, die Eing\u00e4nge 0, 2, 5 und 6 sind alle auf 1, dann gibt der Priorit\u00e4tsenkoder den Wert 110 weiter. Wenn keiner der Eing\u00e4nge auf 1 gesetzt ist, dann ist das Bauelement deaktiviert und der Ausgang des Priorit\u00e4tsenkoders ist offen.\nDer Priorit\u00e4tsenkoder ist so konstruiert, da\u00df eine Reihe von Enkodern kaskadiert werden k\u00f6nnen, um weitere Eing\u00e4nge zur Verf\u00fcgung zu stellen. Insbesondere enth\u00e4lt das Bauelement einen Freigabeeingang und einen Freigabeausgang. Wenn der Freigabeeingang auf 0 gesetzt ist, ist das Bauelement deaktiviert und alle Ausg\u00e4nge sind offen. Der Freigabeausgang ist 1, wenn das Bauelement aktiviert ist, aber keiner der Eing\u00e4nge auf 1 gesetzt ist. Daher k\u00f6nnen Sie zwei Priorit\u00e4tsenkoder nehmen, und den Freigabeausgang des ersten mit dem Freigabeeingang des zweiten verbinden: wenn irgendeiner der indizierten EIng\u00e4nge des ersten Enkoders auf 1 gesetzt wird, dann wird der zweite Enkoder deaktiviert und dessen Ausg\u00e4nge bleiben offen. Wenn aber keiner der indizierten Eing\u00e4nge des ersten Enkoders auf 1 gesetzt ist, dann bleiben dessen Ausg\u00e4nge offen, der zweite Enkoder wird freigeschaltet, und dieser identifiziert den Eingang h\u00f6chster Priorit\u00e4t, der eine 1 aufweist.\nEin weiterer Ausgang des Enkoders ist 1, wenn der Enkoder aktiviert ist, und wenn eine 1 an einem der indizierten Eing\u00e4nge anliegt. Wenn mehrere Priorit\u00e4tsenkoder verkettet werden, dann kann dieser Ausgang benutzt werden anzuzeigen, welcher der Enkoder getriggert wurde.\nPins (wenn das Bauelement nach Osten zeigt)\nWestseite, variable Anzahl (Eing\u00e4nge, Bitbreite 1)\nEingangswerte, indiziert mit 0 an der oberen, westlichen Ecke der Seite.\nOstseite, oberer Pin (Ausgang, Bitbreite entspricht dem Attribut Auswahlleitungen)\nAusgang: der h\u00f6chste Index der Eing\u00e4nge, die auf 1 gesetzt sind - oder offen, wenn kein Eingang auf 1 ist, oder wenn das Bauelement \u00fcber den Freigabeeingang deaktivert wurde.\nOstseite, unterer Pin (Ausgang, Bitbreite 1)\nGruppenauswahl: 1 wenn das Bauelement aktiviert ist, und wenn mindestens einer der indizierten Eing\u00e4nge auf 1 gesetzt ist, ansonsten 0\nS\u00fcdseite (Eingang, Bitbreite 1)\nFreigabeeingang: das Bauelement ist deaktiviert, wenn dieser Eingang auf 0 gesetzt ist, ansonsten ist das Bauelement aktiviert.\nNordseite (Ausgang, Bitbreite 1)\nFreigabeausgang: 1 wenn dieses Bauelement aktiviert ist und keiner der indizierten Eing\u00e4nge auf 1 gesetzt ist, anderenfalls ist dieser Ausgang 0.\nAttribute\nWenn das Bauelement ausgew\u00e4hlt ist oder gerade hinzugef\u00fcgt wird, dann \u00e4ndern die Ziffern 1 bis 4 das Attribut\nAuswahlleitungen, und die Pfeiltasten \u00e4ndern das Attribut Ausrichtung.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nAuswahlleitungen\nDie Bitbreite des prim\u00e4ren Ausgangs Die Anzahl der indizierten Eing\u00e4nge des Priorit\u00e4tsenkoders ist 2Auswahlleitungen.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 93,
    "title": "Bit-W\u00e4hler",
    "url": "/de/html/libs/plexers/selector.html",
    "text": "Bit-W\u00e4hler\nBit-W\u00e4hler\nBibliothek:\nAuswahlschaltungen\nEingef\u00fchrt:\n2.0.5\nAussehen:\nVerhalten\nGiven an input of several bits, this will divide it into several\nequal-sized groups (starting from the lowest-order bit) and output\nthe group selected by the select input.\nFor example, if we have an eight-bit input 01010101, and we are to have\na three-bit output, then group 0 will be the lowest-order three bits 101,\ngroup 1 will be the next three bits, 010, and group 2 will be the next three\nbits 001. (Any bits beyond the top are filled in with 0.) The select\ninput will be a two-bit number that selects which of these three groups\nto output; if the select input is 3, then 000 will be the output.\nPins (wenn das Bauelement nach Osten zeigt)\nWest edge (input, bit width matches Data Bits attribute)\nData value from which bits should be selected for the output.\nEast edge (output, bit width matches Output Bits attribute)\nA group of bits from the data value, as selected by the select\ninput.\nSouth edge (input, bit width is quotient of Data Bits and Output Bits, rounded up)\nSelect input: Determines which of the bit groups should be routed\nto the output.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Output Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nAusrichtung\nDie Richtung des Bauelements (Lage des Ausgangs im Vergleich zum Eingang).\nData Bits\nThe bit width of the component's data input.\nOutput Bits\nThe bit width of the component's output.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 94,
    "title": "Arithmetikbibliothek",
    "url": "/de/html/libs/arith/index.html",
    "text": "Arithmetic Library\nArithmetikbibliothek\nThe Arithmetic library includes combinational\ncomponents that perform arithmetic operations on unsigned and\ntwo's-complement values.\nAddierer\nSubtrahierer\nMultiplizierer\nTeiler\nNegator\nKomparator\nBitschieber\nBit-Addierer\nBit-Finder"
  },
  {
    "id": 95,
    "title": "Addierer",
    "url": "/de/html/libs/arith/adder.html",
    "text": "Addierer\nAddierer\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 11\nAussehen:\nVerhalten\nThis component adds two values coming in via the west inputs and\noutputs the sum on the east output. The component is designed so that it\ncan be cascaded with other adders to provide add more bits than is\npossible with a single adder: The carry-in input provides a\none-bit value to be added into the sum also (if it is specified), and a\ncarry-out output provides a one-bit overflow value that can be fed to\nanother adder.\nIf either of the addends contains some floating bits or some error\nbits, then the component will perform a partial addition. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nOne of the two values to add.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe other of the two values to add.\nNorth edge, labeled c in (input, bit width 1)\nA carry value to add into the sum. If the value is unknown (i.e.,\nfloating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the sum of the two values\ncoming in the west edge, plus the cin\nbit.\nSouth edge, labeled c out (output, bit width 1)\nThe carry bit computed for the sum. If the values added together as\nunsigned values yield a result that fits into dataBits\nbits, then this bit will be 0; otherwise, it will be 1.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be added and of the result.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 96,
    "title": "Subtrahierer",
    "url": "/de/html/libs/arith/subtractor.html",
    "text": "Subtrahierer\nSubtrahierer\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 11\nAussehen:\nVerhalten\nThis component subtracts values coming in via the west inputs\n(the upper minus the lower) and outputs the difference on the east\noutput. The component is designed so that it can be cascaded with other\nsubtractors to provide subtract more bits than is possible with a single\nsubtractor: The borrow-in input provides a one-bit value to be borrowed\nout of the difference (if the borrow-in input is specified), and a\nborrow-out output indicates whether the component needs to borrow an\nupper-order bit to complete the subtraction without underflow (assuming\nunsigned subtraction).\nInternally, the subtractor simply performs a bitwise NOT on the\nsubtrahend, and add this to the minuend along with the NOT of the\nborrow-in input. (The minuend is the first operand (upper\ninput) to the subtraction, and the subtrahend is the second\n(lower input). I happen to like the antiquated terms.)\nIf either of the operands contains some floating bits or some error\nbits, then the component will perform a partial subtraction. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe minuend of the subtraction; that is, the number from which to\nsubtract.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe subtrahend of the subtraction; that is, the number to subtract\nfrom the minuend.\nNorth edge, labeled b in (input, bit width 1)\nIf 1, then 1 is borrowed out of the difference. If the value is\nunknown (i.e., floating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the difference of the two\nvalues coming in the west edge, minus the\nbin bit.\nSouth edge, labeled b out (output, bit width 1)\nThe borrow bit computed for the difference. If the values subtracted\nas unsigned values yield a negative value, then this bit will be 1;\notherwise, it will be 0.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be subtracted and of the result.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 97,
    "title": "Multiplizierer",
    "url": "/de/html/libs/arith/multiplier.html",
    "text": "Multiplizierer\nMultiplizierer\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 20\nAussehen:\nVerhalten\nThis component multiplies two values coming in via the west inputs\nand outputs the product on the east output. The component is designed so\nthat it can be cascaded with other multipliers to multiply a\nmultiplicand with more bits than is possible with a single multiplier:\nThe carry-in input provides a multi-bit value to be added into the\nproduct (if it is specified), and a carry-out output provides the upper\nhalf of the product result, which can be fed into another\nmultiplier.\nIf the multiplicand, the multiplier, or the carry-in input contain\nsome floating bits or some error bits, then the component will perform a\npartial multiplication. That is, it will compute as many low-order bits\nas possible. But above the floating or error bit, the result will have\nfloating or error bits. Note that if the carry-in input is completely\nfloating, then it will be assumed to be all-zeroes.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe multiplicand (that is, the first of the two numbers to\nmultiply).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe multiplier (that is, the second of the two numbers to multiply).\nNorth edge, labeled c in (input, bit width matches Data Bits attribute)\nA carry value to add into the product. If all bits of the value are\nunknown (i.e., floating), then they are assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the product of the two values\ncoming in the west edge, plus the cin\nvalue.\nSouth edge, labeled c out (output, bit width matches Data Bits attribute)\nThe upper dataBits bits of the product.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be multiplied and of the result.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 98,
    "title": "Teiler",
    "url": "/de/html/libs/arith/divider.html",
    "text": "Teiler\nTeiler\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 22\nAussehen:\nVerhalten\nThis component divides two values coming in via the west inputs and\noutputs the quotient on the east output. The component is designed so\nthat it can be cascaded with other dividers to provide support a\ndividend with more bits than\nis possible with a single divider: The upper input provides the\nupper dataBits bits of the dividend (if it is specified at\nall), and the rem bits provide the remainder, which can be\nfed as the upper input into another divider.\nIf the divisor is 0, then no division is performed (i.e., the divisor\nis assumed to be 1).\nThe divider essentially performs unsigned division. That is, the\nremainder will always be between 0 and divisor-1. The\nquotient will always be an integer so that\nquotient * divisor + remainder\n= dividend .\nIf, however, the quotient does not fit into\ndataBits bits, then only the lower dataBits bits\nwill be reported. The component does not provide any method for\naccessing the upper dataBits bits.\nIf either of the operands contains some floating bits or some error\nbits, then the component's outputs will be either entirely floating or\nentirely error values.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe lower dataBits bits of the dividend (that is, the\nfirst operand for the division).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe divisor (that is, the second operand for the division)\nNorth edge, labeled upper (input, bit width matches Data Bits attribute)\nThe upper dataBits bits of the dividend (that is, the\nfirst operand for the division).\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the quotient, as specified\nabove.\nSouth edge, labeled rem (output, bit width matches Data Bits attribute)\nThe remainder of the division. This value will always be between 0\nand divisor-1.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be divided and of the result.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 99,
    "title": "Negator",
    "url": "/de/html/libs/arith/negator.html",
    "text": "Negator\nNegator\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 22\nAussehen:\nVerhalten\nComputes the two's-complement negation of the input.\nThis negation\nis performed by maintaining all the lower-order bits up to the\nlowest-order 1, and complementing all bits above that.\nIf the value to be negated happens to be the least negative value,\nthen its negation (which cannot be represented in two's-complement\nform), is still the least negative value.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe value to negate.\nEast edge, labeled -x (output, bit width matches Data Bits attribute)\nThe negation of the input. If the input happens to be the least\nnegative value representable in dataBits bits, however, then\nthe output matches the input.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's input and output.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 100,
    "title": "Komparator",
    "url": "/de/html/libs/arith/comparator.html",
    "text": "Komparator\nKomparator\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.0 Beta 22\nAussehen:\nVerhalten\nCompares two values, either as unsigned values or as two's-complement\nvalues, depending on the Numeric Type attribute. Normally, one of the\noutputs will be 1, and the other two outputs will be 0.\nThe comparison is performed starting at the most significant bits in\neach number and descending downward in parallel until a location is\nfound where the two values disagree. If, however, an error value or\na floating value is encountered during this descent, then all outputs\nwill match that error or floating value.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe first of the two values to be compared.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe second of the two values to be compared.\nEast edge, labeled > (output, bit width 1)\n1 if the first input is greater than the second input, 0 if\nthe first input is less than or equal the second input.\nEast edge, labeled = (output, bit width 1)\n1 if the first input equals the second input, 0 if\nthe first input is not equal the second input.\nEast edge, labeled < (output, bit width 1)\n1 if the first input is less than the second input, 0 if\nthe first input is greater than or equal the second input.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's inputs and outputs.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 101,
    "title": "Bitschieber",
    "url": "/de/html/libs/arith/shifter.html",
    "text": "Bitschieber\nBitschieber\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.3.0\nAussehen:\nVerhalten\nThis component includes two inputs, data and dist, and\nit has one output, which is the result of shifting data by\ndist places. Both data and output have the same number of\nbits in them. The component supports the following shift types:\nLogical Left: All bits in data are shifted up dist places,\nwith the bottom dist places filled with 0's. For example,\n11001011 logically shifted left twice is 00101100. (The top two ones are lost.)\nLogical Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with 0's. For example,\n11001011 logically shifted right twice is 00110010. (The bottom two ones are\nlost.)\nArithmetic Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with repetitions of\nwhatever the uppermost bit in data. For example, 11001011\narithmetically shifted right twice is 11110010.\nRoll Left: All bits in data are shifted up dist\nplaces, with the top dist places wrapped around into the bottom.\nFor example, 11001011 rolled left twice is 00101111.\nRoll Right: All bits in data are shifted down dist\nplaces, with the bottom dist places wrapped around into the top.\nFor example, 11001011 rolled right twice is 11110010.\nNote that if dist contains any floating or error inputs, then\nthe output is composed entirely of error values, since there is no way to\nguess how far to shift the input.\nPins\nWest edge, north end (input, bit width matches the Data Bits attribute)\nThe value to be shifted.\nWest edge, south end (input, bit width is computed as below)\nThe number of bits by which to shift the data input.\nThis input should have as many bits as is the minimum number to indicate\nany shift distance from 0 up to one less than Data Bits; that is, it should\nbe the ceiling of the base-2 logarithm of Data Bits. For example, if Data Bits\nwere 8, this input would require 3 bits; but if it were 9, it would require\n4 bits.\nEast edge (output, bit width matches the Data Bits attribute)\nThe result of shifting the input value by the input distance.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the data input and of the output.\nShift Type\nOne of the five possible shift types as outlined above (Logical Left,\nLogical Right, Arithmetic Right, Roll Left, Roll Right).\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 102,
    "title": "Bit-Addierer",
    "url": "/de/html/libs/arith/bitadder.html",
    "text": "Bit-Addierer\nBit-Addierer\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.6.0\nAussehen:\nVerhalten\nThe component determines how many 1 bits are in its input(s) and emits the\ntotal number of 1 bits on its output. For example, given the 8-bit input 10011101,\nthe output would be 5, since there are five 1-bits in the input\n(the first, the last, and a string of three bits in the middle).\nIf any of the input bits are floating or error values, then the output will\ncontain error bits in the output corresponding to the range of possible outputs\ndepending on whether those floating/error values are counted as zeroes or ones.\nFor instance, if the 14-bit input is 111x10110x1101, then the output must be\nat least 9 (if the x's are interpreted as zeroes)\nand at most 11 (if they are interpreted as ones).\nThus, the output will be 10EE: The upper two bits will be 1 and 0 since all integers\nbetween 9 and 11 have 1 and 0 as their top two bits, but the lower two bits are EE\nsince integers between 9 and 11 vary within these bits.\nPins\nWest edge (inputs, bit width matches Data Bits attribute)\nThe inputs whose 1 bits are to be counted. The number of inputs is based\non the Number of Inputs attribute.\nEast edge (output, bit width computed as described below)\nThe number of input bits which are 1. The bit width of the output is the\nminimum number of bits to store the maximum possible value (which would be\nthe product of the Data Bits attribute and the Number of Inputs attribute).\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute and\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input(s).\nNumber of Inputs\nThe number of input values.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 103,
    "title": "Bit-Finder",
    "url": "/de/html/libs/arith/bitfinder.html",
    "text": "Bit-Finder\nBit-Finder\nBibliothek:\nArithmetic\nEingef\u00fchrt:\n2.6.1\nAussehen:\nVerhalten\nThe component takes a multi-bit input and determines the the index of a bit,\nwhere the index is computed by counting from 0 as the lowest-order bit.\nExactly which index it computes depends on the Type attribute, as illustrated\nby the examples in the below table for the 8-bit sample input 11010100.\nTypeOutput for 11010100\nLowest-order 12\nHighest-order 17\nLowest-order 00\nHighest-order 05\nFor the lowest-order 1, the output is 2 because if you index the bits\nstarting from 0 for the lowest-order bit, the first 1 you will find is\nat index 2. (The bits at indices 0 and 1 are both 0.)\nFor the highest-order 1, the output is 7 because the topmost 1 bit is at index 7\n(again counting from the lowest-order bit as 0).\nThe component's output on the south edge indicates whether the desired bit\nwas found at all. In the above examples involving the input 11010100,\nthe south output is 1 in all cases.\nBut if the input were 00000000 and the component is to find the\nlowest-order 1, then the south output would be 0 \u2014 and the output on the\nwest edge would be 0 as well.\nIf while searching for the desired value, a value that is neither 0 or 1 is\nfound (the bit could be floating or an error value),\nthen both outputs will consist entirely of error bits.\nNote that this occurs only if the problematic bit is encountered before finding\nthe desired bit: For the input x1010100, the output would still be 2 if\nthe lowest-order 1 is desired; but we would get error values if the component's\ntype indicates to search for the highest-order 1 or the highest-order 0, since\nthere is an erroneous bit in a higher-order bit than either the highest-order 0\nor the highest-order 1.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe multibit input that is to be searched for the desired bit.\nEast edge (output, bit width computed as described below)\nThe index of the desired bit, counting from 0 for the lowest-order bit.\nThe bit width is the\nminimum number of bits to store the maximum possible index, which is one\nless than the value of the Data Bits attribute.\nSouth edge (output, bit width 1)\n1 if the desired bit is found, 0 if all input bits are the inverse of the\ndesired bit, and the error value if a non-0, non-1 value is found before the\ndesired bit.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input.\nType\nIndicates which bit to search for \u2014 the lowest-order 0,\nthe highest-order 0, the lowest-order 1, or the highest-order 1.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 104,
    "title": "Speicherbibliothek",
    "url": "/de/html/libs/mem/index.html",
    "text": "Memory Library\nSpeicherbibliothek\nThe Memory library includes components that remember information.\nD/T/J-K/S-R Flip-Flop\nRegister\nZ\u00e4hler\nSchieberegister\nZufallsgenerator\nRAM\nROM"
  },
  {
    "id": 105,
    "title": "D/T/J-K/S-R Flip-Flop",
    "url": "/de/html/libs/mem/flipflops.html",
    "text": "D/T/J-K/S-R Flip-Flop\nD/T/J-K/S-R Flip-Flop\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nEach flip-flop stores a single bit of data, which is emitted through\nthe Q output on the east side. Normally, the value can be\ncontrolled via the inputs to the west side. In particular, the value\nchanges when the clock input, marked by a triangle on\neach flip-flop, rises from 0 to 1 (or otherwise as configured); on this rising\nedge, the value changes according to the table below.\nD Flip-Flop\nT Flip-Flop\nJ-K Flip-Flop\nS-R Flip-Flop\nDQ\n00\n11\nTQ\n0Q\n1Q'\nJKQ\n00\nQ\n01\n0\n10\n1\n11\nQ'\nSRQ\n00\nQ\n01\n0\n10\n1\n11\n??\nAnother way of describing the different behavior of the flip-flops\nis in English text.\nD Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop becomes the value of the D\ninput (Data) at that instant.\nT Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop either toggles or remains the same\ndepending on whether the T\ninput (Toggle) is 1 or 0.\nJ-K Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\ntoggles if the J and K inputs are both 1\nand the value remains the same if both are 0;\nif they are different, then the value becomes 1 if the J\n(Jump) input is 1 and 0 if the K (Kill)\ninput is 1.\nS-R Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\nremains unchanged if R and S are both 0,\nbecomes 0 if the R input (Reset) is 1, and\nbecomes 1 if the S input (Set) is 1.\nThe behavior in unspecified if both inputs are 1.\n(In Logisim, the value in the flip-flop remains unchanged.)\nBy default, the clock triggers on a rising edge \u2014 that is, when the\nclock input changes from 0 to 1. However, the\nTrigger attribute allows this to change to a falling edge (when the clock\ninput changes from 1 to 0), a high level (for the duration that the clock input\nis 1), or a low level (for the duration that the clock input is 0). The\nlevel-trigger options are unavailable for the T and J-K flip-flops, because\na flip-flop behaves unpredictably when told to toggle for an indeterminate\namount of time.\nPins\nWest edge, marked by triangle (input, bit width 1)\nClock input: At the instant that this input value switches from 0 to\n1 (the rising edge), the value will be updated according to the other\ninputs on the west edge.\nAs long as this remains 0 or 1, the other\ninputs on the west edge have no effect.\nWest edge, other labeled pin(s) (input(s), bit width 1)\nThese inputs control how the flip-flop's value changes during the\nrising edge of the clock. Their exact behavior depends on the\nflip-flop; the above tables summarize their behavior.\nEast edge, labeled Q, north end (output, bit width 1)\nOutputs the value currently stored by the flip-flop.\nEast edge, south end (output, bit width 1)\nOutputs the complement of the value currently stored by the\nflip-flop.\nSouth edge, east end (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the flip-flop's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nSouth edge, center end (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current bit\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, west end (input, bit width 1)\nAsynchronous set: When 1 or undefined, this input has no effect.\nWhen 1, the flip-flop's value is pinned to 1. This occurs asynchronously\n- that is, without regard to the current clock input value. As long as\nthis input is 1, the other inputs have no effect, except for the\nasynchronous reset input, which has priority.\nAttribute\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the flip-flop should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the flip-flop should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0. Note that the latter two options\nare unavailable for T and J-K flip-flops.\nLabel\nThe text within the label associated with the flip-flop.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nClicking a flip-flop using the Poke Tool toggles the bit stored in\nthe flip-flop, unless the asynchronous set/reset inputs currently\npin the flip-flop's value.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 106,
    "title": "Register",
    "url": "/de/html/libs/mem/register.html",
    "text": "Register\nRegister\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nA register stores a single multi-bit value, which is displayed in\nhexadecimal within its rectangle, and is emitted on its\nQ output. When the clock input\n(indicated by a triangle on the south edge) indicates so,\nthe value stored in the register changes to the value of the\nD input at that instant. Exactly when the clock input indicates\nfor this to happen is configured via the Trigger attribute.\nThe reset input resets the register's value to 0 (all\nzeroes) asynchronously; that is, as long as reset\nis 1, the value is pinned to 0, regardless of the clock input.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the register.\nWest edge, labeled D (input, bit width matches Data Bits attribute)\nData input: At the instant that the clock value rises from 0 to 1,\nthe register's value changes to the value of the D input at\nthat instant.\nWest edge, labeled en (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current value\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock input: At the instant that this input value rises from 0 to\n1 (the rising edge), the register's value will be updated to the value\nof the D input.\nSouth edge, labeled 0 (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the register's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in the register.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the register should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0.\nLabel\nThe text within the label associated with the register.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nClicking the register brings keyboard focus to the register\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the register.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 107,
    "title": "Z\u00e4hler",
    "url": "/de/html/libs/mem/counter.html",
    "text": "Z\u00e4hler\nZ\u00e4hler\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.3.0\nAussehen:\nVerhalten\nThe counter holds a single value, whose value is emitted on the output\nQ. Each time the clock input (diagrammed with a triangle on the\ncomponent's south edge) triggers according to its Trigger attribute,\nthe value in the counter may update based on\nthe two inputs on the component's west edge: The upper input is called\nload and the lower is called count, and they are\ninterpreted as follows.\nloadcounttrigger action\n0 or z0\nThe counter remains unchanged.\n0 or z1 or z\nThe counter increments.\n10\nThe counter loads the value found at the\nD input.\n11 or z\nThe counter decrements.\nThe range of counting can be configured using the Maximum\nValue attribute. When the counter reaches this value, the next\nincrement wraps the counter back to 0; and if it is at 0,\nthen a decrement will wrap the counter around back to its maximum value.\nIn addition to the output Q, the component also includes a\nsingle-bit output carry. This is 1 whenever the counter is at its\nmaximum and the load and count inputs indicate that the\ncomponent should increment on the next step - or when the counter is at 0\nand the load and count inputs indicate to decrement at\nthe next step.\nThe clear input resets the counter's value to 0 (all\nzeroes) asynchronously; that is, as long as the clr input\nis 1, the value is pinned to 0, regardless of the clock input.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the counter.\nOstseite, unterer Pin (Ausgang, Bitbreite 1)\nCarry: When load and count indicate to increment,\nthis output is 1 whenever the counter is at its maximum. When load\nand count indicate to decrement, this output is 1 whenever the\ncounter is at 0. At all other times, this output is 0.\nWest edge, top pin (input, bit width 1)\nLoad: When this is 1 while the count input is 0, the counter\nwill load the value found at the data input at the next clock\ntrigger - or, if the count input happens to be 1, the counter's\nvalue will decrement.\nWest edge, middle pin labeled D\n(input, bit with matches Data Bits attribute)\nData: When the clock triggers while load is 1\nand count is 0, the counter's value changes to the value found at\nthis input.\nWest edge, lower pin labeled ct (input, bit width 1)\nCount: When this is 1 or unconnected, the value in the counter increments\nwhenever the clock input is triggered - or it decrements if the load\ninput happens to also be 1.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the counter updates as indicated by the load and\ncount inputs.\nSouth edge, labeled 0 (input, bit width 1)\nClear: When 0 or undefined, this input has no effect.\nAs long as it is 1, the counter's value is asynchronously pinned to 0. This\noccurs asynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nMaximum Value\nThe maximum value, at which point the counter will set its carry output.\nAction On Overflow\nThe behavior when the counter attempts to increment beyond the maximum value\nor decrement beyond 0. Four possible actions are supported:\nWrap around\nThe next value is 0 (if incrementing - the maximum value if decrementing)\nStay at value\nThe counter's value remains at the maximum (or 0 if decrementing)\nContinue counting\nThe counter continues incrementing/decrementing, keeping the number of bits\nas provided by the Data Bits attribute\nLoad next value\nThe next value is loaded from the D input.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the counter should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nClicking the counter brings keyboard focus to the component\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the counter.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 108,
    "title": "Schieberegister",
    "url": "/de/html/libs/mem/shiftreg.html",
    "text": "Schieberegister\nSchieberegister\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.3.0\nAussehen:\nVerhalten\nThis register consists of several stages, where each clock may lead to\neach stage receiving the value in the previous stage, while a new value is\nloaded into the first stage. The component optionally also supports parallel\nloads and stores to all stages' values.\nThe clear input resets all stages to 0 (all\nzeroes) asynchronously; that is, as long as the clear input\nis 1, all values are pinned to 0, regardless of the clock input.\nPins\n* An asterisk marks pins that exist only when the Parallel Load attribute\nis enabled.\nWest edge, top pin (input, bit width 1)\nShift: When 1 or disconnected, all stages advance with the clock trigger;\nbut if it is 0, no advance takes place. This input is ignored if the Load\ninput is 1.\nWest edge, middle pin (input, bit width matches Data Bits attribute)\nData: When advancing the stages, the value found at this input is loaded\ninto the first stage.\nWest edge, bottom pin marked with triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the\nTrigger attribute, the component may advance the stages or load new values.\n*North edge, left pin (input, bit width 1)\nLoad: When this 1, the values found on the other north-edge pins are\nloaded into all stages at the next clock trigger. When 0 or disconnected, no\nload occurs.\n*North edge, other pins (input, bit width matches Data Bits attribute)\nData: These values are loaded into all stages when the clock is triggered\nwhile the load input is 1. The leftmost input corresponds to the\nyoungest stage.\nSouth edge, left pin (input, bit width 1)\nClear: When this is 1, all stages are asynchronously reset to 0, and all\nother inputs are ignored.\n*South edge, other pins (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in each stage, with the youngest stage\nreflected on the leftmost of the pins (next to the clear input).\nEast edge (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in the final (oldest) stage.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Stages attribute\nand Alt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in each stage.\nNumber of Stages\nThe number of stages included in the component.\nParallel Load\nIf yes, then the component includes inputs and outputs facilitating\nparallel access to all the stages' values.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nIf the Parallel Load attribute is no, or if the Data Bits attribute is more\nthan 4, then poking the register has no effect. Otherwise, clicking the\ncomponent will bring keyboard focus to the clicked stage\n(indicated by a red rectangle), and typing a hexadecimal digit will\nchange the value stored in that stage.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 109,
    "title": "Zufallsgenerator",
    "url": "/de/html/libs/mem/random.html",
    "text": "Zufallsgenerator\nZufallsgenerator\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.3.0\nAussehen:\nVerhalten\nThis component iterates through a pseudorandom sequence of numbers, which\nsteps forward to the following number in the sequence each time the clock is\ntriggered while the component is enabled. Technically speaking, the algorithm\nused to compute the pseudorandom sequence is a linear\ncongruential generator: Starting from a seed\nr0, the following number\nr1 is the number\nr1 =\n(25,214,903,917 r0 + 11)\nmod 248\nThe next value r2\nis computed from r1\nusing the same computation, and so forth. This sequence is of 48-bit numbers;\nthe value seen from the component is the low-order bits as configured\nby its Data Bits attribute, after first throwing out the lower 12 bits of\nthe current seed.\nBesides the clock input, the component also includes an enable\ninput, which leads the clock input to be ignored when enable is 0,\nand the reset input, which resets the component's value asynchronously\nto the initial seed r0.\nThe initial seed is user-configurable. If it is configured at 0 (which is\nthe default), then the seed is based on the current time; when instructed\nto reset through the reset input, the component starts with the\nsame seed based on the past time. It acquires a new seed only when the entire\nsimulation is reset.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the component.\nWest edge, top pin, labeled with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the component steps to the following number in its sequence.\nWest edge, bottom pin (input, bit width 1)\nEnable: The component is enabled when this input is disconnected or 1;\nbut if it is 0, then the clock input is ignored.\nS\u00fcdseite (Eingang, Bitbreite 1)\nReset: When this is 1, the pseudorandom sequence asynchronously resets to\nits initial seed.\nAttribute\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nSeed\nThe starting value used for the pseudorandom sequence. If this is 0\n(the default), then the starting value is based on the time that the current\nsimulation began.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the component should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 110,
    "title": "RAM",
    "url": "/de/html/libs/mem/ram.html",
    "text": "RAM\nRAM\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nThe RAM component, easily the most complex component in Logisim's\nbuilt-in libraries, stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). The circuit can load and\nstore values in RAM. Also, the user can modify individual values\ninteractively via the Poke Tool, or the user can modify the entire\ncontents via the Menu Tool.\nCurrent values are displayed in the component. Addresses displayed\nare listed in gray to the left of the display area. Inside, each value\nis listed using hexadecimal. The value at the currently selected address\nwill be displayed in inverse text (white on black).\nThe RAM component supports three different interfaces, depending on the\nData Interface attribute.\nOne synchronous load/store port (default)\nThe component includes a single port on its east side that serves for both\nloading and storing data. Which it performs depends on the input labeled\nld: 1 (or floating) indicates to load the data at the address\ndesignated on the component's west side, and 0 indicates to store the data\ngiven on the port. To transmit data into and out of the component, you will\nneed to use a Controlled Buffer component, as illustrated below.\nOne asynchronous load/store port\nThis is the same as above, except that there is no clock. The value\nfound on the data bus is stored into memory whenever the ld input is\n0. If, while the ld input is 0, the address or data changes, then an\nadditional store occurs. This option is meant to more closely approximate the\ninterface of many available random-access memories.\nSeparate load and store ports\nTwo data ports are provided - one on the west side for storing data,\nand another on the east side for loading data. This option removes the\nnecessity of dealing with the Controlled Buffer and so it is easier to\nuse.\nPins\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values in memory is currently being accessed by the\ncircuit.\nD on west edge (input, bit width matches Data Bit Width attribute)\nThis input is present only if \"separate load and store ports\" is selected\nfor the Data Interface attribute. When a store is requested (via the clock changing\nfrom 0 to 1 while sel and str are both 1 or floating), the\nvalue found at this port is stored into memory at the currently selected address.\nD on east edge (input/output or output, bit width matches Data Bit Width attribute)\nIf sel and ld are 1 or floating, then the RAM\ncomponent emits the value found at the currently selected address on this port.\nIf there is a single load/store port, the value read from this port is\nstored whenever a store is requested.\nstr on south edge (input, bit width 1)\nStore: This input is present only if \"separate load and store ports\" is selected\nfor the Data Interface attribute. When it is 1 or floating, a clock pulse will result\nin storing the data found on the west edge into memory (provided the\nsel input is also 1 or floating).\nsel on south edge (input, bit width 1)\nChip select: This input enables or disables the entire RAM module, based on\nwhether the value is 1/floating or 0. The input is meant primarily for\nsituations where you have multiple RAM units, only one of which would be\nenabled at any time.\ntriangle on south edge (input, bit width 1)\nClock input: This is absent when the Data Interface attribute's value is \"One\nasynchronous load/store port.\" In other circumstances, when ld is 0,\nand this input rises from 0 to 1 (and sel is 1/undefined and\nclr is 0), then the value at the currently selected address\nchanges to whatever value is\nat the D pin. As long as the clock input remains 0 or 1,\nthough, the D value will not be stored into memory.\nld on south edge (input, bit width 1)\nLoad: Selects whether the RAM should emit (on D)\nthe value at the current address (A). This output behavior\nis enabled if out is 1 or undefined; if out\nis 0, then no value is pushed onto D - but if there is a combined\nload/store port, stores will be enabled.\nclr on south edge (input, bit width 1)\nClear: When this is 1, all values\nin memory are pinned to 0, no matter what the other inputs are.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nRAM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nData Interface\nConfigures which of the three interfaces are used for communicating data\ninto and out of the component.\nVerhalten des Schaltwerkzeugs\nSee poking memory\nin the User's Guide.\nVerhalten des Textwerkzeugs\nKeines.\nMenu Tool Behavior\nSee pop-up menus and files\nin the User's Guide."
  },
  {
    "id": 111,
    "title": "ROM",
    "url": "/de/html/libs/mem/rom.html",
    "text": "ROM\nROM\nBibliothek:\nMemory\nEingef\u00fchrt:\n2.1.0\nAussehen:\nVerhalten\nThe ROM component stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). A circuit can access\nthe current values in ROM, but it cannot change them. The user can modify individual values\ninteractively via the Poke Tool, or the user can modify the entire\ncontents via the Menu Tool.\nUnlike the RAM component, the ROM component's current contents are\nstored as an attribute of the component. Thus, if a circuit containing\na ROM component is used twice, then both ROM components will hold the\nsame values. Also because of this behavior, the current ROM contents are\nstored in files created by Logisim.\nCurrent values are displayed in the component. Addresses displayed\nare listed in gray to the left of the display area. Inside, each value\nis listed using hexadecimal. The value at the currently selected address\nwill be displayed in inverse text (white on black).\nPins\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values are currently being accessed by the\ncircuit.\nD on east edge (input/output, bit width matches Data Bit Width attribute)\nOutputs the value at the currently selected address at the\nD pin if sel is 1 or floating. If sel\nis 0, then D will be floating.\nsel on south edge (input, bit width 1)\nIf you have just one ROM module, ignore this input.\nIf you have multiple ROM modules in parallel, you can use this input\nto enable or disable the entire ROM module, based on whether the value is\n1 or 0. In other words, when this is 0, no value is emitted on\nthe D output.\nAttribute\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nROM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nContents\nStores the contents of memory.\nVerhalten des Schaltwerkzeugs\nSee poking memory\nin the User's Guide.\nVerhalten des Textwerkzeugs\nKeines.\nMenu Tool Behavior\nSee pop-up menus and files\nin the User's Guide."
  },
  {
    "id": 112,
    "title": "Eingabe/Ausgabe-Bibliothek",
    "url": "/de/html/libs/io/index.html",
    "text": "Input/Output Library\nEingabe/Ausgabe-Bibliothek\nThe Input/Output library includes components that are meant to\ncorrespond to typical components found in electronics for interfacing\nwith a user.\nTaster\nJoystick\nTastatur\nLED\n7-Segmentanzeige\nHexadezimale Anzeige\nLED-Matrix\nTerminal"
  },
  {
    "id": 113,
    "title": "Taster",
    "url": "/de/html/libs/io/button.html",
    "text": "Taster\nTaster\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.1.3\nAussehen:\nVerhalten\nOutputs 0 normally; but when the user is pressing the\nthe button using the Poke Tool, the output is 1.\nPins\nA button has only one pin, a 1-bit output, which is 0 except when the\nuser is pressing the button using the Poke Tool, when it is 1.\nAttribute\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nAusrichtung\nThe location of the output pin relative to the component.\nColor\nThe color with which to display the button.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nVerhalten des Schaltwerkzeugs\nWhen the mouse button is pressed, the component's output will be 1.\nUpon releasing the mouse button, the output reverts back to 0.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 114,
    "title": "Joystick",
    "url": "/de/html/libs/io/joystick.html",
    "text": "Joystick\nJoystick\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.2.0\nAussehen:\nVerhalten\nThe user can drag the red knob within the rounded-square area, and the outputs\nupdate to indicate the knob's current x- and\ny-coordinates. This is meant to emulate the joysticks known from\nthe days of classical arcade games.\nPins\nWest edge, north pin (output, bit width matches Bit Width attribute)\nIndicates knob's x-coordinate, to be interpreted as an unsigned\ninteger whose value will never be 0. Thus, a value of 1 represents the far left,\nand the maximum value for the bit width indicates the far right. When the knob\nis at rest (in the center), the value has the bit pattern 10...00.\nWest edge, south pin (output, bit width matches Bit Width attribute)\nIndicates knob's y-coordinate, whose value ranges as with the\nx-coordinate pin. When the knob is pulled to the top, this output's\nvalue is 1, and when the knob is pulled to the bottom, the output is the\nmaximum value for the bit width selected.\nAttribute\nWhen the component is selected or being added,\nAlt-2 through Alt-5 alter its Bit Width attribute.\nBit Width\nThe number of bits used to indicate each of the knob's coordinates.\nColor\nThe knob's color as it is drawn on the screen.\nVerhalten des Schaltwerkzeugs\nPressing the mouse button while within the joystick area moves the knob to\nthat location and updates the outputs. Dragging the mouse continues to move\nthe knob and update the outputs, keeping the knob within the joystick's area.\nReleasing the mouse button reverts the knob back to its rest position.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 115,
    "title": "Tastatur",
    "url": "/de/html/libs/io/keyboard.html",
    "text": "Tastatur\nTastatur\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.2.0\nAussehen:\nVerhalten\nThis component allows the circuit to read keys typed from the keyboard -\nas long as the keys are representable in the 7-bit ASCII code.\nAfter clicking the component using the poke tool, the user can type characters,\nwhich accumulate in a buffer. At all times, the ASCII value for the leftmost\ncharacter in the buffer is sent out the rightmost output. When the clock input\nis triggered, the leftmost character disappears from the buffer and the new\nleftmost character is sent on the rightmost output.\nThe supported characters for the buffer include all the printable ASCII\ncharacters, as well as space, newline, backspace, and control-L. In addition,\nthe left-arrow and right-arrow keys move the cursor within the buffer, and the\ndelete key deletes the character to the right of the cursor (if any).\nThe component is asynchronous in the sense that when the buffer is empty and\nthe user types a character, that character is sent immediately as an output,\nwithout any wait for a clock pulse.\nPins\nWest edge, marked by a triangle (input, bit width 1)\nClock - when triggered while the read-enable pin isn't 0, the leftmost\ncharacter from the buffer is deleted,\nand the outputs are updated to reflect the buffer's new status.\nSouth edge, leftmost pin (input, bit width 1)\nRead Enable - when 1 (or floating or error), a clock edge will consume\nthe leftmost character from the buffer. The clock input is ignored when\nRead Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the buffer is emptied and does not accept further\ncharacters.\nSouth edge, second pin from right (output, bit width 1)\nAvailable - this is 1 when the buffer contains at least one character\nand 0 when the buffer is empty.\nSouth edge, rightmost pin (output, bit width 7)\nData - the 7-bit ASCII code for the leftmost character in the buffer,\nor 0 if the buffer is empty.\nAttribute\nBuffer Length\nThe number of characters that the buffer can hold at once.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the leftmost character is consumed (when enabled by the Read\nEnable input). If it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nVerhalten des Schaltwerkzeugs\nPressing the mouse button into the component gives keyboard focus to the\ncomponent, and a vertical-bar cursor will be displayed.\nEach character typed will then be inserted into the buffer, as long as the\nbuffer hasn't reached its capacity and the character is one of those that the\ncomponent supports: the printable characters within the 7-bit ASCII code, as\nwell as space, backspace, newline, and control-L. Additionally, the user may\ntype the left-arrow and right-arrow keys to change the location of the cursor\nwithin the buffer, and the user may type the delete key to delete the buffer\ncharacter (if any) just to the right of the cursor.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 116,
    "title": "LED",
    "url": "/de/html/libs/io/led.html",
    "text": "LED\nLED\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.1.3\nAussehen:\nVerhalten\nDisplays the value of its input by coloring the LED (as specified\nby its Color attribute) or not depending on whether the input is 1 or 0.\n(The LED component is basically redundant with an output pin, except\nfor a somewhat different appearance. Some users, though, thought it would\nbe nice to include.)\nPins\nA LED has only one pin, a 1-bit input which is used to determine whether\nto display the LED colored (when the input is 1) or darkened (when the input\nis anything else).\nAttribute\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nAusrichtung\nThe location of the input pin relative to the component.\nColor\nThe color to display when the input value is 1.\nActive On High?\nIf yes, then the LED is colored when the input is 1.\nIf no, it is colored when the input is 0.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the label associated with the component to be edited."
  },
  {
    "id": 117,
    "title": "7-Segmentanzeige",
    "url": "/de/html/libs/io/7seg.html",
    "text": "7-Segmentanzeige\n7-Segmentanzeige\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.1.3\nAussehen:\nVerhalten\nDisplays the values of its eight one-bit inputs. Segments are either\ncolored or light gray depending on the inputs. The correspondence is as\nfollows.\n(Manufacturers vary as to how they map inputs to segments; the\ncorrespondence used here is based on Texas Instruments'\nTIL321.)\nPins\nNorth edge, first from left (input, bit width 1)\nControls the middle horizontal segment.\nNorth edge, second from left (input, bit width 1)\nControls the upper vertical segment on the left side.\nNorth edge, third from left (input, bit width 1)\nControls the upper horizontal segment.\nNorth edge, fourth from left (input, bit width 1)\nControls the upper vertical segment on the right side.\nSouth edge, first from left (input, bit width 1)\nControls the lower vertical segment on the left side.\nSouth edge, second from left (input, bit width 1)\nControls the bottom horizontal segment.\nSouth edge, third from left (input, bit width 1)\nControls the lower vertical segment on the right side.\nSouth edge, fourth from left (input, bit width 1)\nControls the decimal point.\nAttribute\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nActive On High?\nIf yes, then the segments light when the corresponding input is 1.\nIf no, they light when the corresponding input is 0.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 118,
    "title": "Hexadezimale Anzeige",
    "url": "/de/html/libs/io/hexdig.html",
    "text": "Hexadezimale Anzeige\nHexadezimale Anzeige\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.2.0\nAussehen:\nVerhalten\nUsing a seven-segment display, shows the hexadecimal digit corresponding to\nthe four-bit input. If any of the inputs are not 0/1 (either floating or error),\nthen the display shows a dash ('-'). A separate one-bit input controls the\ndisplay of the decimal point.\nPins\nSouth edge, first from left (input, bit width 4)\nThis input is interpreted as an unsigned four-bit number, and the\ncorresponding hexadecimal digit is displayed. If any of the bits are floating\nor error, then a dash ('-') is displayed.\nSouth edge, second from left (input, bit width 1)\nControls the decimal point. If this is left unconnected, the decimal point\nremains off.\nAttribute\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 119,
    "title": "LED-Matrix",
    "url": "/de/html/libs/io/dotmat.html",
    "text": "LED-Matrix\nLED-Matrix\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.2.0\nAussehen:\nVerhalten\nDisplays a small grid of pixels, whose values are determined by the current\ninputs. The grid can have up to 32 rows and 32 columns.\nPins\nThe interface to the component varies depending on the value of the\nInput Format attribute. It has three possible values.\nColumns\nThe inputs are lined along the component's south edge, with one\nmultibit input for each column of the matrix. Each input has as many bits\nas there are rows in the matrix, with the low-order bit corresponding to the\nsouthmost pixel in the column. A 1 indicates to light the corresponding pixel,\nwhile a 0 indicates to keep the pixel dim. If any of the bits for a column are\neither floating or error values, then all pixels in the column are lit.\nRows\nThe inputs are lined along the component's west edge, with one multibit\ninput for each row of the matrix. Each input has as many bits as there are\ncolumns in the matrix, with the low-order bit corresponding to the rightmost\npixel in the row. As with the Columns format, a 1 indicates to light the\ncorresponding pixel, and a 0 indicates to keep the pixel dim. If any bits for\na row are floating or error values, then all pixels in the row are lit.\nSelect Rows/Columns\nThere are two inputs on the component's west edge. The upper multibit\ninput has as many bits as there are columns in the matrix, with the low-order\nbit corresponding to the rightmost column. The lower multibit input has as\nmany bits as there are rows in the matrix, with the low-order bit corresponding\nto the bottom row. If any bits in either input are floating or error\nvalues, all pixels in the matrix are lit. Normally, though, a pixel at a\nparticular row-column location is lit if the corresponding column bit in the\nupper input is 1 and the corresponding row bit in the lower input is 1.\nFor example, for a 5x7 matrix, if the first input is 01010 and the second is\n0111010, then the second and fourth columns are lit for the second, third,\nfourth, and sixth rows; the result appears to be a pair of exclamation points.\n(This input format may seem unintuitive, but LED matrixes are sold commercially\nwith exactly this interface. Lite-On sells such components, for example.)\nAttribute\nInput Format (read-only after component is created)\nSelects how the pins correspond to pixels, as outlined above.\nMatrix Columns\nSelects how many columns are in the matrix, which may range from 1 up to\n32.\nMatrix Rows\nSelects how many rows are in the matrix, which may range from 1 up to\n32.\nOn Color\nSelects the color of a pixel when it is lit.\nOff Color\nSelects the color of a pixel when it is dim.\nLight Persistence\nWhen this is other than 0, a pixel that is lit remains lit\nfor the given number of clock ticks after the component's inputs indicate\nthat the pixel should become dim.\nDot Shape\nThe square option means that each pixel is drawn as a 10x10 square, filling\nthe component with no gaps between pixels. The circle option means that each\npixel is drawn as a diameter-8 circle, with gaps between each circle. The circle\noption is more difficult to interpret, but it more closely approximates the\noff-the-shelf LED matrix components.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 120,
    "title": "Terminal",
    "url": "/de/html/libs/io/tty.html",
    "text": "Terminal\nTerminal\nBibliothek:\nInput/Output\nEingef\u00fchrt:\n2.2.0\nAussehen:\nVerhalten\nThis component implements a very simple dumb terminal. It receives a sequence\nof ASCII codes and displays each printable character. When the current row\nbecomes full, the cursor moves to the following line, possibly scrolling all\ncurrent rows up if the cursor was already in the bottom row. The only supported\ncontrol sequences are: backspace (ASCII 8), which deletes the last character in\nthe final row, unless the final row is already empty; newline (ASCII 10), which\nmoves the cursor to the beginning of the following line, scrolling if necessary;\nand form-feed (ASCII 12, typed as control-L), which clears the screen.\nPins\nWest edge, upper pin (input, bit width 7)\nData - this is the ASCII value of the next character to be entered into\nthe terminal.\nWest edge, lower pin marked by triangle (input, bit width 1)\nClock - when triggered while the write-enable pin isn't 0, the\ncurrent ASCII value on the Data input is processed by the terminal.\nSouth edge, leftmost pin (input, bit width 1)\nWrite Enable - when 1 (or floating or error), a clock edge will result\nin processing a new character from the data input. The clock and data inputs are\nignored when Write Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the terminal is cleared of all data, and all other inputs\nare ignored.\nAttribute\nRows\nThe number of rows displayed in the terminal.\nColumns\nThe maximum number of characters displayed in each row of terminal.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the data input is processed (when enabled by the write-enable\nand clear inputs).\nIf it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nColor\nThe color with which to draw the text appearing in the terminal.\nBackground\nThe color with which to draw the terminal's background.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nKeines."
  },
  {
    "id": 121,
    "title": "Basisbibliothek",
    "url": "/de/html/libs/base/index.html",
    "text": "Base Library\nBasisbibliothek\nThe Base library includes general-purpose\ntools, as well as components whose behavior in a circuit is\ndistinguished from other components (that is, they are treated\nunusually by Logisim's propagation engine).\nSchaltwerkzeug\nBearbeitungswerkzeug\nAuswahlwerkzeug\nVerbindungswerkzeug\nTextwerkzeug\nMen\u00fcwerkzeug\nVerteiler\nPin\nTestpunkt\nTunnel\nPull Resistor\nTakt\nBit-Erweiterung\nLabel"
  },
  {
    "id": 122,
    "title": "Schaltwerkzeug",
    "url": "/de/html/libs/base/poke.html",
    "text": "Schaltwerkzeug\nSchaltwerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nVerhalten\nThe Poke Tool is for manipulating the current values associated with\ncomponents. The precise behavior of the Poke Tool varies depending on\nwhich component is clicked; this behavior is documented in the `Poke\nTool Behavior' section of each individual component.\nThe following components all have support for the Poke Tool.\nBasisbibliothek\nPin\nClock\nSpeicherbibliothek\nD/T/J-K/S-R Flip-Flop\nRegister\nCounter\nShift Register\nRAM\nROM\nEingabe/Ausgabe-Bibliothek\nButton\nJoystick\nKeyboard\nAltlasten\nLogisim 1.0 D/J-K Flip-Flop\nLogisim 1.0 8-Bit Register\nAlso, clicking a wire segment using the Poke tool displays the value\ncurrently carried by the wire, as described on the Wiring Tool's page.\nAttribute\nKeines. Clicking on a component supporting the Poke Tool, though, will display that component's attributes."
  },
  {
    "id": 123,
    "title": "Bearbeitungswerkzeug",
    "url": "/de/html/libs/base/edit.html",
    "text": "Bearbeitungswerkzeug\nBearbeitungswerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.3.0\nVerhalten\nThe Edit tool allows the user to rearrange existing components and to add\nwires. Exactly what the tool does depends on where the user presses the mouse\non the canvas.\nWhen the mouse is over a wiring point for an existing component,\nor if it is atop a current wire, the Edit Tool will display a small green circle\naround the mouse's location. Pressing the button there initiates the addition of\na new wire. But if the user doesn't drag the mouse far enough to initiate a\nwire before releasing the button, the press is treated as a mouse click, and so\nthe wire is simply added into the current selection.\nThe bit width of an added wire is inferred from the components to which it\nis connected. If it is not attached to any components, the wire will be drawn\ngray to indicate that its bit width is unknown; if the components at the\nlocations that the wire helps to connect disagree on the bit width, then the\nwire will be drawn orange to indicate the conflict, and the wire will in fact\nrefuse to carry any values at all until the user resolves the conflict.\nAll wires in Logisim are either horizontal or vertical, never diagonal.\nWires are non-directional; that is, they carry values from\neither endpoint to the other. Indeed, a wire can carry values\nin both directions simultaneously: In the below example, a bit flows from the\nupper input at left through the center wire, then it circles back through the\ncenter wire, and then it circles forward again through the center wire before\nreaching the output at lower right.\nA single drag of the mouse can create multiple wire segments. The\nprecise process is a little confusing in its description; but it works\nquite intuitively in practice: If you request a particular wire segment\nusing the Wiring Tool, that segment will be split apart wherever it hits\na pin for an existing component, or wherever it hits the endpoint of an\nexisting wire segment. Also, if an endpoint of any of the new wire\nsegments hit somewhere in the middle of an existing wire, then that wire\nwill be split into multiple segments itself.\nYou can also shorten or delete an existing wire segment by initiating a drag\nat the terminus of the segment and then drawing backwards across the segment.\nDuring the drag, the shortening is indicated by drawing a white line over of the\nportion of the wire that will be removed.\nSome components draw short stubs to which wires can connect, such as the\nOR gate and controlled buffer. Logisim will\nsilently correct attempts to create wires that slightly overshoot the\nstub's end.\nIf, however, the user presses the Alt key at a point in the middle of\nthe wire, then the green circle will disappear. A mouse press selects the wire,\nand a mouse drag moves it.\nPressing the mouse button while it is within a currently selected\ncomponent begins a drag moving all elements of the selection.\nBy default, Logisim will compute a way to add new wires\nso that no existing connections are lost during the move.\n(Sometimes it will delete or shorten existing wires.)\nIf you're performing a move where you do not want these changes to be made,\nyou can press the shift key during the move.\nIf you want to disable this behavior entirely,\ngo to Project > Options, select the Canvas tab,\nand uncheck the Keep Connections When Moving box;\nin this case, the connections are computed only when the shift key is down.\nDragging a selection can lead to unexpected behavior from wires: If\nyou drag a selection including some wires on top of some other wires,\nall wires are merged, and the merged wires are placed into the\nselection.\nAs a result, if you drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior\nis necessary to keep with the intuitive behavior of wires in Logisim, where\nwires never overlap. And\nit does not normally constitute a major problem: Logisim will draw the\nfull selection in the midst of dropping, and you should not drop it\nuntil you are sure it is in the correct location.\nPressing the mouse within an unselected component (but not at one of\nthe component's wiring points) drops all components from the current selection\nand selects instead the component(s) containing the clicked location.\nShift-clicking the mouse within a component toggles that component's\npresence within the selection. If multiple components include the same\nlocation, all components' presence will be toggled.\nDragging the mouse starting at a location not contained within any\ncomponents drops all components from the current selection and\ninitiates a rectangular selection.\nAll component(s) contained by the rectangle will be placed into the\nselection.\nShift-dragging the mouse starting at a location not contained\nwithin any components initiates a rectangular selection.\nThe presence in the selection of all component(s) contained by the\nrectangle will be toggled.\nHowever, if the Alt key is pressed at a location not contained within\nany components, this initiates the addition of a new wire. A small green circle\nis drawn in such a circumstance to indicate this.\nAfter selecting the desired items in the selection, you can of course\ncut/copy/paste/delete/duplicate all the items via the\nEdit menu.\nSome keys have an effect with the Edit Tool.\nThe arrow keys change the Facing attribute for all components in the\nselection that have such an attribute.\nThe Delete and Backspace keys will delete everything in the selection\nfrom the circuit.\nThe Insert and MenuKey-D keys will create a duplicate of the currently\nselected components.\nLogisim's behavior when duplicating a selection or pasting the clipboard into\na circuit is somewhat peculiar: It will not immediately place the components into the\ncircuit; instead, the selection will be a collection of \"ghosts,\" which\nwill be dropped into the circuit as soon as they are either dragged to\nanother location or removed from the selection. (This peculiar behavior\nis necessary because pasting will otherwise merge the wires of the\nselection into the current circuit at once, and the wires there\npreviously will be dragged with the pasted clipboard if the user wants\nto move the pasted components somewhere else.)\nAttribute\nKeines. Selecting a component, though, will display its attributes. With multiple components selected, attributes shared by all are shown, blank if they have different values and otherwise with the value they all have in common. (Wires are ignored if there are any non-wires in the selection.) Changes to the attribute value affect all selected components."
  },
  {
    "id": 124,
    "title": "Auswahlwerkzeug",
    "url": "/de/html/libs/base/select.html",
    "text": "Auswahlwerkzeug\nAuswahlwerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nVerhalten\nAllows individual components to be placed into the current selection.\nThere are a number of actions possible with this tool.\nPressing the mouse button while it is within a currently selected\ncomponent begins a drag moving all components of the selection.\nBy default, Logisim will compute a way to add new wires\nso that no existing connections are lost during the move.\n(Sometimes it will delete or shorten existing wires.)\nIf you're performing a move where you do not want these changes to be made,\nyou can press the shift key during the move.\nIf you want to disable this behavior entirely,\ngo to Project > Options, select the Canvas tab,\nand uncheck the Keep Connections When Moving box;\nin this case, the connections are computed only when the shift key is down.\nDragging a selection can lead to unexpected behavior from wires: If\nyou drag a selection including some wires on top of some other wires,\nall wires are merged, and the merged wires are placed into the\nselection.\nAs a result, if you drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior\nis necessary to keep with the expected behavior of wires in Logisim. And\nit does not normally constitute a major problem: Logisim will draw the\nfull selection in the midst of dropping, and you should not drop it\nuntil you are sure it is in the correct location.\nOtherwise, clicking the mouse within a component drops all\ncomponents from the current selection and selects instead the\ncomponent(s) containing the clicked location.\nShift-clicking the mouse within a component toggles that component's\npresence within the selection. If multiple components include the same\nlocation, all components' presence will be toggled. None of this will\nhappen, though, if shift-clicking is mapped to another tool instead (via\nthe project options window's Mouse\ntab).\nDragging the mouse starting at a location not contained within any\ncomponents drops all components from the current selection and\ninitiates a rectangular selection.\nAll component(s) contained by the rectangle will be placed into the\nselection.\nShift-dragging the mouse starting at a location not contained\nwithin any components initiates a rectangular selection.\nThe presence in the selection of all component(s) contained by the\nrectangle will be toggled. This will not happen, though, if\nshift-clicking is mapped to another tool instead.\nAfter selecting the desired items in the selection, you can of course\ncut/copy/paste/delete all the items via the Edit menu.\nLogisim's behavior when pasting the clipboard into a circuit is\nsomewhat peculiar: It will not immediately place the components into the\ncircuit; instead, the selection will be a collection of \"ghosts,\" which\nwill be dropped into the circuit as soon as they are either dragged to\nanother location or removed from the selection. (This peculiar behavior\nis necessary because pasting will otherwise merge the wires of the\nselection into the current circuit at once, and the wires there\npreviously will be dragged with the pasted clipboard if the user wants\nto move the pasted components somewhere else.)\nAttribute\nKeines. Selecting a component, though, will display its attributes. With multiple components selected, attributes shared by all are shown, blank if they have different values and otherwise with the value they all have in common. (Wires are ignored if there are any non-wires in the selection.) Changes to the attribute value affect all selected components."
  },
  {
    "id": 125,
    "title": "Verbindungswerkzeug",
    "url": "/de/html/libs/base/wiring.html",
    "text": "Verbindungswerkzeug\nVerbindungswerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nVerhalten\nThe wiring tool is the tool for creating wire segments that carry\nvalues from one endpoint to another.\nThe bit width of these values can\nbe anything; exactly which bit width is automatically inferred from the\ncomponents to which the wires are ultimately attached.\nIf it is not\nattached to any components, the wire will be drawn gray to indicate that\nits bit width is unknown; if the components at the locations that the\nwire helps to connect disagree on the bit width, then the wire will be\ndrawn orange to indicate the conflict, and the wire will in fact refuse\nto carry any values at all until the user resolves the conflict.\nA single drag of the mouse can create multiple wire segments. The\nprecise process is a little confusing in its description; but it works\nquite intuitively in practice: If you request a particular wire segment\nusing the Wiring Tool, that segment will be split apart wherever it hits\na pin for an existing component, or wherever it hits the endpoint of an\nexisting wire segment. Also, if an endpoint of any of the new wire\nsegments hit somewhere in the middle of an existing wire, then that wire\nwill be split into multiple segments itself.\nFor some components that draw short stubs to which wires can connect\n(such as an OR gate or a controlled buffer), Logisim will\nsilently correct attempts to create wires that slightly overshoot the\nstub's end.\nYou can also shorten an existing wire segment using the Wiring Tool,\nusing a drag that starts or ends at a terminus of the segment, and that\noverlaps the existing segment.\nAll wires in Logisim are either horizontal or vertical.\nWires are also non-directional; that is, they carry values from\neither endpoint to the other. Indeed, a wire can carry values\nin both directions simultaneously; the center wire in the below example\nis doing this.\nAttribute\nThe wiring tool does not itself have attributes, but the wires that\nit creates do.\nDirection\nIndicates whether the wire is horizontal or vertical.\nThe value of this attribute cannot be changed.\nLength\nIndicates how many pixels long the wire is.\nThe value of this attribute cannot be changed.\nVerhalten des Schaltwerkzeugs\nWhen you click an existing wire segment using the Poke Tool, Logisim\ndisplays the current value traveling through that wire.\nThe behavior is particularly useful for multi-bit wires, whose black\ncolor provide no visual feedback about what value the wire is\ncarrying.\nFor multi-bit values, you can configure exactly how the value\nis displayed (in binary, decimal, or hexadecimal, for example) using\nthe Layout\npane of the Logisim Preferences dialog box."
  },
  {
    "id": 126,
    "title": "Textwerkzeug",
    "url": "/de/html/libs/base/text.html",
    "text": "Textwerkzeug\nTextwerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nVerhalten\nThe text tool allows you to create and edit labels associated with\ncomponents. Which components support labels are indicated in the 'Text\nTool Behavior' section of their documentation. As of the current\nrelease, the following components in the built-in libraries support labels.\nBasisbibliothek\nPin\nClock\nLabel\nProbe\nSpeicherbibliothek\nD/T/JK/SR Flip-Flop\nRegister\nCounter\nShift Register\nRandom\nEingabe/Ausgabe-Bibliothek\nButton\nLED\nFor components that can take a label but have none assigned to it currently,\nyou can click anywhere within the component to add a label. If there is already\na label, you need to click within the label. If you click at a point where there\nis not currently a label to be edited, Logisim will initiate the addition of a\nnew Label component.\nIn the current version of Logisim, text editing features are\nstill fairly primitive.\nSelections of a region of text within a label is impossible.\nThere is no way to insert a line break into a label.\nAttribute\nThe attributes for the tool are the same as for the label component. These attributes have no effect\nwhen editing the label on an existing component, but they are imparted\nto any labels created using the text tool.\nClicking on a component supporting the Text Tool will\ndisplay that component's attributes."
  },
  {
    "id": 127,
    "title": "Men\u00fcwerkzeug",
    "url": "/de/html/libs/base/menu.html",
    "text": "Men\u00fcwerkzeug\nMen\u00fcwerkzeug\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nVerhalten\nThe menu tool permits the user to pull up a pop-up menu for\ncomponents that already exist. By default, right-clicking or\ncontrol-clicking a component will bring up this pop-up menu; however, the Mouse tab of the project options allows a user to\nconfigure the mouse buttons to work differently.\nThe pop-up menu for most components has two items.\nDelete: Removes the component from the circuit.\nShow Attributes: Places the component's attributes into the\nwindow's attribute table, so that the attribute values can be viewed and\nchanged.\nFor some components, however, the menu has additional items.\nSubcircuits (that is, instances of using one circuit as a \"black box\"\nwithin another) are one example of this: In addition to the above two\nitems, the pop-up menu includes another item.\nView XXX: Changes the circuit layout being viewed and\nedited to be the subcircuit's layout instead. The values seen in the\nlayout will be part of the same hierarchy as those of the supercircuit.\n(See the\n`Debugging subcircuits'\nsection of the User's Guide.)\nOther components may extend the pop-up menu also.\nIn the built-in libraries of the current version of Logisim, the only\nsuch components are RAM and\nROM.\nAttribute\nKeines."
  },
  {
    "id": 128,
    "title": "Text",
    "url": "/de/html/libs/base/label.html",
    "text": "Label\nLabel\nBibliothek:\nBase\nEingef\u00fchrt:\n2.0 Beta 1\nAussehen:\nVerhalten\nThis is a simple text label that can be placed anywhere in the\ncircuit. It does not interact with values traveling through the circuit\nin any way, except inasmuch as it will be visible when the circuit is\ndrawn.\nIn contrast to all other components in the current built-in\nlibraries, label components can be placed anywhere on the canvas;\nthey do not snap to the grid.\nPins\nKeines.\nAttribute\nText\nThe text appearing in the label. This value can be edited in the\nattribute table or, using the text tool, on the canvas.\nFont\nThe font to use when drawing the label.\nHorizontal Alignment\nThe horizontal positioning technique for the text relative to the label's official location\n(where the mouse was clicked in creating the label).\n\"Left\"\nmeans that the text should be drawn so that its left edge\nis at the location; \"right\" means that the text should be\ndrawn so that its right edge is at the location; and \"center\" means that\nthe text should be drawn so that its center (horizontally) is at the\nlocation.\nVertical Alignment\nThe vertical positioning technique for the text relative to the\nlabel's official location (where the mouse was clicked in creating the\nlabel). \"Base\" means that the baseline should intersect the location;\n\"Top\" means that the text's top should intersect the location; \"Bottom\"\nmeans that the text's bottom should intersect the location; and \"Center\"\nmeans that the text should be centered (vertically) at the location.\nThe text's top and bottom is computed based on the font's\nstandard ascent and descent values; thus, even if the actual text\ncontains no tall letters (such as b) or descending letters\n(such as g), it is assumed to contain such letters for the\npurposes of vertical positioning.\nVerhalten des Schaltwerkzeugs\nKeines.\nVerhalten des Textwerkzeugs\nAllows the text appearing within the label to be edited."
  }
]
