[
  {
    "id": 1,
    "title": "Logisim References",
    "url": "/en/html/guide/index.html",
    "text": "The Guide to Being a Logisim User\nThe Guide to Being a Logisim User\nLogisim is an educational tool for designing and simulating digital\nlogic circuits. With its simple toolbar interface and simulation of\ncircuits as they are built, it is simple enough to facilitate learning\nthe most basic concepts related to logic circuits.\nWith the capacity\nto build larger circuits from smaller subcircuits, and to draw bundles\nof wires with a single mouse drag, Logisim can be used (and is used)\nto design and simulate entire CPUs for educational purposes.\nStudents at colleges and universities around the world use\nLogisim for a variety of purposes, including:\nA module in general-education computer science surveys\nA unit in sophomore-level computer organization courses\nOver a full semester in upper-division computer architecture courses\nThe Guide to Being a Logisim User, which you are reading\nnow, is the official reference for Logisim's features.\nIts first part\nis a sequence of sections introducing the major parts of Logisim. These\nsections are written so that they can be read \"cover to cover\"\nto learn about all of the most important features of Logisim.\nBeginner's tutorial\nLibraries and attributes\nSubcircuits\nWire bundles\nCombinational analysis\nHDL components and FPGA synthesis\nThe remaining sections are a motley bunch of reference\nmaterials and explanations of some of the lesser corners\nof Logisim.\nMenu reference\nMemory components\nLogging and test vectors\nCommand-line verification\nApplication preferences\nProject options\nValue propagation\nHDL IP\nJAR libraries\nAbout the program"
  },
  {
    "id": 2,
    "title": "Guide to Being a Logisim User",
    "url": "/en/html/guide/index.html",
    "text": "The Guide to Being a Logisim User\nThe Guide to Being a Logisim User\nLogisim is an educational tool for designing and simulating digital\nlogic circuits. With its simple toolbar interface and simulation of\ncircuits as they are built, it is simple enough to facilitate learning\nthe most basic concepts related to logic circuits.\nWith the capacity\nto build larger circuits from smaller subcircuits, and to draw bundles\nof wires with a single mouse drag, Logisim can be used (and is used)\nto design and simulate entire CPUs for educational purposes.\nStudents at colleges and universities around the world use\nLogisim for a variety of purposes, including:\nA module in general-education computer science surveys\nA unit in sophomore-level computer organization courses\nOver a full semester in upper-division computer architecture courses\nThe Guide to Being a Logisim User, which you are reading\nnow, is the official reference for Logisim's features.\nIts first part\nis a sequence of sections introducing the major parts of Logisim. These\nsections are written so that they can be read \"cover to cover\"\nto learn about all of the most important features of Logisim.\nBeginner's tutorial\nLibraries and attributes\nSubcircuits\nWire bundles\nCombinational analysis\nHDL components and FPGA synthesis\nThe remaining sections are a motley bunch of reference\nmaterials and explanations of some of the lesser corners\nof Logisim.\nMenu reference\nMemory components\nLogging and test vectors\nCommand-line verification\nApplication preferences\nProject options\nValue propagation\nHDL IP\nJAR libraries\nAbout the program"
  },
  {
    "id": 3,
    "title": "Beginner's tutorial",
    "url": "/en/html/guide/tutorial/index.html",
    "text": "Beginner's tutorial\nBeginner's tutorial\nWelcome to Logisim!\nLogisim allows you to design and simulate digital circuits. It\nis intended as an educational tool, to help you learn how circuits\nwork.\nTo practice using Logisim, let's build a XOR circuit -\nthat is, a circuit that takes two inputs (which we'll call x and\ny) and outputs 0 if the inputs\nare the same and 1 if they are different.\nThe following truth table illustrates.\nWe might design such a circuit on paper.\nBut just because it's on paper doesn't mean it's right. To verify our\nwork, we'll draw it in Logisim and test it. As an added bonus, we'll get\na circuit that's looks nicer than what you probably would draw by hand.\nStep 0: Orienting yourself\nStep 1: Adding gates\nStep 2: Adding wires\nStep 3: Adding text\nStep 4: Testing your circuit\nEnjoy your circuit-building!"
  },
  {
    "id": 4,
    "title": "Step 0: Orienting yourself",
    "url": "/en/html/guide/tutorial/tutor-orient.html",
    "text": "Tutorial: Orienting yourself\nStep 0: Orienting yourself\nWhen you start Logisim, you'll see a window similar to the following.\nSome of the details may be slightly different since you're likely using a\ndifferent system than mine.\nAll Logisim is divided into three parts, called the explorer\npane, the attribute table, and the\ncanvas. Above these parts are\nthe menu bar and the toolbar.\nWe can quickly dispose of the explorer pane and the attribute\ntable: We won't be examining them in this tutorial, and you can\njust ignore them. Also, the menu bar is self-explanatory.\nThat leaves the toolbar and the canvas. The canvas is where you'll\ndraw your circuit; and the toolbar contains the tools that you'll use to\naccomplish this."
  },
  {
    "id": 5,
    "title": "Step 1: Adding gates",
    "url": "/en/html/guide/tutorial/tutor-gates.html",
    "text": "Tutorial: Adding gates\nStep 1: Adding gates\nRecall that we're trying to build the following circuit in Logisim.\nI suggest building a circuit by inserting the gates first as a sort of\nskeleton and then connecting them with wires later. The first thing we'll do\nis to add the two AND gates. Click on the AND tool in the toolbar\n(, the\nnext-to-last tool listed).\nThen click in the editing area where\nyou want the first AND gate to go. Be sure to leave plenty of room\nfor stuff on the left. Then click the AND tool again and place the second\nAND gate below it.\nNotice the five dots on the left side of the AND gate. These are spots\nwhere wires can be attached. It happens that we'll just use two of them\nfor our XOR circuit; but for other circuits, you may find that having\nmore than two wires going to an AND gate is useful.\nNow add the other gates.\nFirst click on the OR tool\n();\nthen click where you want it. And place the two NOT gates into the canvas\nusing the NOT tool\n().\nI left a little space between the NOT gates and the AND gates; if you\nwant to, though, you can put them up against each other and save\nyourself the effort of connecting them with a wire later.\nNow we want to add the two inputs x and y into\nthe diagram. Select the Input tool\n(),\nand place the pins down.\nYou should also place an output pin next to the OR gate's output using\nthe Output tool\n().\n(Again, I'm leaving a bit of space between the OR gate and the output\npin, but you might choose to place them right next to each other.)\nIf you decide you don't like where you placed something, then you can\nselect it using the Edit tool\n()\nand drag it to the desired spot. Or you can delete it altogether by selecting\nDelete from the Edit menu or pressing the Delete key.\nAs you place each component of the circuit, you'll notice that as soon as\nthe component is placed, Logisim reverts to the Edit tool so that you can\nmove the recently-placed component or (as we'll see soon) connect the component\nto others by creating wires. If you want to add a copy of the recently placed\ncomponent, a shortcut is to press Control-D to duplicate the selection.\n(Some computers use another keys for menus, such as the Command key on\nMacintoshes. You would press that key with the D key.)"
  },
  {
    "id": 6,
    "title": "Step 2: Adding wires",
    "url": "/en/html/guide/tutorial/tutor-wires.html",
    "text": "Tutorial: Adding wires\nStep 2: Adding wires\nAfter you have all the components blocked out on the canvas, you're\nready to start adding wires. Select the Edit Tool\n().\nWhen the cursor is over a point that receives a wire, a small green circle\nwill be drawn around it. Press the mouse button there and drag as far as you\nwant the wire to go.\nLogisim is rather intelligent when adding wires: Whenever a wire ends at\nanother wire, Logisim automatically connects them. You can also \"extend\" or\n\"shorten\" a wire by dragging one of its endpoints using the edit tool.\nWires in Logisim must be horizontal or vertical. To connect the upper\ninput to the NOT gate and the AND gate, then, I added three\ndifferent wires.\nLogisim automatically connects wires to the gates\nand to each other. This includes automatically drawing the circle at\na T intersection as above, indicating that the\nwires are connected.\nAs you draw wires, you may see some blue or gray wires. Blue in Logisim\nindicates that the value at that point is \"unknown,\" and gray\nindicates that the wire is not connected to anything.\nThis is not a big\ndeal as you're in the process of building a circuit. But by the time you finish\nit, none of your wires should be blue or gray. (The unconnected legs of the OR\ngate will still be blue: That's fine.)\nIf you do have a blue or a gray wire after you think everything\nought to be connected, then something is going wrong.\nIt's important\nthat you connect wires to the right places. Logisim draws little dots\non the components to indicate where wires ought to connect. As you\nproceed, you'll see the dots turn from blue to light or dark green.\nOnce you have all the wires connected, all of the wires you inserted\nwill themselves be light or dark green."
  },
  {
    "id": 7,
    "title": "Step 3: Adding text",
    "url": "/en/html/guide/tutorial/tutor-text.html",
    "text": "Tutorial: Adding text\nStep 3: Adding text\nAdding text to the circuit isn't necessary to make it work;\nbut if you want to show your circuit to somebody (like a teacher),\nthen some labels help to communicate the purpose of the\ndifferent pieces of your circuit.\nSelect the text tool\n().\nYou can click on an input pin and start typing to give it\na label. (It's better to click directly on the input pin than to\nclick where you want the text to go, because then the label will\nmove with the pin.)\nYou can do the same for the output pin. Or you could just click any old\nplace and start typing to put a label anywhere else."
  },
  {
    "id": 8,
    "title": "Step 4: Testing your circuit",
    "url": "/en/html/guide/tutorial/tutor-test.html",
    "text": "Tutorial: Testing your circuit\nStep 4: Testing your circuit\nOur final step is to test our circuit to ensure that it really does\nwhat we intended. Logisim is already simulating the circuit. Let's look\nagain at where we were.\nNote that the input pins both contain 0s; and so does the output pin.\nThis already tells us that the circuit already computes a 0 when both\ninputs are 0.\nNow to try another combination of inputs. Select the poke tool\n() and start poking the\ninputs by clicking on them. Each time you poke an input, its value will\ntoggle.\nFor example, we might first poke the bottom input.\nWhen you change the input value, Logisim will show you what values\ntravel down the wires by drawing them light green to indicate a 1 value\nor dark green (almost black) to indicate a 0 value. You can also see\nthat the output value has changed to 1.\nSo far, we have tested the first two rows of our truth table, and the\noutputs (0 and 1) match the desired outputs.\nBy poking the switches through different combinations, we can verify the\nother two rows. If they all match, then we're done: The circuit works!\nTo archive your completed work, you might want to save or print\nyour circuit.\nThe File menu allows this, and of course it also allows\nyou to exit Logisim. But why quit now?\nNow that you are finished with tutorial, you can experiment with\nLogisim by building your own circuits. If you want to build circuits\nwith more sophisticated features, then you should navigate through\nthe rest of the help system to see what else you can do.\nLogisim is\na powerful program, allowing you to build up and test huge circuits;\nthis step-by-step process just scratches the surface."
  },
  {
    "id": 9,
    "title": "Libraries and attributes",
    "url": "/en/html/guide/attrlib/index.html",
    "text": "Libraries and Attributes\nLibraries and Attributes\nIn this section, we'll examine how to use the other two major\nregions of the Logisim window, the explorer pane and\nthe attribute table.\nThe explorer pane\nThe attribute table\nTool and component attributes"
  },
  {
    "id": 10,
    "title": "The explorer pane",
    "url": "/en/html/guide/attrlib/explore.html",
    "text": "The explorer pane\nThe explorer pane\nLogisim organizes tools into libraries. They are displayed\nas folders in the explorer pane; to access a library's components, you have only\nto double-click the corresponding folder.\nBelow, I have opened the Gates library and selected the NAND tool from\nit. You can see that Logisim now stands ready to add NAND gates into the\ncircuit.\nIf you look through the choices in the Gates library, you'll notice that\nthere was no need for us to develop a XOR circuit earlier: It's built\ninto Logisim.\nWhen you create a project, it automatically includes several libraries:\nWiring: Components that interact directly with wires.\nGates: Components that perform simple logic functions.\nPlexers: More complex combinational components, like multiplexers and\ndecoders.\nArithmetic: Components that perform arithmetic.\nMemory: Components that remember data, like flip-flops, registers, and\nRAM.\nI/O: Components that exist for the purpose of interacting with the\nuser.\nBase: Tools that are integral to using Logisim, though you probably won't\nneed to dig into this library very often.\nLogisim allows you to add more libraries, too, using the Load Library submenu\nof the Project menu.\nYou can see that Logisim has three categories of libraries.\nBuilt-in libraries are libraries that are\ndistributed with Logisim. These are documented in the\nLibrary Reference.\nLogisim libraries are projects built\nwithin Logisim and saved to the disk as a Logisim project. You can develop a\nset of circuits in a single project (as described in the\nSubcircuits section of this guide)\nand then use that set of circuits as a library for other projects.\nJAR libraries are libraries that are developed\nin Java but not distributed with Logisim.\nYou can download JAR\nlibraries that others have written, or you can write your own as\ndescribed in the JAR Libraries section\nof this guide.\nDeveloping a JAR library is much more difficult than\ndeveloping a Logisim library, but the components can be much fancier,\nincluding things like attributes and interaction with the user.\nThe built-in libraries (other than Base) were written using the same\nAPI as JAR libraries can use, so they aptly demonstrate the range of\nfunctionality that the JAR libraries can support.\nSome JAR libraries are distributed without any information about\nwhich Java class to start with. When loading such a JAR, Logisim\nwill prompt you to type a class name. This class name should be provided\nby whoever distributed the JAR file to you.\nTo remove a library, choose Unload Library... from the Project\nmenu. Logisim will prevent you from unloading libraries that contain\ncomponents used in a circuit, that appear in the toolbar, or that\nare mapped to a mouse button.\nIncidentally, a library technically contains tools, not\ncomponents. Thus, in the Base library you'll find the Poke Tool\n(), the Edit Tool\n(), and other tools that don't\ncorrespond directly to individual components.\nMost libraries, though, contain only tools for adding individual\ncomponents; all built-in libraries other than the Base library\nare like this."
  },
  {
    "id": 11,
    "title": "The attribute table",
    "url": "/en/html/guide/attrlib/attr.html",
    "text": "The attribute table\nThe attribute table\nMany components have attributes, which are\nproperties for configuring how the component behaves or appears. The\nattribute table is for viewing and displaying a\ncomponent's attribute values.\nTo select which component's attributes you wish to view, click\nthe component using the Edit tool\n().\n(You can also right-click (or control-click) the component\nand choose Show Attributes from the popup menu. Also,\nmanipulating a component via the Poke tool\n() or the Text tool\n() will display that component's\nattributes.)\nThe below screen shot demonstrates what things look like\nafter selecting the upper input of our XOR circuit and scrolling\ndown to view the Label Font attribute.\nTo modify an attribute value, click on the value. The\ninterface for modifying the attribute will depend on which\nattribute you are changing; in the case of the Label Font\nattribute, a dialog box will appear for selecting the new font;\nbut some attributes (like Label) will allow you to\nedit the value as a text field, while others (like Label\nLocation) will display a drop-down menu from which to select\nthe value.\nEach component type has a different set of attributes; to\nlearn what they mean, go to the relevant documentation in the\nLibrary Reference.\nIf you've selected multiple components using the Edit tool, then\nthe attribute table will display attributes that are shared among all\nthe selected components (excluding any wires). If the selected components\ndon't all have the same value for the attribute, then the displayed value will\nbe blank. You can change the value for all selected components' attribute at\nonce by using the attribute table."
  },
  {
    "id": 12,
    "title": "Tool and component attributes",
    "url": "/en/html/guide/attrlib/tool.html",
    "text": "Tool Attributes\nTool attributes\nEvery tool for adding components to a circuit also has a set of\nattributes, which are imparted to the components created by the tool,\nalthough the components' attributes may be changed later without\naffecting the tool's attributes.\nWhen you select a tool, Logisim\nwill change the attribute table to display that tool's attributes.\nFor example, suppose we want to create smaller AND gates.\nRight now, each time we select the AND tool, it creates a large AND gate.\nBut if we edit the Gate Size attribute just after selecting the tool (before\nplacing its AND gate into the circuit), we'll be changing\nthe attributes for the tool, so that future AND gates added using the tool\nwould be narrow instead.\nNow, we can delete the two existing AND gates and add two new\nAND gates in their place. This time, they will be narrow.\n(If you chose to reduce the number of inputs to 3, the AND gate\nwould not have vertical extension on the left side. But you'd also\nhave to rewire the circuit so that the wires hit the AND gate's left\nside.)\nWith some tools, the tool's icon reflects some of the attributes'\nvalues. One example of this is the Pin tool, whose icon\nfaces the same way as its Facing attribute says.\nThe tools in the toolbar each have a separate attribute set from\nthe corresponding tools in the explorer pane. Thus, even though we\nchanged the toolbar's AND tool to create narrow AND gates, the AND\ntool in the Gates library will still create wide AND gates unless\nyou change its attributes too.\nIn fact, the input pin and output pin tools in the default\ntoolbar are both instances of the Wiring library's Pin tool, but\nthe attribute sets are different. The icon for the Pin tool\nis drawn as a circle or a square depending on the value of its\n\"Output?\" attribute.\nLogisim provides a handy shortcut for changing the Facing attribute\nthat controls the direction in which many components face: Typing an\narrow key while that tool is selected automatically changes the\ndirection of the component."
  },
  {
    "id": 13,
    "title": "Subcircuits",
    "url": "/en/html/guide/subcirc/index.html",
    "text": "Subcircuits\nSubcircuits\nAs you build circuits that are more and more sophisticated, you will\nwant to build smaller circuits that you can use multiple times\nas a module nested within larger circuits.\nIn Logisim, such a smaller circuit that is used in a larger\ncircuit is called a subcircuit.\nIf you're familiar with computer programming, you're familiar with\nthe subprogram concept, whether it's called a subroutine,\nfunction, method, or procedure in your\nfavored language.\nThe subcircuit concept is analogous to this, and it serves the same purpose:\nTo break a large job into bite-sized pieces,\nto save the effort of defining the same concept multiple times, and to\nfacilitate debugging.\nCreating circuits\nUsing subcircuits\nEditing subcircuit appearance\nDebugging subcircuits\nLogisim libraries"
  },
  {
    "id": 14,
    "title": "Creating circuits",
    "url": "/en/html/guide/subcirc/creating.html",
    "text": "Creating circuits\nCreating circuits\nEvery Logisim project is actually a library of circuits. In\nits simplest form, each project has only one circuit (called\n\"main\" by default), but it is easy to add more:\nSelect Add Circuit... from the Project menu, and type any name\nyou like for the new circuit you want to create.\nSuppose we want to build a 2-to-1 multiplexer named \"2:1 MUX.\"\nAfter adding the circuit, Logisim will look like this.\nIn the explorer pane, you can now see that the project now\ncontains two circuits, \"main\", and \"2:1 MUX.\" Logisim draws a\nmagnifying glass over the icon of the circuit currently being\nviewed; the current circuit name also appears in the window's\ntitle bar.\nAfter editing the circuit to appear like a 2:1 multiplexer,\nwe might end up with the following circuit."
  },
  {
    "id": 15,
    "title": "Using subcircuits",
    "url": "/en/html/guide/subcirc/using.html",
    "text": "Using subcircuits\nUsing subcircuits\nNow suppose we want to build a 4-to-1 multiplexer using\ninstances of our 2-to-1 multiplexer. Of course, we would first create\na new circuit, which we'll call \"4:1 MUX.\" To add 2-to-1 multiplexers\ninto our circuit, we click the 2:1 MUX circuit once in the\nexplorer pane to select it as a tool, and then we can add copies of\nit, represented as boxes, by clicking within the canvas.\nIf you were to double-click the 2:1 MUX circuit in the explorer pane,\nthen the window would switch to editing the 2:1 MUX circuit instead.\nAfter building up the circuit, we end up with the following.\nOur circuit for a 4-to-1 multiplexer uses three copies of the\n2-to-1 multiplexer, each drawn as a box with pins along the side.\nThe pins on this box correspond to the input and output pins in the\n2:1 MUX circuit.\nThe two pins on the west side of the box correspond\nto the two pins that face east in the 2:1 MUX circuit; the pin on\nthe box's east side corresponds to the 2:1 MUX's west-facing pin\n(which happens to be an output pin); and the pin on the box's south\nside corresponds to the 2:1 MUX's north-facing pin.\nThe order of\nthe two pins on the box's west side correspond to the same top-down\nordering from the subcircuit's design.\n(If there were several pins\non the box's north or south side, they would correspond to the same\nleft-right order in the subcircuit.)\nIf the pins in the subcircuit's layout have labels associated with\nthem, then Logisim will display that label in a tip\n(that is, a temporary text box) when the user hovers the mouse over the\ncorresponding location of the subcircuit component. (If you find these\ntips irritating, you can disable them via the\nPreferences window's Layout\ntab.)\nSeveral other components will display these tips, too: For some of the\npins of a built-in flip-flop,\nfor example, hovering over it explains what that pin does.\nIncidentally, every pin to a circuit must be either an input or\nan output. Many manufactured chips have pins that behave as an input\nin some situations and as an output in others; you cannot construct\nsuch chips within Logisim (at least, in the current version).\nLogisim will maintain different state information for all subcircuits\nappearing in a circuit. For example, if a circuit contains a\nflip-flop, and that circuit is used as a subcircuit several\ntimes, then each subcircuit's flip-flop will have its own value\nwhen simulating the larger circuit.\nNow that we have the 4-to-1 multiplexer defined, we can now use it\nin other circuits. Logisim has no limits on how deeply circuits\ncan be nested - though it will object to nesting circuits within\nthemselves!\nNote: There's nothing wrong with editing a\ncircuit that is being used as a subcircuit; in fact, this is quite\ncommon. Be aware, though, that any changes to a circuit's pins (adding,\ndeleting, or moving them) will rearrange them also in the containing\ncircuit. Thus, if you change any pins in a circuit, you will also\nneed to edit any circuits using it as a subcircuit."
  },
  {
    "id": 16,
    "title": "Editing subcircuit appearance",
    "url": "/en/html/guide/subcirc/appear.html",
    "text": "Editing subcircuit appearance\nEditing subcircuit appearance\nDefault appearance\nBy default, when a subcircuit is placed within a larger circuit, it is drawn\nas a rectangle with a notch indicating the north end of the subcircuit's\nlayout. Pins will be placed on the rectangle's border based on their facing:\nPins that face east in the layout (and typically appear on the west side\nof the layout) will be placed on the rectangle's west side,\naccording to their top-down ordering in the layout.\nPins that face south in the layout (typically toward the north side of the layout)\nwill be placed on the rectangle's north side, according to the left-to-right\nordering in the layout.\nThe default rectangle can optionally include some letters that will appear\nin the middle of the rectangle. To specify this, select the selection tool\n() and click the background of the circuit's\nlayout. This will show the circuit attributes in the attribute table, including\nthe Shared Label, Shared Label Facing, and Shared Label Font attributes.\nThe value of the Shared Label attribute will be drawn in the rectangle's center;\nthe Shared Label Facing attribute customizes which direction the text is drawn,\nand of course the Shared Label Font attribute customizes the font used.\nCustomized appearance\nThe default appearance is very usable, and indeed Logisim existed for many\nyears with no other option. If, however, you prefer that the subcircuit be\ndrawn differently, you can select Edit Circuit Appearance from the\nProject menu, and Logisim's interface will switch from its regular\nlayout-editing interface to an interface for drawing the circuit's\nappearance.\n(You can also click the far-right icon ()\nin the explorer pane's upper toolbar.)\nBelow, we are editing the 2:1 multiplexer's appearance so that\nit is drawn with the usual trapezoid rather than a rectangle.\nWith the appearance for the 2:1 multiplexer drawn as above,\nthe layout for the 4:1 multiplexer would then appear as the following.\nThe appearance editor is like a traditional drawing program, but there\nare a few special symbols for indicating how the drawing works when placed\ninto a circuit's layout. These special symbols cannot be removed.\nThe green circle with a line coming out of it, which we'll call the anchor.\nThere is exactly one anchor in each subcircuit appearance.\nEach component in a circuit has a single point identifying its location;\na user sees this when creating a new component:\nThe mouse click identifies just a single location, and the component is placed\nrelative to that (usually with the primary output at the mouse's location)\nThe anchor identifies the mouse's location relative to the overall drawing\nwhen the subcircuit is created.\nThe anchor also identifies the appearance's facing, as indicated by the\ndirection the anchor's line points from its circle. When placing the subcircuit\ninto a layout, the user can change the subcircuit's facing; the anchor's facing\nindicates in which direction the appearance is oriented. In our example, the\nanchor is facing east, and each instance of the subcircuit in the 4:1 multiplexer\nis also facing east, so they are all drawn in the same orientation as the 2:1\nmultiplexer's appearance.\nThe blue circles and squares with dots in them are the subcircuit's\nports. There are exactly as many ports as there are input and output\npins in the circuit.\nPorts corresponding to inputs are drawn as squares, while ports corresponding\nto outputs are drawn as circles.\nEach port indicates how a wire connecting into the\ncircuit will correspond to an input or output pin within the layout.\nWhen you select a port, Logisim will indicate the corresponding pin\nby popping up a miniature diagram of the layout in the window's bottom right\ncorner, with the corresponding pin(s) drawn in blue. This does not happen when\nall ports are selected.\nThe toolbar contains tools for adding additional shapes, as listed below\nwith descriptions of how the shift and alt key modifies the tool behavior. In\naddition, clicking or dragging the mouse with the control key pressed regularly\nsnaps the mouse position to the nearest grid point.\nSelect, move, copy, and paste shapes.\nAdd or edit text.\nCreate a line segment. Shift-drag keeps the line's angle at a multiple of 45\u00b0.\nCreate a quadratic Bezier curve.\nFor the first drag, where you specify the curve's endpoints,\nshift-drag keeps the endpoints at an angle that is a multiple of 45\u00b0.\nThen you click to indicate the control point's location;\nshift-click ensures the curve is symmetric,\nwhile alt-click draws the curve through the control point.\nCreate a sequence of connected lines, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the angle between the\nprevious vertex and the current one is a multiple of 45\u00b0.\nDouble-click or press the Enter key to complete the\nshape.\nCreate a rectangle through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate a rectangle with rounded corners through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate an oval through dragging from one corner of its bounding box to the opposite corner.\nShift-drag to create a circle, and alt-drag to create the oval starting\nfrom the center.\nCreate an arbitrary polygon, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the vertex is at a 45\u00b0\nangle from the previous one. Double-click, press the Enter key, or click the\nstarting vertex to complete the shape."
  },
  {
    "id": 17,
    "title": "Debugging subcircuits",
    "url": "/en/html/guide/subcirc/debug.html",
    "text": "Debugging subcircuits\nDebugging subcircuits\nAs you test larger circuits, you will likely find bugs. To nail down\nwhat's going wrong, exploring what's going on in the subcircuits while\nrunning the overall circuit can help. To enter the subcircuit's state, you can\nuse any of three different techniques. The most straightforward is probably\nto view the simulation hierarchy by clicking the second icon in the explorer\npane's upper toolbar (), or by selecting\n\"View Simulation Tree\" from the Project menu. This switches\nthe explorer pane so that it shows the hierarchy of subcircuits being simulated.\nDouble-clicking an element in this hierarchy will display what is happening\ninside that subcircuit.\nThe second way you can enter a subcircuit is to bring up its popup menu\nby right-clicking or control-clicking it, and then choosing the View option.\nAnd the third way is to first ensure the Poke Tool is selected\nand then click the subcircuit you want to enter;\na magnifying glass will appear over the subcircuit's center, and\ndouble-clicking the magnifying glass will enter\nthe subcircuit's state.\nIn any case, once you enter the subcircuit, you'll see that the pins' values\nin the subcircuit match the values being sent through them from the containing\ncircuit.\nWhile in the subcircuit, you are allowed to alter the circuit. If the\nchanges affect any of the subcircuit's outputs, they are propagated into the\ncontaining circuit. One exception: The subcircuit inputs are determined based on\nthe values coming into the circuit from the supercircuit, so it doesn't make\nsense to toggle those values. If you attempt to poke a subcircuit's input,\na dialog will pop up asking, The pin is tied to the supercircuit state.\nCreate a new circuit state? Clicking No will cancel the toggle request,\nwhile clicking Yes will create a copy of the viewed state,\ndivorced from the outer circuit, with the input pin toggled.\nOnce you have completed viewing and/or editing, you can return to the parent circuit\neither by double-clicking the parent circuit in the explorer pane, or via the Go Out\nTo State submenu of the Simulate menu."
  },
  {
    "id": 18,
    "title": "Logisim libraries",
    "url": "/en/html/guide/subcirc/library.html",
    "text": "Logisim libraries\nLogisim libraries\nEvery Logisim project is automatically a library that can be loaded\ninto other Logisim projects: Just save it into a file and then load\nthe library within another project. All of the circuits defined in the\nfirst project will then be available as subcircuits for the second.\nThis feature allows you to reuse common components across projects\nand to share favorite components with your friends (or students).\nEach project has a designated \"main circuit,\" which can be changed\nto refer to the current circuit via the Set As Main Circuit option\nin the Project menu. The only significance of this is that\nthe main circuit is the one that is displayed when you first open\nthe project.\nThe default name of the circuit in a newly created file\n(\"main\") has no significance at all, and you can feel free to delete\nor rename that circuit.\nWith a loaded Logisim library, you are allowed to view circuits and\nmanipulate their states, but Logisim will prevent you from altering\nthe circuits' design and other data stored within the file.\nIf you want to alter a circuit in a loaded Logisim library, then\nyou need to open it separately within Logisim. As soon as you save\nit, the other project should automatically load the modified version\nimmediately; but if it does not, you can right-click the library\nfolder in the explorer pane and select Reload Library."
  },
  {
    "id": 19,
    "title": "Wire bundles",
    "url": "/en/html/guide/bundles/index.html",
    "text": "Wire bundles\nWire bundles\nIn simple Logisim circuits, most wires carry only one bit;\nbut Logisim also allows you to create wires that bundle together multiple bits.\nThe number of bits traveling along a wire is that wire's\nbit width.\nCreating bundles\nSplitters\nWire colors"
  },
  {
    "id": 20,
    "title": "Creating bundles",
    "url": "/en/html/guide/bundles/creating.html",
    "text": "Creating bundles\nCreating bundles\nEvery input and output on every component in the circuit has a\nbit width associated with it. Often the bit width is 1, and there is no way\nof changing that, but many of Logisim's built-in components\ninclude attributes allowing you to customize the bit widths of\ntheir inputs and outputs.\nThe below screen shot illustrates a simple circuit\nfor finding the bitwise AND of two three-bit inputs. Notice how the three-bit\noutput is the bitwise AND of the two inputs. All components have been\ncustomized to deal with three-bit data via its Data Bits attribute; the screen\nshot shows the AND gate attributes, including the Data Bits attribute of 3.\nAll components in Logisim define a bit width for each of input and output.\nIn contrast, a wire's bit width is undefined:\nInstead, the wire's width adapts to the components to which it\nis attached.\nIf a wire connects two components demanding different bit widths,\nLogisim will complain of \"Incompatible widths\" and indicate the\noffending locations in orange.\nIn the below, the output pin's Data Bits attribute has been\nchanged to 1, and so Logisim complains that the wire cannot\nconnect a three-bit value to a one-bit value.\nWires that connect incompatible locations (drawn in orange)\ndo not carry values.\nFor single-bit wires, you can see at a glance what value the wire carries\nbecause Logisim colors the wire light or dark green depending the value.\nIt does not display values for multi-bit wires: They are simply\nblack. You can, though, probe a wire by clicking it using the\npoke tool ().\nThis probing feature is helpful for debugging circuits using\nwire bundles."
  },
  {
    "id": 21,
    "title": "Splitters",
    "url": "/en/html/guide/bundles/splitting.html",
    "text": "Splitters\nSplitters\nWhen you work with multi-bit values, you will often want to route\ndifferent bits in different directions.\nThe Wiring library's splitter tool\n()\nallows you to accomplish this.\nFor example, suppose we want a circuit that computes the bitwise\nAND of the two nibbles of its eight-bit input (the upper four bits and\nthe lower four bits). We will have an eight-bit value coming from the\ninput pin, and we want to split that into two four-bit values. In the\nbelow circuit, we have used a splitter to accomplish this: The 8-bit input\ncomes into the splitter, which divides the\n8 bits into two 4-bit values, which are then fed into the AND gate and from\nthere to the output.\nIn this example, the splitter splits an\nincoming value into multiple outgoing values. But splitters can\nalso work the other way: It can combine multiple values into a single value. In fact,\nthey are non-directional: They can send values one way at one time\nand another way later, and they can even do both at the same\ntime, as in the below example where a value travels eastward through the two\nsplitters, then is routed back westward through them again, and then back\neastward where it finally reaches its output.\nThe key to understanding splitters is their attributes.\nIn the following, the term split end refers to one of\nthe multiple wires on one side, while the term combined\nend refers to the single wire on the other side.\nThe Facing attribute tells where the split ends\nshould be relative to the combined end.\nThe Fan Out attribute specifies how many\nsplit ends there are.\nThe Bit Width In attribute specifies the bit width of\nthe combined end.\nThe Bit x attribute says which split\nend corresponds to bit x of the combined end. If multiple\nbits correspond to the same split end, then their relative ordering\nwill be the same as in the combined end. Logisim splitters cannot\nhave a bit from the combined end correspond to multiple split ends.\nNote that any change to the Fan Out or Bit Width In\nattributes will reset all Bit x attributes so that\nthey will distribute the bits of the combined value as evenly\nas possible among the split ends."
  },
  {
    "id": 22,
    "title": "Wire colors",
    "url": "/en/html/guide/bundles/colors.html",
    "text": "Wire colors\nWire colors\nWe are now in a position to summarize the full rainbow of\ncolors that Logisim wires can take on. The following\nlittle circuit illustrates all of them at once.\nGray: The wire's bit width is unknown. This\noccurs because the wire is not attached to any components' inputs\nand outputs. (All inputs and outputs have a defined bit width.)\nBlue: The wire carries a one-bit\nvalue, but nothing is driving a specific value onto the wire.\nWe call this a floating bit; some people call it a\nhigh-impedance value.\nIn this example, the component placing a value onto the wire is a three-state\npin, so it can emit this floating value.\nDark green: The wire is carrying a one-bit 0\nvalue.\nBright green: The wire is carrying a one-bit 1\nvalue.\nBlack: The wire is carrying a multi-bit value.\nSome or all of the bits may not be specified.\nRed: The wire is carrying an error value.\nThis often arises because a gate cannot determine the proper output,\nperhaps because it has no inputs. It could also arise because two components\nare trying to send different values onto the wire;\nthis is what happens in the above example,\nwhere one input pin places 0 onto the wire\nwhile another places 1 onto the same wire, causing a conflict.\nMulti-bit wires will turn red when any of the bits carried are error values.\nOrange: The components attached to the wire do\nnot agree in bit width. An orange wire is effectively \"broken\": It does\nnot carry values between components. Here, we've attached a two-bit\ncomponent to a one-bit component, so they are incompatible."
  },
  {
    "id": 23,
    "title": "Combinational analysis",
    "url": "/en/html/guide/analyze/index.html",
    "text": "Combinational analysis\nCombinational analysis\nAll circuits fall into one of two well-known categories:\nIn a combinational circuit,\nall circuit outputs are a strict combination of the current\ncircuit inputs, whereas in a sequential circuit,\nsome outputs may depend on past inputs (the sequence of\ninputs over time).\nThe category of combinational circuits is the simpler of the\ntwo. Practitioners use three major techniques for summarizing\nthe behavior of such circuits.\nlogic circuits\nBoolean expressions, which allow an algebraic representation\nof how the circuit works\ntruth tables, which list all possible input combinations and\nthe corresponding outputs\nThe Combinational Analysis module of Logisim allows\nyou to convert between these three representations in all\ndirections. It is a particularly handy way of creating and\nunderstanding circuits with a handful of one-bit inputs and outputs.\nOpening Combinational Analysis\nEditing the truth table\nCreating expressions\nGenerating a circuit"
  },
  {
    "id": 24,
    "title": "Opening Combinational Analysis",
    "url": "/en/html/guide/analyze/open.html",
    "text": "Opening Combinational Analysis\nOpening Combinational Analysis\nThe bulk of the Combinational Analysis module is accessed through\na single window of that name allowing you to view truth tables and\nBoolean expressions. This window can be opened in two ways.\nVia the Window menu\nSelect Combinational Analysis, and the current Combinational Analysis\nwindow will appear. If you haven't viewed the window before,\nthe opened window will represent no circuit at all.\nOnly one Combinational Analysis window exists within Logisim,\nno matter how many projects are open.\nThere is no way to have two\ndifferent analysis windows open at once.\nVia the Project menu\nFrom a window for editing circuits, you can also request that\nLogisim analyze the current circuit by selecting the Analyze Circuit\noption from the Project menu. Before Logisim opens the window, it\nwill compute Boolean expressions and a truth table corresponding to\nthe circuit and place them there for you to view.\nFor the analysis to be successful, each input must be attached to an\ninput pin, and each output must be attached to an output pin.\nLogisim will only analyze circuits with at most eight of each\ntype, and all should be single-bit pins. Otherwise, you will see\nan error message and the window will not open.\nIn constructing Boolean expressions corresponding to a circuit,\nLogisim will first attempt to construct a Boolean expressions\ncorresponding exactly to the gates in the circuit. But if the circuit\nuses some non-gate components (such as a multiplexer), or if the\ncircuit is more than 100 levels deep (unlikely), then it will pop\nup a dialog box telling you that deriving Boolean expressions was\nimpossible, and Logisim will instead derive the expressions based\non the truth table, which will be derived by quietly trying each\ncombination of inputs and reading the resulting outputs.\nAfter analyzing a circuit, there is no continuing relationship\nbetween the circuit and the Combinational Analysis window.\nThat is,\nchanges to the circuit will not be reflected in the window, nor will\nchanges to the Boolean expressions and/or truth table in the window be\nreflected in the circuit. Of course, you are always free to analyze a\ncircuit again; and, as we will see later, you can replace the circuit\nwith a circuit corresponding to what appears in the Combinational\nAnalysis window.\nLimitations\nLogisim will not attempt to detect sequential circuits: If you\ntell it to analyze a sequential circuit, it will still create a truth\ntable and corresponding Boolean expressions, although these will\nnot accurately summarize the circuit behavior.\n(In fact, detecting\nsequential circuits is provably impossible, as it would\namount to solving the Halting Problem.\nOf course, you might hope\nthat Logisim would make at least some attempt - perhaps look for\nflip-flops or cycles in the wires - but it does not.) As a result,\nthe Combinational Analysis system should not be used indiscriminately:\nOnly use it when you are indeed sure that the circuit you are analyzing\nis indeed combinational!\nLogisim will make a change to the original circuit that is perhaps\nunexpected: The Combinational Analysis system requires that each\ninput and output have a unique name that conforming to the rules for\nJava identifiers.\n(Roughly, each character must either a letter or a\ndigit, and the first character must be a letter. No spaces allowed!)\nIt attempts to use the pins' existing labels, and to use a list of\ndefaults if no label exists. If an existing label doesn't follow the\nJava-identifier rule, then Logisim will attempt to extract a valid\nname from the label if at all possible.\nIncidentally, the ordering of the inputs in the truth table will\nmatch their top-down ordering in the original circuit, with ties\nbeing broken in left-right order. (The same applies to the ordering\nof outputs.)"
  },
  {
    "id": 25,
    "title": "Editing the truth table",
    "url": "/en/html/guide/analyze/table.html",
    "text": "Editing the truth table\nEditing the truth table\nOn opening the Combinational Analysis window, you will see that\nit consists of five tabs.\nThis page describes the first three tabs, Inputs, Outputs, and Table.\nThe next page of the guide describes the last two tabs,\nExpression and Minimized.\nThe Inputs and Outputs tabs\nThe Inputs tab allows you to view and edit the list of inputs.\nTo add new inputs, type it in the field at the pane's bottom,\nand click Add. If you want to rename an existing input, select it\nin the list in the pane's upper left region; then type the name\nand click Rename.\nTo remove an input, select it from the list and click Remove.\nYou can also reorder the inputs (which affects the order of\ncolumns in the truth table and in the generated circuit) using\nthe Move Up or Move Down buttons on an input.\nAll actions affect the truth table immediately.\nThe Outputs tab works in exactly the same way as the Inputs tab,\nexcept of course it works with the list of outputs instead.\nThe Table tab\nThe only item under the Table tab is the current truth table,\ndiagrammed in the conventional order, with inputs constituting the\ncolumns on the left and outputs constituting the columns on the\nright.\nYou can edit the current values appearing in the output columns by\nclicking on the value of interest. The values will cycle through 0,\n1, and x (representing a \"don't care\"). As we'll see on the\nnext page, any don't-care values allow the computation of\nminimized expressions some flexibility.\nYou can also navigate and edit the truth table using the keyboard.\nAnd you can copy and paste values using the clipboard. The clipboard\ncan be transferred to any application supporting tab-delimited text\n(such as a spreadsheet).\nIf the truth table is based on an existing circuit,\nyou may see some pink squares in the output columns with \"!!\" in them.\nThese correspond to errors that occurred while calculating the value\nfor that row - either the circuit seemed to be oscillating, or the\noutput value was an error value (which would be pictured as a red wire\nin the Logisim circuit). Hovering your mouse over the entry should\nbring up a tool tip describing which type of error it was. Once you\nclick on the error entry, you will be in the 0-1-x cycle;\nthere is no way to go back."
  },
  {
    "id": 26,
    "title": "Creating expressions",
    "url": "/en/html/guide/analyze/expr.html",
    "text": "Creating expressions\nCreating expressions\nFor each output variable, the Combinational Analysis window\nmaintains two structures - the relevant column of the truth table,\nand a Boolean expression - specifying how each output relates to its\ninput. You can edit either the truth table or the expression; the other\nwill automatically change as necessary to keep them consistent.\nAs we will see on the next page, the Boolean expressions are\nparticularly useful because the Combinational Analysis window will\nuse these when told to build a circuit corresponding to the current\nstate.\nYou can view and edit the expressions using the window's last two\ntabs, the Expression tab and the Minimized tab.\nThe Expression tab\nThe Expression tab allows you to view and edit the current\nexpression associated with each output variable. You can select the\noutput expression you want to view and edit using the selector labeled\n\"Output:\" at the pane's top.\nJust below the selector will appear the expression formatted in a\nparticularly common notation, where an OR is represented as addition,\nan AND is represented as multiplication, and a NOT is denoted with a bar\nabove the portion affected by the NOT.\nThe text pane below this displays the same information in ASCII form.\nHere, a NOT is represented with a tilde ('~').\nYou can edit the expression in the text pane and click the Enter\nbutton to make it take effect; doing this will also update the truth\ntable to make it correspond. The Clear button clears the text pane,\nand the Revert button changes the pane back to representing the\ncurrent expression.\nNote that your edited expression will be lost if you edit the truth table.\nIn addition to multiplication and addition standing for AND and OR, an expression\nyou type may contain any of C/Java logical operators, as well as simply the words themselves.\nhighest precedence~ ! ' NOT\n(none) & && AND\n^ XOR\nlowest precedence+ | || OR\nThe following examples are all valid representations of the same expression. You could\nalso mix the operators.\na' (b + c)\n!a && (b || c)\nNOT a AND (b OR c)\nIn general, parentheses within a sequence of ANDs (or ORs or\nXORs) do not matter. (In particular, when Logisim creates a\ncorresponding circuit, it will ignore such parentheses.)\nThe Minimized tab\nThe final tab displays a minimized expression\ncorresponding to a column of the truth table. You can select which\noutput's minimized expression you want to view using the selector\nat top, and you can indicate whether you want to derive a sum-of-products\nexpression or a product-of-sums expression using the selector below.\nIf there are four or fewer inputs, a Karnaugh map corresponding\nto the variable will appear below the selector. You can click the\nKarnaugh map to change the corresponding truth table values. The\nKarnaugh map will also display the currently selected terms for the\nminimized expression as solid semitransparent rounded rectangles.\nBelow this is the minimized expression itself, formatted as in the\nExpression tab's display. If there are more than four inputs,\nthe Karnaugh map will not appear; but the minimized expression will\nstill be computed. (Logisim uses the Quine-McCluskey algorithm to\ncompute the minimized expression. This is equivalent to a Karnaugh map,\nbut it applies to any number of input variables.)\nThe Set As Expression button allows you to select the minimized\nexpression as the expression corresponding to the variable. This will\ngenerally not be necessary, as edits to the truth table result in using\nthe minimized expression for the changed column; but if you enter an\nexpression through the Expression tab, this can be a convenient way\nto switch to the corresponding minimized expression."
  },
  {
    "id": 27,
    "title": "Generating a circuit",
    "url": "/en/html/guide/analyze/gen.html",
    "text": "Generating a circuit\nGenerating a circuit\nThe Build Circuit button will construct a circuit whose gates\ncorrespond to the currently chosen expressions for each output. The\ncircuit's inputs and outputs will be displayed in top-down order\ncorresponding to how they appear under the Inputs and Outputs\ntabs. Generally speaking, the constructed circuit will be attractive;\nand, indeed, one application of Logisim's Combinational Analysis\nmodule is to beautify poorly drawn circuits. Still, as with any\nautomatic formatting, it will not express the structural details that\na human-drawn circuit would.\nWhen you click the Build Circuit button, a dialog box will appear\nprompting you to choose which project where you want the circuit and\nthe name you wish to give it.\nIf you type the name of an existing\ncircuit, then that circuit will be replaced (after Logisim prompts\nyou to confirm that you really want to do this).\nThe Build Circuit dialog includes two options. The Use Two-Input\nGates Only option specifies that you want all gates constructed to have\ntwo inputs.\n(NOT gates, of course, constitute an exception to this\nrule.)\nThe Use NAND Gates Only option specifies that you would like\nit to translate the circuit into one using only NAND gates. You can\nselect both options if you want to use only two-input NAND gates.\nLogisim cannot construct a NAND-only circuit for an expression\ncontaining any XOR operators. This option will therefore be disabled\nif any outputs' expressions contain XORs."
  },
  {
    "id": 28,
    "title": "Menu reference",
    "url": "/en/html/guide/menu/index.html",
    "text": "Menu Reference\nMenu Reference\nThis section explains the six menus that accompany\nevery major Logisim window.\nThe File menu\nThe Edit menu\nThe Project menu\nThe Simulate menu\nThe Window and Help menus\nMany menu items relate specifically to a currently opened\nproject.\nBut some Logisim windows (particularly the Combinational Analysis window and the\nApplication Preferences window) are\nnot associated with projects. For these windows, the project-specific\nmenu items will be disabled."
  },
  {
    "id": 29,
    "title": "The File menu",
    "url": "/en/html/guide/menu/file.html",
    "text": "The File menu\nThe File menu\nNew\nOpens a new project in a new window. The project will\ninitially be a copy of the\ncurrently selected template.\nOpen...\nOpens an existing file as a project in a new window.\nOpen Recent\nOpens a recently opened project in a new window\nwithout prompting the user to navigate through a file selection dialog.\nClose\nCloses all windows associated with the currently viewed\nproject.\nSave\nSaves the currently viewed project, overwriting what was\npreviously in the file.\nSave As...\nSaves the currently viewed project, prompting the user to\nsave into a different file than before.\nExport Image...\nCreates image file(s) corresponding to circuits.\nThe configuration dialog box is described below.\nPrint...\nSends circuit(s) to a printer. The configuration dialog box\nis described below.\nPreferences...\nDisplays the application\npreferences window. (On Mac OS systems, this will appear\nin the Logisim menu.)\nExit\nCloses all currently open projects and terminates Logisim.\n(On Mac OS systems, this will appear\nas Quit in the Logisim menu.)\nConfiguring Export\nWhen you select Export Image..., Logisim displays a dialog box\nwith four options.\nCircuits: A list where you can select one or more circuits\nthat should be exported into image files. (Empty circuits are not\ndisplayed as options.)\nImage Format: You can create PNG, GIF, and JPEG files. I would\nrecommend PNG files: The GIF format is quite dated, and the JPEG format will\nintroduce artifacts into the image, as the JPEG format is\nreally meant for photographic images.\nScale Factor: You can scale the images as they are dumped\ninto image files using this slider.\nPrinter View: Whether to use\n\"printer view\" in exporting\nthe circuits.\nAfter clicking OK, Logisim will display a file selection dialog\nbox. If you have selected one circuit, select the file into which\nthe image should be placed. If you have selected multiple circuits,\nselect a directory where the files should be placed; Logisim will\nname the images based on the circuits' names (main.png,\nfor example).\nConfiguring Print\nWhen you choose Print..., Logisim displays a dialog box for\nconfiguring what is printed.\nCircuits: A list where you can select one or more circuits\nto be printed. (Empty circuits are not\ndisplayed as options.) Logisim will print one circuit per page. If the circuit is too\nlarge for the page, the image will be scaled down to fit.\nHeader: Text that should appear centered at the top of\neach page. The following substitutions will be made into the text.\n%nName of circuit on page\n%pPage number\n%PTotal page count\n%%A single percent sign ('%')\nRotate To Fit: If checked, then Logisim will rotate\neach circuit by 90 degrees when the circuit is too large to\nfit onto the page and it does not need to be scaled as\nsmall when rotated 90 degrees.\nPrinter View: Whether to use\n\"printer view\" in printing\nthe circuits.\nAfter clicking OK, Logisim will display the standard page setup\ndialog box before printing the circuits."
  },
  {
    "id": 30,
    "title": "The Edit menu",
    "url": "/en/html/guide/menu/edit.html",
    "text": "The Edit menu\nThe Edit menu\nUndo XX\nUndoes the most recently completed action affecting how the\ncircuit would be saved in a file. Note that this does not\ninclude changes to the circuit state (as with manipulations\nperformed by the Poke Tool).\nCut\nRemoves the currently selected components from the circuit onto\nLogisim's clipboard.\nNote: Logisim's clipboard is maintained separately\nfrom the clipboard for the overall system; as a result, cut/copy/paste\nwill not work across different applications, even including other\nrunning copies of Logisim. If, however, you have multiple\nprojects open under the same Logisim process, then you should be\nable to cut/copy/paste between them.\nCopy\nCopies the currently selected components in the circuit onto\nLogisim's clipboard. (See the note under the Cut menu\nitem.)\nPaste\nPastes the components on Logisim's clipboard into the current\nselection.\n(See the note under the Cut menu item.)\nWhen you paste components, they will not immediately be\ndropped; instead, they will be drawn in light gray. They will\nnot actually be ``dropped'' into the circuit until you either\nmove the selection or change the selection so that the\ncomponents are no longer in it.\nThe reason for this odd behavior is this: To be consistent with\nits other behavior, Logisim must immediately merge any wires as soon\nas they are dropped into a circuit; this merging process changes\nexisting wires in the circuit.\nWhen you paste wires from the\nclipboard, however, you may want them to appear in a different location,\nand the changing inherent in the merging process would be against\nyour wishes.\nDelete\nRemoves all components in the current selection from the\ncircuit, without modifying the clipboard.\nDuplicate\nCreates a copy of all components in the current selection. This is like\nselecting Copy, then Paste, except that Duplicate doesn't modify or use\nthe clipboard.\nSelect All\nSelects all components in the current circuit.\nRaise Selection\nThis menu item is available only when editing a circuit's appearance.\nIt raises the currently selected object(s) so that it is drawn (or they are drawn)\non top of an object that currently overlaps the selection. If the selection\nis overlapped by several objects, it is raised only to be above the lowest\none; select the menu item repeatedly until it is in the order it\nshould be.\n(Determining whether two arbitrary objects overlap is difficult. Logisim uses\nan algorithm of selecting several random points in each of the two objects\nand seeing if any point is also in the other object. Sometimes it will fail to\ndetect an overlap if the overlap is small \u2014 say, less than 5% of\neither of the objects.)\nLower Selection\nThis menu item is available only when editing a circuit's appearance.\nIt lowers the currently selected object(s) so that it is drawn (or they are drawn)\nbelow an object that the selection currently overlaps.\nIf the selection overlaps several objects, it is lowered only\nto be below the highest one; select the menu item repeatedly until it is in the\norder it should be.\nRaise To Top\nAvailable only when editing a circuit's appearance, this menu item\nraises the currently selected object(s) to be drawn on top of all other objects.\n(The anchor and the ports are exceptions \u2014 they are always on top.)\nLower To Bottom\nAvailable only when editing a circuit's appearance, this menu item\nlowers the currently selected object(s) so that all other objects are drawn\non top of them.\nAdd Vertex\nAvailable only when editing a circuit's appearance and a point has been\nselected on a line, polyline, or polygon, this menu item inserts a new vertex\nonto the shape. Previous to insertion, the selected point is drawn as a\ndiamond.\nRemove Vertex\nAvailable only when editing a circuit's appearance and an existing\nvertex has been selected on a polyline or polygon, this menu item removes\nthe selected vertex. Previous to deletion, the selected vertex is drawn as a\ndiamond within the square representing the vertex. Logisim will not permit\nremoving a vertex on a polygon with only three vertices or on a polyline with\nonly two vertices."
  },
  {
    "id": 31,
    "title": "The Project menu",
    "url": "/en/html/guide/menu/project.html",
    "text": "The Project menu\nThe Project menu\nAdd Circuit...\nAdds a new circuit into the current project. Logisim will\ninsist that you name the new circuit. The name must not match\nany existing circuits in the project.\nLoad Library\nLoads a library into the\nproject. You can load three types of libraries, as explained elsewhere in the User's\nGuide.\nUnload Libraries...\nUnloads current libraries from the project. Logisim will\nnot permit you to unload any libraries currently being used,\nincluding libraries containing components appearing in any\nproject circuits, as well as those with tools that appear in\nthe toolbar or that are mapped to the mouse.\nMove Circuit Up\nMoves the currently displayed circuit one step up the list of\ncircuits within the project, as displayed in the explorer pane.\nMove Circuit Down\nMoves the currently displayed circuit one step down the list of\ncircuits within the project, as displayed in the explorer pane.\nSet As Main Circuit\nSets the currently displayed circuit to be the project's\nmain circuit. (This menu item will be grayed out if the\ncurrent circuit is already the project's main circuit.)\nThe only significance of the main circuit is that it is the\ncircuit that first appears when a project file is opened.\nRevert To Default Appearance\nIf you've edited the circuit's appearance, this menu item reverts\nthe appearance back to the default rectangle-with-notch appearance.\nThe menu item is enabled only when editing the circuit's appearance.\nView Toolbox\nChanges the explorer pane to displaying a list of the project's\ncircuits and the libraries that have been loaded.\nView Simulation Tree\nChanges the explorer pane to displaying the hierarchy of\nsubcircuits in the current simulation.\nEdit Circuit Layout\nSwitches to allow you to edit the layout of components, which\ndetermines how the circuit works. This menu item is usually disabled since\nyou will usually be editing the layout anyway.\nEdit Circuit Appearance\nSwitches to allow you to edit how the circuit will be represented\nwhen it is used as a subcircuit within another circuit. By default, the circuit\nis represented as a rectangle with a gray notch on its north end, but\nthis menu option allows you to draw a different appearance for the\nsubcircuit.\nRemove Circuit\nRemoves the currently displayed circuit from the project.\nLogisim will prevent you from removing circuits that are used as\nsubcircuits, and it will prevent you from removing the final\ncircuit in a project.\nAnalyze Circuit\nComputes a truth table and Boolean expressions corresponding\nto the current circuit, displaying them in\nthe Combinational Analysis window.\nThe analysis process will only be valid for combinational circuits.\nA full description of the analysis process is described\nin the\nCombinational Analysis section.\nGet Circuit Statistics\nShows a dialog containing statistics about components used by the\ncurrently viewed circuit. The dialog includes a table with five columns:\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nSimple: The number of times that component appears directly within the viewed circuit.\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nThe distinction between Unique and Recursive is easiest to\nexplain by considering the 4:1 multiplexer built using three 2:1 multiplexers\nas in the Using subcircuits section.\nThe 2:1 multiplexer contains two AND gates (and the 4:1 circuit includes none),\nso the Unique count\nof AND gates would be 2; but if you were to build the 4:1 multiplexer using this\ndiagram, you would actually need 2 AND gates for each of the three 2:1 multiplexers,\nso the Recursive count is 6.\nIf you are using circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\nOptions...\nOpens the Project Options\nwindow."
  },
  {
    "id": 32,
    "title": "The Simulate menu",
    "url": "/en/html/guide/menu/simulate.html",
    "text": "The Simulate menu\nThe Simulate menu\nSimulation Enabled\nIf checked, circuits viewed will be \"live:\" That is, the\nvalues propagating through the circuit will be updated with each\npoke or change to the circuit.\nThe menu option will be automatically unchecked if\ncircuit oscillation is\ndetected.\nReset Simulation\nClears everything about the current circuit's state, so that it\nis as if you have just opened the file again. If you are viewing a\nsubcircuit's state, the entire hierarchy is cleared.\nStep Simulation\nAdvances the simulation one step forward. For example, a signal may end up\nentering a gate during one step, but the gate won't show a different signal\nuntil the next simulation step. To help identify which points in the overall\ncircuit have changed, any points whose values change are indicated with a blue\ncircle; if a subcircuit contains any points that have changed in it (or its\nsubcircuits, recursively), then it will be drawn with a blue\noutline.\nGo Out To State\nWhen you delve into a\nsubcircuit's state via its pop-up menu, the Go Out To State\nsubmenu lists the\ncircuits above the currently viewed circuit's state. Selecting\none displays the corresponding circuit.\nGo In To State\nIf you have delved into a subcircuit's state and then moved\nback out, this submenu lists the subcircuits below the current\ncircuit. Selecting one of the circuits displays the\ncorresponding circuit.\nTick Once\nSteps one tick forward into the simulation. This can be useful\nwhen you want to step the clocks manually, particularly when the clock\nis not in the same circuit that you are currently viewing.\nTicks Enabled\nStarts automatically ticking the clock. This will have an\neffect only if the circuit contains any clock devices (in the Wiring\nlibrary). The option is disabled by default.\nTick Frequency\nAllows you to select how often ticks occur.\nFor example, 8 Hz\nmeans that ticks will occur eight times a second.\nA tick is the\nbase unit of measurement for the speed of clocks.\nNote that the clock cycle speed will be slower than the tick\nspeed: The fastest possible clock will have a one-tick up cycle\nand a one-tick down cycle; such a clock would have up/down cycle\nrate of 4 Hz if the ticks occur at 8 Hz.\nLogging...\nEnters the logging module, which\nfacilitates automatically noting and saving values in a circuit as a\nsimulation progresses.\nand Help menus."
  },
  {
    "id": 33,
    "title": "The Window and Help menus",
    "url": "/en/html/guide/menu/winhelp.html",
    "text": "The Window and Help menus\nThe Window menu\nMinimize\nMinimizes (iconifies) the current window.\nMaximize (Zoom on MacOS)\nResizes the current window to its preferred size.\nClose\nCloses the current window.\nCombinational Analysis\nShows the current\nCombinational Analysis\nwindow, without changing any of its contents.\nPreferences\nShows the\nApplication Preferences\nwindow.\nindividual window titles\nBrings the respective window to the front.\nThe Help menu\nTutorial\nOpens the help system to the\n\"Beginner's Tutorial\" section of the\nGuide to Being a Logisim User.\nUser's Guide\nOpens the help system to the\nGuide to Being a Logisim User.\nLibrary Reference\nOpens the help system to the\nLibrary Reference.\nAbout...\nDisplays a window containing the version number, mixed among the splash\nscreen graphics. (On MacOS, this menu item is under the Logisim menu.)"
  },
  {
    "id": 34,
    "title": "Memory components",
    "url": "/en/html/guide/mem/index.html",
    "text": "Memory components\nMemory components\nThe RAM and ROM components are two of the more useful\ncomponents in Logisim's built-in libraries. However, because\nof the volume of information they can store, they are also two\nof the most complex components.\nDocumentation about how they work within a circuit can\nbe found on the\nRAM and\nROM pages of the\nLibrary Reference. This section of the User's\nGuide explains the interface allowing the user to view\nand edit memory contents.\nPoking memory\nMemory import/export format\nLogisim's integrated hex editor"
  },
  {
    "id": 35,
    "title": "Poking memory",
    "url": "/en/html/guide/mem/poke.html",
    "text": "Poking memory\nPoking memory\nClicking a RAM or ROM component with the Poke Tool brings keyboard and mouse\nfocus to the component (indicated by a red rectangle), allowing for the contents\nto be viewed or edited. Because Poke Tool editing all takes place within a very\nsmall space, the interface for this is severely but necessarily constrained. For\nall but the simplest editing, it is more convenient to right-click the RAM and\nselect \"Edit Contents...\" to bring up the integrated hex\neditor.\nThe Poke Tool has two modes of operation: You can edit the address displayed,\nand you can edit an individual value at some memory location.\nEditing Addresses: Use the Poke Tool and click anywhere within the\nmemory component but outside the gray box holding the memory contents.\nLogisim will draw a red rectangle around the address at the upper left corner.\nFrom here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the address (assuming the new address\nisn't too large) and scroll the memory contents to show that address.\nScrolling with the mouse wheel increments or decrements the address\nand scrolls the memory forward or backward.\nThe Down (or Enter)\nkey will increment the address and scroll the memory contents forward by one\nrow.\nThe Up (or Backspace\nor Delete) keys will also increment or decrement\nthe address to key will decrement the address and scroll the memory contents\nbackwards by one row.\nThe Page Down (or Space) and Page Up keys will\nincrement or decrement the address to scroll the memory contents forward or\nbackward by one full page.\nEditing Contents: Use the Poke Tool and click anywhere within the\nmemory component within the gray box holding the memory contents.\nLogisim will draw a red rectangle around the memory cell currently being\nedited. From here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the contents of that cell.\nScrolling with the mouse wheel moves up or down to an adjacent memory\ncell.\nThe Up, Down, Left, and Right arrow keys\nmove to an adjacent memory cell.\nThe Page Up and Page\nDown keys move up or down by a full page.\nThe Backspace (or Delete) and Tab (or Space) keys similarly move to the previous or next\nmemory cell."
  },
  {
    "id": 36,
    "title": "Pop-up menus and files",
    "url": "/en/html/guide/mem/menu.html",
    "text": ""
  },
  {
    "id": 37,
    "title": "Hex editor",
    "url": "/en/html/guide/mem/hex.html",
    "text": "Hex editor\nHex editor\nLogisim includes an integrated hex editor for viewing and editing\nthe contents of memory. To access it, bring up a pop-up menu for\nthe memory component and select Edit Contents....\nFor ROM components, which have the memory contents as part of the\nattribute value, you can alternatively access the hex editor by\nclicking the corresponding attribute value.\nThe numbers in italics at left display memory addresses,\nwritten in hexadecimal. The other numbers display values\nstarting from that memory address; the hex editor may display\nfour, eight, or sixteen values per line, depending on what fits\nin the window. To help with counting, each group of four values\nhas a larger space between.\nYou can navigate through memory using the scroll bar or\nusing the keyboard (the arrow keys, home, end, page up, and\npage down). Typing hexadecimal characters will alter the\ncurrently selected value.\nYou can select a range of values by dragging the mouse,\nshift-clicking the mouse, or navigating through memory with\nthe keyboard while depressing the shift key. Values may be\ncopied and pasted using the Edit menu; the clipboard can also be\ntransferred into other applications."
  },
  {
    "id": 38,
    "title": "Logging",
    "url": "/en/html/guide/log/index.html",
    "text": "Logging\nLogging\nIn testing a large circuit, and for documenting a circuit's\nbehavior, a log of past circuit behavior can be useful. This is the purpose for\nLogisim's logging module, which allows you to select components whose\nvalues should be logged; optionally, you can specify a file into which\nthe log should be placed.\nAnother way to test a circuit is using a test vector.\nLogisim's test vector module allows you to load a file specifying\ncircuit inputs and the values that should be output by the circuit.\nLogisim will run the simulation and compare the actual outputs against\nthe desired outputs. Currently, test vectors are only designed to work\nfor combinational circuits.\nNote: The logging and test vector modules are in\nalpha phase; they may be buggy, and they are subject to significant\nchanges in the future. While bug reports and suggestions are welcome\nfor all of Logisim, they are particularly welcome concerning these\nrelatively new features. If you do not send comments, then they will\nlikely not change.\nYou can enter the test vector module via the Test Vector... option\nfrom the Simulate menu. See Test Vectors for\ndocumentation on how to use this module.\nYou can enter the logging module via the Logging...\noption from the Simulate menu. It brings up a window with three tabs.\nWe will discuss each of these tabs separately.\nThe Selection tab\nThe Table tab\nThe File tab\nEach project has only one logging window; when you switch to viewing\nanother circuit within the project, the logging window switches\nautomatically to logging the other circuit instead. That is, it does\nthis unless you are moving up or down\nwithin the same simulation, in which case the logging module does\nnot change.\nNote that when the logging module switches to logging another\nsimulation, it will cease any logging into a file. Should you switch\nback to the simulation again, it will remember the configuration for\nthat simulation, but you will need to re-enable the file logging\nmanually."
  },
  {
    "id": 39,
    "title": "The Selection tab",
    "url": "/en/html/guide/log/selection.html",
    "text": "The Selection tab\nThe Selection tab\nThe Selection tab allows you to select which values\nshould be included in the log. The window below corresponds to the\nfollowing circuit.\nThe tab is divided into three vertical areas. The first (leftmost) is\na list of all components in the circuit whose values can be logged.\nAmong the built-in libraries, the following types of components support\nlogging.\nWiring library: Pin, Probe, and Clock components\nI/O library: Button and LED components\nMemory library: All components except ROM\nFor components which have labels associated with them, their names correspond\nto the labels; other components' names specify their type and their\nlocation within the circuit.\nAny subcircuits will also appear in the list; they cannot be selected\nfor logging, but eligible components within them can be.\nNote that the RAM component requires you to choose which memory\naddress(es) should be logged; it allows logging only for the first 256\naddresses.\nThe last (rightmost) vertical area lists those components that have\nbeen selected. Also, it indicates the radix (base) in which the\ncomponent's multi-bit values\nwill be logged; the radix does not have a significant effect on one-bit\nvalues.\nThe middle column of buttons allows the manipulation of the items\nwithin the selection.\nAdd adds the currently selected item(s) on the left\nside into the selection.\nChange Radix cycles the radix for the currently\nselected component in the selection between 2 (binary), 10 (decimal),\nand 16 (hexadecimal).\nMove Up moves the currently selected component in\nthe selection forward one spot.\nMove Down moves the currently selected component in\nthe selection back one spot.\nRemove removes the currently selected component in\nthe selection."
  },
  {
    "id": 40,
    "title": "The Table tab",
    "url": "/en/html/guide/log/table.html",
    "text": "The Table tab\nThe Table tab\nThe Table tab displays the current log graphically.\nThe table contains a column for each component in the selection. Each\nrow in the table displays a snapshot of the simulation after a\npropagation of values has completed. Any duplicate rows are not added\ninto the log. Note that only the most recent 400 rows are displayed.\nSome rows may have empty entries if the corresponding component was not\nin the selection at the time that the row was computed.\nThe displayed table is for review only; it is not interactive."
  },
  {
    "id": 41,
    "title": "The File tab",
    "url": "/en/html/guide/log/file.html",
    "text": "The File tab\nThe File tab\nThe File tab allows you to specify a file into which the log should\nbe placed.\nAt the top is an indicator of whether file logging is in progress and\na button for enabling or disabling it. (Note that you cannot enable it\nuntil a file is selected below.) The button allows you to pause and\nrestart file entry. When you switch in the project window to viewing\nanother simulation, the file logging is automatically halted; if you\nreturn to the original one and want logging to continue, you will need\nto re-enable the file logging manually using the button at top.\nIn the middle is an indicator of what file is being logged to. To\nchange it, use the Select... button. On selecting a file, file logging\nwill automatically start. If you select a pre-existing file, Logisim\nwill ask whether you want to overwrite the file or append the new\nentries onto the end.\nAt bottom you can control whether a header line should be placed into\nthe file indicating which items are in the selection. If header lines\nare added, then a new header line will be placed into the file whenever\nthe selection changes.\nFile format\nEntries are placed into the file in tab-delimited format\ncorresponding closely to what appears under the Table tab. (One\ndifference is that any header lines will give the full path to\ncomponents lying in subcircuits.) The format is intentionally simple so\nthat you can feed it into another program for processing, such as a\nPython/Perl script or a spreadsheet program.\nSo that a script can process the file at the same time as Logisim\nis running, Logisim will flush the new records onto the disk every\n500 ms. Note that Logisim may also intermittently close and later\nre-open the file during the simulation, particularly if several seconds\nhave elapsed without any new records being added."
  },
  {
    "id": 42,
    "title": "Command-line verification",
    "url": "/en/html/guide/verify/index.html",
    "text": "Command-line verification\nCommand-line verification\nSubsections:\nSubstituting libraries\nOther verification options\nTesting multiple files\nLogisim includes basic support for executing circuits from the command-line.\nThis is intended both to help with scripted verification of circuit designs\nand to help instructors perform automated testing of students' solutions.\nWe'll start by seeing how to execute a circuit from the command line.\nFor our example, we'll suppose we've built the below circuit in a file named adder-test.circ.\nIt uses a two-bit adder as a subcircuit\nand iterates using a counter through all 16 possible inputs to it.\nAfter this circuit has been built, we then execute Logisim from the command line,\nproviding the filename of the project\nand the -tty option with the table parameter.\njava -jar logisim-filename.jar adder-test.circ -tty table\nWithout bringing up any windows, Logisim loads the circuit and begins to execute it,\nticking any clocks as fast as it can while completing the propagation between each tick.\nAfter each propagation is completed, Logisim loads the current values of the output pins;\nif any have changed from the previous propagation,\nthen all values are displayed in tab-delimited format.\nIf there is an output pin labeled with the special word halt,\nits output is not displayed \u2014 but once the pin's value reaches 1 after\na propagation is completed, Logisim ends the simulation.\nFor our example, Logisim displays the table below. Because we have two output\npins corresponding to the two inputs a and b into the\ntwo-bit adder, these outputs are included as the first two columns of the output.\nAnd there is another output pin corresponding to the two-bit adder's output,\nso it is the third column.\nThe columns are ordered left-to-right according to the top-down ordering within\nthe circuit.\n00\n00\n000\n01\n00\n001\n10\n00\n010\n11\n00\n011\n00\n01\n001\n01\n01\n010\n10\n01\n011\n11\n01\n100\n00\n10\n010\n01\n10\n011\n10\n10\n100\n11\n10\n101\n00\n11\n011\n01\n11\n100\n10\n11\n101\n11\n11\n110"
  },
  {
    "id": 43,
    "title": "Substituting libraries",
    "url": "/en/html/guide/verify/sub.html",
    "text": "Substituting libraries\nSubstituting libraries\nNow suppose we have two Logisim circuits that are supposed to do the same thing.\nAs an instructor, you might have had students complete an assignment:\nYou have one file containing your solution, but you have several student files\ncontaining their work. Maybe the assignment was to build a two-bit adder.\nI'll imagine that we have two files, named adder-master.circ\nand adder-query.circ. Each file contains a circuit named\n2-bit adder (it's important that the circuit to test be named exactly the same),\nwhose appearance is the following.\nadder-master.circ\nadder-query.circ\nAs you can see, the master circuit uses Logisim's built-in adder,\nwhile the query circuit uses two subcircuits representing a half adder and\na full adder (which themselves are built up of simple gates).\nFor the purpose of our example, the query circuit has a stupid error:\nThe carry from the half adder is not connected into the full adder.\nWe build our testing circuit into a different file. There, we load\nadder-master.circ as a Logisim Library\n(Project > Load Library > Logisim Library\u2026), and we insert its\n2-bit adder as a subcircuit. We could execute this circuit directly to get\nthe desired output for a perfect solution.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\nBut we want to execute the circuit using adder-query.circ\nrather than adder-master.circ as the loaded library.\nThe naive approach would be to open Logisim and load that library instead;\nor you might simply remove the adder-master.circ file and rename\nadder-query.circ to be named adder-master.circ instead.\nBut Logisim includes a handy -sub option that temporarily replace\none file by another during that session \u2014 without making any changes on disk.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\nThe output you would see from this is shown below; it is of course different\nfrom what we saw in the previous section since now it is\nexecuting using the erroneous adder-query.circ.\n00\n00\n0E0\n01\n00\n0E1\n10\n00\nEE0\n11\n00\nEE1\n00\n01\n0E1\n01\n01\n0E0\n10\n01\nEE1\n11\n01\nEE0\n00\n10\nEE0\n01\n10\nEE1\n10\n10\n1E0\n11\n10\n1E1\n00\n11\nEE1\n01\n11\nEE0\n10\n11\n1E1\n11\n11\n1E0"
  },
  {
    "id": 44,
    "title": "Other verification options",
    "url": "/en/html/guide/verify/other.html",
    "text": "Other verification options\nOther verification options\nThere are a some additional options related to command-line execution.\nThe -load command-line parameter\nA more complex circuit might include a RAM component that needs to\nbe loaded with a program in order for the circuit to have anything to do.\nYou can specify a memory image file at the command line, which will be loaded\ninto any RAM component in the circuit before simulation begins.\n(This does not work when loading the GUI - it is only for command-line execution.)\njava -jar logisim-filename.jar cpu.circ -tty table -load mem-image.txt\nThe order of the parameters is not important (except the table\nparameter must be immediately after -tty, and the memory image's filename\nmust be immediately after -load).\nThe memory image file should be in\nLogisim's memory image format.\nLogisim searches for RAM recursively, so this will still work if RAM is\nnested within a subcircuit.\nThere is no way, though, to distinguish different RAM components:\nLogisim will attempt to load the same file into every RAM that it can find.\nOptions for the -tty parameter\nIn our examples thus far, we've always used -tty\u00a0table\nto indicate that a table of output values should be displayed. You can\ncustomize the behavior in other ways by listing one or more options,\nseparated by commas. For instance, you might write\n-tty\u00a0table,halt,speed,\nand the program will perform all three behaviors listed below.\n(The order in which they are listed does not matter.)\nhalt\nAfter the simulation ends, a one-line message is displayed explaining\nwhy the simulation ended. Error conditions - such as a detected oscillation -\nare displayed in any case.\nspeed\nIf you use speed in conjunction with -tty,\nthen after completing the simulation Logisim will display a summary of\nhow quickly the circuit was simulated, such as:\n714 Hz (509 ticks in 712 milliseconds)\nNote that displaying information during the simulation\nmakes the simulation go much slower. As just one comparison, the same circuit and image\nran at 714\u00a0Hz above with just the speed option\nbut 490\u00a0Hz with the table option as well.\nstats\nShows a tab-delimited table containing statistics about components\nused by the top-level main circuit in the project. The table includes\nfour columns:\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nThe distinction between Unique and Recursive is explained\nfurther under Project menu section.\nIf the file uses circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\n(This feature can be useful for instructors who assign students to build\nprojects using a subset of Logisim's libraries.)\ntable\n(as already discussed)\ntty\nAny TTY components send their output to the display (standard output),\nand any information typed at the keyboard is sent to all Keyboard components\nin the circuit.\nThese components are included even if they are nested deeply\nin the subcircuit hierarchy."
  },
  {
    "id": 45,
    "title": "Testing multiple files",
    "url": "/en/html/guide/verify/multi.html",
    "text": "Testing multiple files\nTesting multiple files\nIn the classroom example, you will have many files that you wish to test\nfor their equivalence, and you won't want to read the output for each\nof the student's solutions.\nBuilding comparison into the circuit\nOne approach is to build a test circuit that does the comparison directly.\nHere, we create an additional circuit within the testing file that contains\nour solution circuit. In our overall testing circuit, we include both the\nsubcircuit from adder-master.circ and the subcircuit from the solution\ncircuit located directly into the nested circuit. We wire it so that there is\njust one output, which is 1 as long as the two subcircuits agree.\nNow we can simply run Logisim substituting each query file. For any correct\nsolution, the only output will be 1.\nUsing redirection and shell scripts\nIf you're quite comfortable with the command line,\nyou can build your own shell script to accomplish this.\nHere, we'll use redirection (the > operator) to save the output of each\ncircuit into a file.\nFor instance, we might issue the following two commands to collect the output\nof the master circuit and the query circuit.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0>\u00a0output-master.txt\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\u00a0>\u00a0output-query.txt\nNow we've created two different files.\nWe can then compare the two output files using a program built for that purpose.\nUnder Linux or MacOS X, you might want to use the cmp or diff\ncommand-line utilities. Under Windows, you might want to use WinMerge.\nTo process several query files, you would like want to build a simple program\nsuch as a shell script to iterate through each and comparing the output.\nHere is how I would do it under Linux's bash:\nRUN_TEST=\"java\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\"\n${RUN_TEST}\u00a0>\u00a0output-master.txt\nfor\u00a0QUERY_FILE\u00a0in\u00a0adder-query*.circ\ndo\nif\u00a0${RUN_TEST}\u00a0-sub\u00a0adder-master.circ\u00a0${QUERY_FILE}\u00a0|\u00a0cmp\u00a0-s\u00a0output-master.txt\nthen\necho\u00a0\"${QUERY_FILE}\u00a0OK\"\nelse\necho\u00a0\"${QUERY_FILE}\u00a0different\"\nfi\ndone"
  },
  {
    "id": 46,
    "title": "Test Vectors",
    "url": "/en/html/guide/log/test.html",
    "text": "The Test Vector window\nThe Test Vector window\nThe Test Vector window is similar to the Table tab of the Logging\nwindow. You can load a test vector from a file, and Logisim will start\nrunning tests on the current circuit. Like the logging window, there\nis only one test vector window for the project, and the table will\nchange to reflect whichever circuit is being simulated in the project\nwindow. Note, however, that the Test Vector module runs a separate\ncopy of the circuit simulator, and so does not interfere with, and is\nnot influenced by, the simulation in the project window.\nAny incorrect outputs will be flagged in red. Hover the mouse over\nthe red box to see what the output should have been, according to the\ntest vector. Rows with incorrect outputs are sorted to the top of the\nwindow.\nThe file format is simple. You can use the Logging module (with\n\"Include Header Line\" selected in the file output tab) to get started,\nsince in most cases the Logging module outputs the same format as used\nby the Test Vector module.\nHere is an example test vector file:.\n# my test vector for add32\nA[32] B[32] C[32] Cin Cout\n00000000000000000000000000000000\n00000000000000000000000000000000\n00000000000000000000000000000000\n0\n0\n-2\n0x00000005\n3\n0\n0\n0\n0o0003\n3\n0\n0\nBlank lines are ignored.\nAnything following a '#' character is a\ncomment.\nThe first non-blank, non-comment line lists the name of each\ncircuit input pin and its width (if > 1), separated by whitespace.\nThe remaining lines list each value separated by whitespace. The\nvalues can be in hex, octal, binary, or signed decimal. Hex values\nmust have a '0x' prefix. Octal values must have a '0o' prefix.\nBinary and decimal are be\ndistinguished by the number of digits: binary values must always have\nexactly as many digits as the width of the column; decimal values must\nalways have fewer, should not have leading zeros, and may have a\nnegative sign.\nFor hex, octal, and binary values, a digit of 'x' specifies four,\nthree, or one \"don't care\" bits. So the value 101xx is a five bit\nbinary value, with the last two bits unspecified, and 0x1ax5 is a hex\nvalue with four unspecified bits.\nSuch \"don't cares\" can not be used\nin decimal notation.\nCommand line: To facilitate automated testing, the\ntest vector feature can be run from the command line, as follows:\nlogisim -test <circuitname> <vector.txt> <project.circ>"
  },
  {
    "id": 47,
    "title": "Application preferences",
    "url": "/en/html/guide/prefs/index.html",
    "text": "Application Preferences\nApplication Preferences\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses application preferences;\nproject options are described in another\nsection.\nYou can view and edit application preferences via the Preferences...\noption from the File menu (or, under Mac OS, the Logisim menu),\na window will appear with several tabs.\nWe will discuss these tabs\nseparately, and then we will see how preferences can be configured\nfrom the command line.\nThe Template tab\nThe International tab\nThe Window tab\nThe Layout tab\nThe Experimental tab\nThe command line"
  },
  {
    "id": 48,
    "title": "The Template tab",
    "url": "/en/html/guide/prefs/template.html",
    "text": "The Template tab\nThe Template tab\nA template is a Logisim file that is used as a starting\npoint whenever Logisim creates a new project. Also, if you have an\nexisting Logisim file with a strangely configured environment, you\ncan \"reset\" the environment using the Revert All To Template\nbutton in the window for editing Project Options.\nAlthough templates are useful in other situations also, they are\nparticularly suited for classroom use, where an instructor might\nwant to distribute a template for students to start from. This is\nparticularly likely if the class uses Logisim heavily, including\nmany of the more advanced features, in which case the simple default\nconfiguration may prove too simple. Templates can also be useful in\nthe classroom setting when the instructor opens a file submitted by\na student who has configured the environment significantly.\nBy default, the \"Plain template\" option will be selected,\nusing the default template shipped with Logisim. If you want a\nbare-bones configuration, you might choose \"Empty template.\"\nBut if you want to designate another file to use as the template,\nselect a template via the Select...\nbutton, and then choose the\n\"Custom template\" option."
  },
  {
    "id": 49,
    "title": "The International tab",
    "url": "/en/html/guide/prefs/intl.html",
    "text": "The International tab\nThe International tab\nThis tab allows configuration of Logisim according to\nregional preferences.\nGate shape: Logisim supports three standards for drawing gates:\nshaped gates, rectangular gates, and DIN 40700\ngates. The following table illustrates the\ndistinction.\nShaped\nRectangular\nDIN 40700\nAND\nOR\nBecause the shaped style tends to be more popular in the U.S., while the\nrectangular style tends to be more popular in Europe, some people refer to\nthese styles according to these regions; but the region-neutral terms\nshaped and rectangular are preferred.\nThe DIN 40700 standard was a standard for drafting digital and analog\nelectronic components adopted by DIN, a German standards organization. DIN\nadopted the rectangular standard for digital components in 1976, but some\nengineers continue to use the older style; they appear to be increasingly\nrare.\nLogisim does not follow any standard exactly; it steers a middle\nground to allow switching between them. In particular, the shaped gates\nare more square than the dimensions defined by the relevant IEEE\nstandard. And, although XOR and XNOR gates really ought to be the same\nwidth as OR and NOR gates with the rectangular style, they are not\nbecause of difficulties compressing the shaped-XOR gate.\nLanguage:\nChange between languages. The current version is supplied with\nEnglish, Spanish, Russian, and German translations.\nThe German translation was introduced with Logisim 2.6.1 and remains current.\nIt is by Uwe Zimmermann, a faculty member at Uppsala University in Sweden.\nThe Greek translation was introduced with Logisim 2.7.0 and remains current.\nIt is by Thanos Kakarountas, a faculty member at Technological Educational Institute of Ionian Islands in Greece.\nThe Portuguese translation was introduced with Logisim 2.6.2 and remains current.\nIt is by Theldo Cruz Franqueira, a faculty member at Pontif\u00edcia Universidade Cat\u00f3lica de Minas Gerais in Brazil.\nThe Russian translation was introduced with Logisim 2.4.0 and remains current.\nIt is by Ilia Lilov, from Russia.\nThe Spanish translation was complete as of Logisim 2.1.0,\nbut subsequent Logisim versions have added new options that remain untranslated.\nIt was contributed by Pablo Leal Ramos, from Spain.\nTranslations of Logisim into other languages are welcome! If you\nare interested, contact me, Carl Burch. This will not be a commitment:\nI will be happy to hear of your interest, and I will tell\nyou whether I know of somebody who is working on it already,\nprepare a version for you to work with, and send you instructions.\nThe translation process does not require an understanding of Java.\nReplace accented characters:\nSome platforms have poor support for characters (such as\n\u00f1 or \u00f6) that do not appear in the 7-bit ASCII character\nset. When this is checked, Logisim will replace all instances of the\ncharacters with the appropriate equivalent 7-bit ASCII characters.\nThe checkbox is disabled when the current language does not have\nany equivalents available (as with English)."
  },
  {
    "id": 50,
    "title": "The Window tab",
    "url": "/en/html/guide/prefs/window.html",
    "text": "The Window tab\nThe Window tab\nThis tab includes preferences affecting the appearance of the main window used\nfor Logisim.\nShow tick rate: If checked, then when ticks are enabled, Logisim\ndisplays a measurement of the rate at which it has been able to complete ticks.\nThe tick rate is measured by averaging over the previous 1,000 ticks.\n(Disabling ticks or changing the maximum tick rate will clear its history.)\nThis actual tick rate may be much less than the selected tick rate, because\nLogisim cannot simulate larger circuits at a very fast rate. For example,\nLogisim's maximum speed for a\nreasonably large circuit might be 16 Hz; you can select a faster tick rate,\nbut the actual speed will not exceed 16 Hz.\nToolbar location: This drop-down menu configures the location of\nthe toolbar within the overall window. The toolbar may be placed\non any of the window's four borders, described as north, south,\neast, and west. It may also be hidden, or it can be placed \"down the\nmiddle\" - that is, to the left of the canvas but to the right of\nthe explorer pane and attribute table."
  },
  {
    "id": 51,
    "title": "The Layout tab",
    "url": "/en/html/guide/prefs/layout.html",
    "text": "The Layout tab\nThe Layout tab\nThis tab includes preferences affecting\nthe behavior of the circuit layout editor.\nPrinter view: Specifies whether\nto display the circuit on the screen in the same way it is displayed\nthrough the printer. Normally this is off, and Logisim displays the on-screen\ncircuit with indications of the current circuit state, and it displays some\nhints about component interface (most notably, it draws legs on OR\ngates to indicate where they would connect). The printer view, though,\nomits indications of state, and it omits such interface hints.\nShow attribute halo: Specifies whether to draw the pale teal oval\naround the component or tool whose attributes are currently displayed in\nthe attribute table.\nShow component tips: Specifies\nwhether to display the \"tool tips\" that will temporarily appear when\nthe mouse hovers over components supporting them. For example, if you hover\nover a subcircuit component's pin, it will display the label of the\ncorresponding pin within the subcircuit. Hovering over one of the\nends of a splitter will tell you the bits to which that end corresponds.\nIn addition, all components in the Plexers, Arithmetic, and Memory libraries will\nprovide information about their inputs and outputs via tips.\nKeep connections while moving: Indicates whether\nLogisim should add new wires when components are moved\nto preserve their connections. By default this is on \u2014 though it can\nbe turned off temporarily by pressing the shift key while moving the components.\nIf this box is unchecked, then the default will be not to add wires during a move\n\u2014 though you can turn it on temporarily by pressing the shift key during the move.\nShow Ghosts while adding: When checked, and when a tool for adding\na new component is selected, a light-gray outline of a component to be added\nis drawn as the mouse moves across the canvas. For example, if you select\nthe AND gate tool and move the mouse into the window (without\npressing the mouse's button), a gray outline of an AND gate will display\nwhere the AND gate will appear when the mouse is clicked.\nAfter adding component: By default, after adding each individual\ncomponent, Logisim switches back to the Edit Tool to allow you to move\ncomponents around and to add wires. The drop-down box allows you to change this\nbehavior so that Logisim stays at the same tool for adding more of the same\ncomponent, until you yourself opt to choose the Edit Tool. (This was Logisim's\ndefault behavior prior to Logisim 2.3.0. While more intuitive, this behavior\nrequires more mouse movement to switch between tools.)\nFirst radix when wire poked:\nConfigures how values are displayed when a wire is clicked using the Poke Tool.\nClicking a wire displays temporarily the value, staying until the user clicks\nelsewhere in the circuit.\nSecond radix when wire poked:\nConfigures the second part of how wire values are displayed."
  },
  {
    "id": 52,
    "title": "The Experimental tab",
    "url": "/en/html/guide/prefs/exp.html",
    "text": "The Experimental tab\nThe Experimental tab\nThese preferences enable features that are considered experimental,\ninserted to garner user feedback.\nGraphics acceleration: One Logisim user observed\nthat adding -Dsun.java2d.d3d=True to the command line seemed\nto improve Logisim's graphics performance by telling it to use hardware graphics\nacceleration. This drop-down box attempts to\nconfigure Logisim to set this up; reports about whether this drop-down box has\nany effect on performance would be welcome. It won't have\nany effect until Logisim is restarted."
  },
  {
    "id": 53,
    "title": "The command line",
    "url": "/en/html/guide/prefs/cmdline.html",
    "text": "Command-line options\nCommand-line options\nYou can configure many of Logisim's application preferences via command\nline options.\nThis can be particularly useful in a laboratory of\nsingle-student computers where you want Logisim to start up the same\nfor students every time, regardless of how previous students may have\nconfigured the program.\nThe overall command-line syntax is as follows.\njava -jar jarFileName [options] [filenames]\nThe optional additional files named on the command line will be\nopened as separate windows within Logisim.\nThe following example starts Logisim in its basic configuration.\njava -jar jarFileName -plain -gates shaped -locale en\nSupported options include the following.\n-plain\n-empty\n-template templateFile\nConfigures the template for Logisim to use.\n-gates [shaped|rectangular]\nConfigures which type of gate to use.\n-locale localeIdentifier\nConfigures which translation to use. As of this writing, the\nsupported locales include:\ndeGerman\nenEnglish\nesSpanish\nruRussian\nelGreek\n-accents [yes|no]\nThis is only relevant for languages that use characters\noutside the 7-bit ASCII character set; this would include\nlanguages using accented characters, and it would not\ninclude English.\nIf no, characters outside the 7-bit ASCII character\nset are replaced with equivalents appropriate to the language;\nthis would be useful for Java/OS combinations where such characters\nare not supported well.\n-clearprops\nClear all application preferences at startup, so Logisim will act as\nif it were being executed on the host system for the first time.\n-nosplash\nHides the initial Logisim splash screen.\n-help\nDisplays a summary of the command line options.\n-version\nDisplays the Logisim version number."
  },
  {
    "id": 54,
    "title": "Project options",
    "url": "/en/html/guide/opts/index.html",
    "text": "Project Options\nProject Options\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses project options;\napplication preferences are described in another\nsection.\nYou can view and edit project options via the Options...\noption from the Project menu. It brings up the Options window\nwith several tabs.\nWe will discuss each of these tabs separately.\nThe Simulation tab\nThe Toolbar tab\nThe Mouse tab\nAt the bottom of the window is the Revert All To Template\nbutton. When clicked, all the options and tool attributes change\nto the settings in the current template (as selected under the\napplication preferences)."
  },
  {
    "id": 55,
    "title": "The Simulation tab",
    "url": "/en/html/guide/opts/simulate.html",
    "text": "The Simulation tab\nThe Simulation tab\nThe Simulation tab allows configuration of the algorithm used for\nsimulating circuits. These parameters apply to all circuits being\nsimulated in the same window, even for circuits that exist in other\nlibraries loaded within the project.\nThe Iterations Until Oscillation drop-down menu\nspecifies how long to simulate a circuit before deciding that it is\noscillating. The number represents the number of clicks of the internal\nhidden clock (a simple gate takes just one click). The default of 1,000\nis good enough for almost all purposes, even for large circuits. But you\nmay want to increase the number of iterations if you are working with a\ncircuit where Logisim reports false oscillations. This is unlikely to be a\nproblem in practice, but one such a circumstance is a circuit that incorporates\nmany of the below latch circuits with random noise enabled. You may want to\ndecrease the number of iterations if you are working with a circuit that is\nprone to oscillating and you are using an unusually slow processor.\nThe Gate Output When Undefined drop-down menu configures\nhow the built-in logic gates behave when some inputs are unconnected or are\nfloating. By default, Logisim ignores such inputs, allowing a gate to work over\nfewer inputs than it was designed for. However, in real life, a gate will behave\nunpredictably in such a situation, and so this drop-down menu allows one to\nchange the gates so that they treat such disconnected inputs as errors.\nThe Add Noise To Component Delays checkbox\nallows you to enable or disable the random noise that is added to the\ndelays of components. The internal simulation uses a hidden clock for\nits simulation, and to provide a somewhat realistic simulation, each\ncomponent (excluding wires and splitters) has a delay between when it\nreceives an input and when it emits an output. If this option is\nenabled, Logisim will occassionally (about once every 16\ncomponent reactions) make a component take one click longer than\nnormal.\nI recommend keeping this option off, as this technique does introduce rare\nerrors with normal circuits."
  },
  {
    "id": 56,
    "title": "The Toolbar tab",
    "url": "/en/html/guide/opts/toolbar.html",
    "text": "The Toolbar tab\nThe Toolbar tab\nThe Toolbar tab allows you to configure what tools appear in\nthe toolbar.\nThe left side is an explorer listing all the tools available,\nand the list on the right side displays the current contents of the\ntoolbar.\n(Three dashes \"---\" indicate a\nseparator, which is drawn as a gray line.)\nBetween the explorer and the list are five buttons and a combo box:\nAdd Tool adds the currently selected\ntool in the explorer at left to the end of the toolbar.\nAdd Separator adds a separator\nto the end of the toolbar.\nMove Up moves the currently selected\nitem of the toolbar up/left one spot.\nMove Down moves the currently selected\nitem of the toolbar down/right one spot.\nRemove removes the currently selected\nitem from the toolbar.\nThe attributes associated with the tools are not displayed in\nthis window; instead, you can view and edit them within the main\ndrawing window."
  },
  {
    "id": 57,
    "title": "The Mouse tab",
    "url": "/en/html/guide/opts/mouse.html",
    "text": "The Mouse tab\nThe Mouse tab\nBy default, when you click the mouse in Logisim's drawing area,\nthe currently selected tool will be used. If you right-click or\ncontrol-click, it will display a pop-up menu for the current component\nbelow the mouse.\nLogisim allows you to modify this behavior, relieving you of the\nneed to go to the toolbar and/or the explorer all the time.\n(This may\nalso be handy if you are left-handed.) Each combination of a mouse\nbutton and a modifier key (any subset of shift, control, and alt) can be mapped to a\ndifferent tool.\nThe Mouse tab allows you to configure these mappings.\nOn the left side is an explorer where you can choose the tool\nyou want to map.\nOn the right top side is a rectangle in which you can click\nusing the mouse combination you want to click. For example, if you\nwant to create new wires by shift-dragging, then you would first\nselect the Wiring Tool in the Explorer (under the Base library); and\nthen you would shift-click where it says \"Click Using Combination\nTo Map Wiring Tool.\" If that combination is already being used,\nthen the mapping would be replaced with the new tool.\nBelow this area is a list of current mappings.\nNote that\nany combinations that aren't listed simply use the currently selected\ntool.\nBelow is the Remove button, where you can delete the mapping\nthat is currently selected in the table above the button.\nIn the\nfuture, then, that mouse combination would map to whatever tool\nis currently selected in the toolbar or the explorer pane.\nBelow this is a list of attributes for the tool currently selected\nin the list of mappings. Each mouse-mapped tool has its own set of\nattributes, different from the attributes used in the explorer pane\nand in the toolbar. You can edit those attribute values here."
  },
  {
    "id": 58,
    "title": "Value propagation",
    "url": "/en/html/guide/prop/index.html",
    "text": "Value propagation\nValue propagation\nLogisim's algorithm for simulating the propagation of values through\ncircuits is not something that you normally need to worry about. Suffice\nit to say that the algorithm is sophisticated enough to account for gate\ndelays, but not realistic enough to account for more difficult\nphenomena like varying voltages or race conditions.\nDo you still want to know more?\nGate delays\nOscillation errors\nShortcomings"
  },
  {
    "id": 59,
    "title": "Gate delays",
    "url": "/en/html/guide/prop/delays.html",
    "text": "Gate delays\nGate delays\nAs an example of the level of sophistication of Logisim's algorithm,\nconsider the following circuit.\nThis \"obviously\" always outputs 0. But NOT gates don't react\ninstantaneously to their inputs in reality, and neither do they in\nLogisim. As a result, when this circuit's input changes from 0 to 1, the\nAND gate will briefly see two 1 inputs, and it will emit a 1 briefly.\nYou won't see it on the screen. But the effect is observable when we\nuse the AND gate's output as an input into the clock of a D flip-flop.\nPoking the 0 input to become 1 leads to an instantaneous 1 going\ninto the D flip-flop, and thus the flip-flop's value will toggle\nevery time the circuit input goes from 0 to 1.\nEvery component has a delay associated with it. More sophisticated\ncomponents built into Logisim tend to have larger delays, but\nthese delays are somewhat arbitrary and may not reflect reality.\nFrom a technical point of view, it is relatively easy to deal with\nthis level of sophistication in a single circuit.\nDealing with gate\ndelays well across subcircuits, though, is a bit more complex;\nLogisim does attempt to address this correctly by placing all primitive\ncomponent's propagation values into a single schedule regardless of the\nsubcircuit in which the component lies.\n(Via the Project Options window's\nSimulation tab, you can configure Logisim\nto add a random, occasional delay to a component's propagation. This is intended\nto simulate the unevenness of real circuits. In particular, an R-S latch built\nusing two NOR gates will oscillate without this randomness, as both gates will\nprocess their inputs in lockstep. This randomness is disabled by default.)\nNote that I'm stopping short of saying that Logisim\nalways addresses gate delays well.\nBut at least it tries."
  },
  {
    "id": 60,
    "title": "Oscillation errors",
    "url": "/en/html/guide/prop/oscillate.html",
    "text": "Oscillation errors\nOscillation errors\nThe propagation algorithm, which normally works silently without any\nproblems, will become very visible\nwhen you create a circuit that oscillates.\nThis circuit is currently in a stable condition. But if you change the\ninput to 1, the circuit will effectively enter an infinite loop. After\na while, Logisim will simply give up and show an \"Oscillation apparent\" message\ntelling you that it believes that the circuit is oscillating.\nIt will display the values it has at the time it gives up. These values\nwill look wrong - in this screen shot, the AND gate is emitting 1\nalthough one of its inputs is 0, but it could be that the NOT gate\nhas a 1 input and a 1 output.\nLogisim helpfully circles in red each location that seems to be\ninvolved in the oscillation. If an involved point lies within a\nsubcircuit, Logisim will draw that subcircuit's outline in red.\nWhen Logisim detects oscillation, it shuts down all\nfurther simulation. You can re-enable simulation using the\nSimulate menu's Simulation Enabled option.\nLogisim detects oscillation using a fairly simple technique: If the\ncircuit simulation seems to many iterations, then it will simply give up\nand report oscillation. (The points it identifies as being involved are\nthose that were touched in the last 25% of the iterations.)\nThus, it could erroneously report oscillation,\nparticularly if you are working with an exceptionally large circuit; but\nit would be one that is larger than any I have built using Logisim.\nIn any case, if you are confident that the reporting is in error, you\ncan configure the number of iterations\ncompleted before oscillation occurs via the\nProject Options window's\nSimulation tab."
  },
  {
    "id": 61,
    "title": "Shortcomings",
    "url": "/en/html/guide/prop/shortcome.html",
    "text": "Shortcomings\nShortcomings\nLogisim's propagation algorithm is more than sophisticated enough\nfor almost all educational purposes; but it is not sophisticated\nenough for industrial circuit design. In order from most damning to\nleast damning, the shortcomings of Logisim's propagation technique\ninclude:\nExcept for the issue of gate delays, Logisim does not particularly\nconcern itself with timing issues. It is very idealized, so that a pair of NOR\ngates in an S-R latch configuration will toggle in lockstep infinitely, rather\nthan the circuit eventually settle into a stable state.\nLogisim cannot simulate subcircuits whose pins sometimes behave\nas inputs and sometimes behave as outputs. Components built using\nJava can have such pins, though: Within the built-in libraries,\nthe Memory library's RAM circuit contains a D pin that can act both\nas an input and as an output.\nLogisim cuts off its simulation after a fixed number of iterations\nassuming that there is an oscillation error.\nConceivably, a large circuit that does not oscillate could lead to\ntrouble.\nLogisim does nothing with respect to discriminating between\nvoltage levels: A bit can be only on, off, unspecified, or error.\nThere are additional shortcomings, too, that I have omitted because\nthey are so obscure that if you were aware of them, it would be obvious\nthat Logisim comes nowhere close to that level. As an extreme example,\nI have a friend who works for a major chip manufacturer, and his\njob is to worry about \"bubbles\" in chips' nanometer-wide wires growing\nand leading to random disconnection.\nEven beyond this, I am not a circuit design specialist; thus,\nthere may well be errors in the propagation technique of which I am\nnot aware. I welcome corrections from experts."
  },
  {
    "id": 62,
    "title": "HDL IP",
    "url": "/en/html/guide/hdl_ip/index.html",
    "text": "HDL IP\nHDL IP\nIn Logisim, you can use VHDL to create new components called\nVHDL entities. Those components can then be used in the\nsimulator, providing you have Questa Advanced Simulator installed\nand configured adequately.\nSee below for more information about the VHDL entities and how to use\nthem in a simulation context.\nVHDL Entity\nConfiguring Questa Advanced Simulator\nVHDL simulator\nSimulating test benchs"
  },
  {
    "id": 63,
    "title": "VHDL Entity",
    "url": "/en/html/guide/hdl_ip/vhdlcomp.html",
    "text": "VHDL Entity\nVHDL Entity\nA VHDL entity is a component that can be described using VHDL. It\ncomes with an editor which can be used to edit the entity and to\nvalidate it, providing you have Questa Advanced Simulator installed\non your system.\nCreating a VHDL entity\nTo create a new VHDL entity, simply open the HDL IP library in\nthe explorer panel and click on the VHDL Entity\ncomponent. If the library is not available, you will need to load it:\ngo to the Project menu, Load Library then Build-in\nLibrary and select HDL IP from the menu.\nEditing a VHDL entity\nA new VHDL entity comes with a default template which contains two\ninputs and two outputs. The entity can be edited by clicking on the\ncontent attribute, as shown below.\nThe integrated HDL editor can then be used to modify the entity using\nVHDL directly. You can also import the content of a VHDL file by\nclicking the Import... button, or export your own code by\nclicking the Export... button.\nAs you edit your component, the Validate Content button will\nlight up. It can be used to check if your code is valid, as long as\nyou have Questa Advanced Simulator installed and configured (see\nConfiguring Questa Advanced Simulator for\nmore information). If it is the case, clicking the Validate\nbutton will compile the VHDL code, check for errors and display a\nwindow with more information if any is found. If your code is valid,\nthe button will simply be deactivated until you make further\nmodifications.\nNote: If you don't have Questa Advanced Simulator,\nor if it is disabled, Logisim will nonetheless make a few checks,\nmostly on the ports description.\nWhen you are done editing your entity, you can click the Close\nWindow button. The code will be validated by Questa Advanced\nSimulator if it is installed and enabled, and Logisim will\nautomatically regenerate your entity's symbol, adding, removing or\nupdating any port you might have added, removed or changed in your\ncode. If an error occurs during the validation process, a window\ncontaining more information will be displayed, and you will be given\nthree choices:\nClose anyway and discard all modifications.\nThis is achieved by clicking Yes. Please note any changes\ndone to your entity will be permanently lost.\nGo back to the editor and correct the error(s). This is achieved\nby clicking No.\nCreate a backup of your VHDL code and close the editor. This is\nachieved by clicking the Create backup button, and then\nby selecting a folder and a name for your backup file.\nUsing a VHDL entity\nA VHDL entity is used like any other component. The only notable\ndifference is how the entities are handled in the simulation. Please\nsee VHDL simulator for a detailed\nexplanation.\nAdvanced Simulator."
  },
  {
    "id": 64,
    "title": "Configuring Questa Advanced Simulator",
    "url": "/en/html/guide/hdl_ip/questa.html",
    "text": "Configuring Questa Advanced Simulator\nConfiguring Questa Advanced Simulator\nQuesta Advanced Simulator can be optionally used to validate VHDL\nentities, and is required for any simulation using a VHDL entity.\nBy default, the VHDL validation with Questa Advanced Simulator is\ndisabled. In order to active it, you need to go in the Window\nmenu, Perferences and then in the Third Party Softwares\ntab. You can then enable the validation by clicking on the Use\nQuesta Advanced Simulator to validate VHDL entities checkbox.\nRight below that option, you can also set the path to your Questa\nAdvanced Simulator installation directory. In order to do so, simply\nclick the Browse... button and select the corresponding\ndirectory. If you activate the validation but do not set the path,\nyou will be prompted to select it the next time a VHDL validation\noccurs.\nNote: You will also be prompted for the path if you\ntry to run a simulation of a circuit that includes a VHDL entity."
  },
  {
    "id": 65,
    "title": "VHDL simulator",
    "url": "/en/html/guide/hdl_ip/simulation.html",
    "text": "VHDL simulator\nVHDL simulator\nLogisim cannot directly perform VHDL content simulation. Instead,\nQuestaSim is used as a background task.\nEnable simulator\nYou can enable the simulator through the Simulate > VHDL\nSimulation Enabled menu. When you do this, the simulator console\nlog appears on the bottom of the drawing pane. At the bottom bar of\nthe simulator log, you have the simulator status indicator. The\nstates are :\nDisabled (console disappears)\nEnabled (but inactive)\nStarting\nActive\nThe simulator starts automatically when it's enabled and the circuit\ncontains VHDL components. It is not possible to start the simulator\nwhen there aren't any VHDL components in the circuit.\nRestart\nThe VHDL simulation is restarted when you reset the Logisim\nsimulation. This concerns only the simulation state, it does not\nreload the simulation (and the source files).\nIf you have changed the content of some VHDL component you have to\nrestart the VHDL simulator. This is never done automatically. You can\nrestart the simulator through the Simulate menu.\nTime\nThe QuestaSim simulation step time has to be considered\nunpredictable, as it depends on the number of VHDL components in the\ncircuit. The absolute minimum step is 100ns. Therefore, usage of\ntime-based simulation events must be avoided (like wait for\n10ns). You must only have signal-based events.\nMultiple instances\nActually, you can only have a single instance of VHDL simulator.\nThat means that you have to disable it on the first project if you\nwant to have it enabled on a second one. If you try to enable it on\ntwo projects it will fail and show you an error message.\nbenchs."
  },
  {
    "id": 66,
    "title": "Simulating test benchs",
    "url": "/en/html/guide/hdl_ip/testbenchs.html",
    "text": "Simulating test benchs\nSimulating test benchs\nYou can add a test bench to your circuit to test it, but you have to\nconsider the following restrictions due to the simulation\narchitecture.\nSimulation must be driven by Logisim\nYou cannot add event generating elements to your test bench, for\nexample, you cannot add a clock generator process. Your test bench\nmust take an external clock from Logisim as input.\nDon't use time based conditions\nThe time representation does not exist in Logisim, no you cannot have\nevent based on time, for example wait for 5 ns. If you want to\nmake asynchronous verification, you must add a sysclk who has\nat least twice the frequency of the mainclk. This way, you will be\nable to check the signals not only on the main clock rising edges but\nat any time you need.\n."
  },
  {
    "id": 67,
    "title": "JAR libraries",
    "url": "/en/html/guide/jar/index.html",
    "text": "JAR Libraries\nJAR Libraries\nUsing JAR libraries\nLogisim has two types of circuit components: those that\nare designed within Logisim as combinations of components, and those\nprimitive components that are written in Java. Logisim circuits are easier to design, but\nthey cannot support sophisticated user interaction, and they\nare relatively inefficient.\nLogisim contains a fairly thorough collection of built-in\nlibraries of Java components, but it can also load additional\nlibraries written by you or others. Once you have downloaded\na library, you can import it into your project by right-clicking\nthe project in the explorer pane (the top line) and choosing\nLoad Library > JAR Library.... Then, Logisim will prompt you to select the JAR file.\n(In some circumstances, you may have to type the starting class name when\nprompted, which would be provided by the library developer. However, a developer\ntypically configures the JAR library to avoid this (by including a\nmanifest file in the JAR with a Library-Class attribute\nspecifying the main class name).)\nCreating JAR libraries\nThe remainder of this section is dedicated to a series of\nthoroughly commented examples illustrating how to develop Logisim\nlibraries yourself. You should only attempt this if you're\nan experienced Java programmer. You will find the documentation\nbeyond these examples fairly meager.\nYou can download a JAR file that allows these examples to be\nimported into Logisim via the Logisim Web site's Links section.\nThat JAR file also contains the source code\ncontained in these examples.\nGray Code Incrementer\nIllustrates the essential components of any component type\nusing a simple example of a component that takes a multibit input\nand computes the next Gray code value following it.\nLibrary Class\nIllustrates how to define a library. This is the entry point\nfor any JAR file - the class whose name the user enters when\nloading the JAR library.\nSimple Gray Code Counter\nIllustrates how to make a component that has internal state,\nin particular an 8-bit counter that iterates through Gray codes.\nGray Code Counter\nDemonstrates a complete, fairly sophisticated component with\nwhich the user can interact. It implements a Gray code counter where the\nnumber of bits remembered is customizable, and where the user can\nedit the current value by clicking on it with the Poke Tool and\ntyping a value.\nGuidelines\nGeneral information for those developing third-party libraries.\nLicense\nThe code in this example JAR library is released under the MIT license,\na more permissive license than the GPL, under which the rest of Logisim is\nreleased.\nCopyright (c) 2009, Carl Burch.\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "id": 68,
    "title": "Gray Code Incrementer",
    "url": "/en/html/guide/jar/incr.html",
    "text": "Gray Code Incrementer\nGray Code Incrementer\nEach component included in a library is defined by creating a subclass of\nInstanceFactory found in the\ncom.cburch.logisim.instance package. This subclass has all\nthe code involved\n(Here we're describing the API for the current version of Logisim.\nYou may find some libraries developed for older versions of Logisim, in\nwhich components were developed by defining two classes, one extending\nComponent and another extending ComponentFactory.\nVersion 2.3.0 introduced the much simpler InstanceFactory API; the\nolder technique is deprecated.)\nThree Logisim packages define most of the classes relevant to defining\ncomponent libraries.\ncom.cburch.logisim.instance\nContains classes specifically related to defining components,\nincluding the InstanceFactory, InstanceState,\nInstancePainter, and Instance classes.\ncom.cburch.logisim.data\nContains classes related to data elements associated with components,\nsuch as the Bounds class for representing bounding rectangles\nor the Value class for representing values that can\nexist on a wire.\ncom.cburch.logisim.tools\nContains classes related to the library definition.\nAbout Gray codes\nBefore we go on, let me briefly describe the Gray code on which these\nexamples are based. It's not really important to understanding how these\nexamples work, so you can safely skip to the code below if you wish -\nparticularly if you already know Gray codes.\nGray code is a technique (named after Frank Gray) for iterating through\nn-bit sequences with only one bit changed for each step. As an\nexample, consider the 4-bit Gray code listed below.\n0000\n0001\n0011\n0010\n0110\n0111\n0101\n0100\n1100\n1101\n1111\n1110\n1010\n1011\n1001\n1000\nEach value has the bit underlined that will change for the next value in\nthe sequence. For example, after 0000 comes 0001, in which the final bit has\nbeen toggled, so the final bit is underlined.\nLogisim's built-in components don't include anything working with Gray codes.\nBut electronics designers find Gray codes useful sometimes. One\nparticularly notable instance of Gray codes is along the axes in Karnaugh\nmaps.\nGrayIncrementer\nThis is a minimal example illustrating the essential elements\nto defining a component. This particular component is an incrementer,\nwhich takes an multibit input and produces the next Gray code following it\nin sequence.\npackage com.cburch.gray;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\n/** This component takes a multibit input and outputs the value that follows it\n* in Gray Code. For instance, given input 0100 the output is 1100. */\nclass GrayIncrementer extends InstanceFactory {\n/* Note that there are no instance variables. There is only one instance of\n* this class created, which manages all instances of the component. Any\n* information associated with individual instances should be handled\n* through attributes. For GrayIncrementer, each instance has a \"bit width\"\n* that it works with, and so we'll have an attribute. */\n/** The constructor configures the factory. */\nGrayIncrementer() {\nsuper(\"Gray Code Incrementer\");\n/* This is how we can set up the attributes for GrayIncrementers. In\n* this case, there is just one attribute - the width - whose default\n* is 4. The StdAttr class defines several commonly occurring\n* attributes, including one for \"bit width.\" It's best to use those\n* StdAttr attributes when appropriate: A user can then select several\n* components (even from differing factories) with the same attribute\n* and modify them all at once. */\nsetAttributes(new Attribute[] { StdAttr.WIDTH },\nnew Object[] { BitWidth.create(4) });\n/* The \"offset bounds\" is the location of the bounding rectangle\n* relative to the mouse location. Here, we're choosing the component to\n* be 30x30, and we're anchoring it relative to its primary output\n* (as is typical for Logisim), which happens to be in the center of the\n* east edge. Thus, the top left corner of the bounding box is 30 pixels\n* west and 15 pixels north of the mouse location. */\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\n/* The ports are locations where wires can be connected to this\n* component. Each port object says where to find the port relative to\n* the component's anchor location, then whether the port is an\n* input/output/both, and finally the expected bit width for the port.\n* The bit width can be a constant (like 1) or an attribute (as here).\n*/\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, StdAttr.WIDTH),\nnew Port(0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n}\n/** Computes the current output for this component. This method is invoked\n* any time any of the inputs change their values; it may also be invoked in\n* other circumstances, even if there is no reason to expect it to change\n* anything. */\npublic void propagate(InstanceState state) {\n// First we retrieve the value being fed into the input. Note that in\n// the setPorts invocation above, the component's input was included at\n// index 0 in the parameter array, so we use 0 as the parameter below.\nValue in = state.getPort(0);\n// Now compute the output. We've farmed this out to a helper method,\n// since the same logic is needed for the library's other components.\nValue out = nextGray(in);\n// Finally we propagate the output into the circuit. The first parameter\n// is 1 because in our list of ports (configured by invocation of\n// setPorts above) the output is at index 1. The second parameter is the\n// value we want to send on that port. And the last parameter is its\n// \"delay\" - the number of steps it will take for the output to update\n// after its input.\nstate.setPort(1, out, out.getWidth() + 1);\n}\n/** Says how an individual instance should appear on the canvas. */\npublic void paintInstance(InstancePainter painter) {\n// As it happens, InstancePainter contains several convenience methods\n// for drawing, and we'll use those here. Frequently, you'd want to\n// retrieve its Graphics object (painter.getGraphics) so you can draw\n// directly onto the canvas.\npainter.drawRectangle(painter.getBounds(), \"G+1\");\npainter.drawPorts();\n}\n/** Computes the next gray value in the sequence after prev. This static\n* method just does some bit twiddling; it doesn't have much to do with\n* Logisim except that it manipulates Value and BitWidth objects. */\nstatic Value nextGray(Value prev) {\nBitWidth bits = prev.getBitWidth();\nif(!prev.isFullyDefined()) return Value.createError(bits);\nint x = prev.toIntValue();\nint ct = (x >> 16) ^ x; // compute parity of x\nct = (ct >> 8) ^ ct;\nct = (ct >> 4) ^ ct;\nct = (ct >> 2) ^ ct;\nct = (ct >> 1) ^ ct;\nif((ct & 1) == 0) { // if parity is even, flip 1's bit\nx = x ^ 1;\n} else { // else flip bit just above last 1\nint y = x ^ (x & (x - 1)); // first compute the last 1\ny = (y << 1) & bits.getMask();\nx = (y == 0 ? 0 : x ^ y);\n}\nreturn Value.createKnown(bits, x);\n}\n}\nThis example by itself is not enough to create a working JAR file;\nyou must also provide a Library class, as illustrated on the next page."
  },
  {
    "id": 69,
    "title": "Library Class",
    "url": "/en/html/guide/jar/library.html",
    "text": "Library Class\nLibrary Class\nThe access point for the JAR library is a class that extends the\nLibrary class. The library's main job is to list the tools that are\navailable through the library; most often, the tools are all tools\nto add the various components defined - that is, instances of the\nAddTool class working with different component factories.\nComponents\npackage com.cburch.gray;\nimport java.util.Arrays;\nimport java.util.List;\nimport com.cburch.logisim.tools.AddTool;\nimport com.cburch.logisim.tools.Library;\n/** The library of components that the user can access. */\npublic class Components extends Library {\n/** The list of all tools contained in this library. Technically,\n* libraries contain tools, which is a slightly more general concept\n* than components; practically speaking, though, you'll most often want\n* to create AddTools for new components that can be added into the circuit.\n*/\nprivate List<AddTool> tools;\n/** Constructs an instance of this library. This constructor is how\n* Logisim accesses first when it opens the JAR file: It looks for\n* a no-arguments constructor method of the user-designated class.\n*/\npublic Components() {\ntools = Arrays.asList(new AddTool[] {\nnew AddTool(new GrayIncrementer()),\nnew AddTool(new SimpleGrayCounter()),\nnew AddTool(new GrayCounter()),\n});\n}\n/** Returns the name of the library that the user will see. */\npublic String getDisplayName() {\nreturn \"Gray Tools\";\n}\n/** Returns a list of all the tools available in this library. */\npublic List<AddTool> getTools() {\nreturn tools;\n}\n}"
  },
  {
    "id": 70,
    "title": "Simple Gray Code Counter",
    "url": "/en/html/guide/jar/simpctr.html",
    "text": "Simple Gray Code Counter\nSimple Gray Code Counter\nOften we want components that aren't exclusively combinational\nin nature - that is, we want the component to have some memory.\nThere is an important subtlety in defining such components: You\ncan't have the component itself store the state, because an\nindividual component can appear many times in the same circuit.\nIt can't appear directly within a circuit multiple times, but\nit can appear multiple times if it appears in a subcircuit that\nis used several times.\nThe solution is to create a new class for representing the\nobject's current state, and to associate instances of this with\nthe component through the parent circuit's state. In this example,\nwhich implements an edge-triggered 4-bit Gray code counter, we define a\nCounterData class to represent the counter's state, in addition\nto the InstanceFactory subclass as illustrated previously.\nThe CounterData object remembers both the counter's\ncurrent value, as well as the last clock input seen (to detect\nrising edges).\nCounterData\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceData;\nimport com.cburch.logisim.instance.InstanceState;\n/** Represents the state of a counter. */\nclass CounterData implements InstanceData, Cloneable {\n/** Retrieves the state associated with this counter in the circuit state,\n* generating the state if necessary.\n*/\npublic static CounterData get(InstanceState state, BitWidth width) {\nCounterData ret = (CounterData) state.getData();\nif(ret == null) {\n// If it doesn't yet exist, then we'll set it up with our default\n// values and put it into the circuit state so it can be retrieved\n// in future propagations.\nret = new CounterData(null, Value.createKnown(width, 0));\nstate.setData(ret);\n} else if(!ret.value.getBitWidth().equals(width)) {\nret.value = ret.value.extendWidth(width.getWidth(), Value.FALSE);\n}\nreturn ret;\n}\n/** The last clock input value observed. */\nprivate Value lastClock;\n/** The current value emitted by the counter. */\nprivate Value value;\n/** Constructs a state with the given values. */\npublic CounterData(Value lastClock, Value value) {\nthis.lastClock = lastClock;\nthis.value = value;\n}\n/** Returns a copy of this object. */\npublic Object clone() {\n// We can just use what super.clone() returns: The only instance variables are\n// Value objects, which are immutable, so we don't care that both the copy\n// and the copied refer to the same Value objects. If we had mutable instance\n// variables, then of course we would need to clone them.\ntry { return super.clone(); }\ncatch(CloneNotSupportedException e) { return null; }\n}\n/** Updates the last clock observed, returning true if triggered. */\npublic boolean updateClock(Value value) {\nValue old = lastClock;\nlastClock = value;\nreturn old == Value.FALSE && value == Value.TRUE;\n}\n/** Returns the current value emitted by the counter. */\npublic Value getValue() {\nreturn value;\n}\n/** Updates the current value emitted by the counter. */\npublic void setValue(Value value) {\nthis.value = value;\n}\n}\nSimpleCounter\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Manufactures a simple counter that iterates over the 4-bit Gray Code. This\n* example illustrates how a component can maintain its own internal state. All\n* of the code relevant to state, though, appears in CounterData class. */\nclass SimpleGrayCounter extends InstanceFactory {\nprivate static final BitWidth BIT_WIDTH = BitWidth.create(4);\n// Again, notice how we don't have any instance variables related to an\n// individual instance's state. We can't put that here, because only one\n// SimpleGrayCounter object is ever created, and its job is to manage all\n// instances that appear in any circuits.\npublic SimpleGrayCounter() {\nsuper(\"Gray Counter (Simple)\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, BIT_WIDTH.getWidth()),\n});\n}\npublic void propagate(InstanceState state) {\n// Here I retrieve the state associated with this component via a helper\n// method. In this case, the state is in a CounterData object, which is\n// also where the helper method is defined. This helper method will end\n// up creating a CounterData object if one doesn't already exist.\nCounterData cur = CounterData.get(state, BIT_WIDTH);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n// (You might be tempted to determine the counter's current value\n// via state.getPort(1). This is erroneous, though, because another\n// component may be pushing a value onto the same point, which would\n// \"corrupt\" the value found there. We really do need to store the\n// current value in the instance.)\n}\npublic void paintInstance(InstancePainter painter) {\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST); // draw a triangle on port 0\npainter.drawPort(1); // draw port 1 as just a dot\n// Display the current counter value centered within the rectangle.\n// However, if the context says not to show state (as when generating\n// printer output), then skip this.\nif(painter.getShowState()) {\nCounterData state = CounterData.get(painter, BIT_WIDTH);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(BIT_WIDTH.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}"
  },
  {
    "id": 71,
    "title": "Gray Code Counter",
    "url": "/en/html/guide/jar/counter.html",
    "text": "Gray Code Counter\nGray Code Counter\nThis orientation to the Logisim libraries concludes with a\nfairly sophisticated Gray code counter that allows the user to alter its\ncurrent value using the Poke Tool and to place a label on the component using\nthe Text Tool. It also customizes the icon that appears in the explorer,\nassociated with the tool.\nGrayCounter\npackage com.cburch.gray;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.Instance;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Manufactures a counter that iterates over Gray codes. This demonstrates\n* several additional features beyond the SimpleGrayCounter class. */\nclass GrayCounter extends InstanceFactory {\npublic GrayCounter() {\nsuper(\"Gray Counter\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n// We'll have width, label, and label font attributes. The latter two\n// attributes allow us to associate a label with the component (though\n// we'll also need configureNewInstance to configure the label's\n// location).\nsetAttributes(\nnew Attribute[] { StdAttr.WIDTH, StdAttr.LABEL, StdAttr.LABEL_FONT },\nnew Object[] { BitWidth.create(4), \"\", StdAttr.DEFAULT_LABEL_FONT });\n// The following method invocation sets things up so that the instance's\n// state can be manipulated using the Poke Tool.\nsetInstancePoker(CounterPoker.class);\n// These next two lines set it up so that the explorer window shows a\n// customized icon representing the component type. This should be a\n// 16x16 image.\nURL url = getClass().getClassLoader().getResource(\"com/cburch/gray/counter.gif\");\nif(url != null) setIcon(new ImageIcon(url));\n}\n/** The configureNewInstance method is invoked every time a new instance\n* is created. In the superclass, the method doesn't do anything, since\n* the new instance is pretty thoroughly configured already by default. But\n* sometimes you need to do something particular to each instance, so you\n* would override the method. In this case, we need to set up the location\n* for its label. */\nprotected void configureNewInstance(Instance instance) {\nBounds bds = instance.getBounds();\ninstance.setTextField(StdAttr.LABEL, StdAttr.LABEL_FONT,\nbds.getX() + bds.getWidth() / 2, bds.getY() - 3,\nGraphicsUtil.H_CENTER, GraphicsUtil.V_BASELINE);\n}\npublic void propagate(InstanceState state) {\n// This is the same as with SimpleGrayCounter, except that we use the\n// StdAttr.WIDTH attribute to determine the bit width to work with.\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nCounterData cur = CounterData.get(state, width);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n}\npublic void paintInstance(InstancePainter painter) {\n// This is essentially the same as with SimpleGrayCounter, except for\n// the invocation of painter.drawLabel to make the label be drawn.\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST);\npainter.drawPort(1);\npainter.drawLabel();\nif(painter.getShowState()) {\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nCounterData state = CounterData.get(painter, width);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(width.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}\nCounterPoker\npackage com.cburch.gray;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstancePoker;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.StdAttr;\n/** When the user clicks a counter using the Poke Tool, a CounterPoker object\n* is created, and that object will handle all user events. Note that\n* CounterPoker is a class specific to GrayCounter, and that it must be a\n* subclass of InstancePoker in the com.cburch.logisim.instance package. */\npublic class CounterPoker extends InstancePoker {\npublic CounterPoker() { }\n/** Determines whether the location the mouse was pressed should result\n* in initiating a poke.\n*/\npublic boolean init(InstanceState state, MouseEvent e) {\nreturn state.getInstance().getBounds().contains(e.getX(), e.getY());\n// Anywhere in the main rectangle initiates the poke. The user might\n// have clicked within a label, but that will be outside the bounds.\n}\n/** Draws an indicator that the caret is being selected. Here, we'll draw\n* a red rectangle around the value. */\npublic void paint(InstancePainter painter) {\nBounds bds = painter.getBounds();\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nint len = (width.getWidth() + 3) / 4;\nGraphics g = painter.getGraphics();\ng.setColor(Color.RED);\nint wid = 7 * len + 2; // width of caret rectangle\nint ht = 16; // height of caret rectangle\ng.drawRect(bds.getX() + (bds.getWidth() - wid) / 2,\nbds.getY() + (bds.getHeight() - ht) / 2, wid, ht);\ng.setColor(Color.BLACK);\n}\n/** Processes a key by just adding it onto the end of the current value. */\npublic void keyTyped(InstanceState state, KeyEvent e) {\n// convert it to a hex digit; if it isn't a hex digit, abort.\nint val = Character.digit(e.getKeyChar(), 16);\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nif(val < 0 || (val & width.getMask()) != val) return;\n// compute the next value\nCounterData cur = CounterData.get(state, width);\nint newVal = (cur.getValue().toIntValue() * 16 + val) & width.getMask();\nValue newValue = Value.createKnown(width, newVal);\ncur.setValue(newValue);\nstate.fireInvalidated();\n// You might be tempted to propagate the value immediately here, using\n// state.setPort. However, the circuit may currently be propagating in\n// another thread, and invoking setPort directly could interfere with\n// that. Using fireInvalidated notifies the propagation thread to\n// invoke propagate on the counter at its next opportunity.\n}\n}"
  },
  {
    "id": 72,
    "title": "Guidelines",
    "url": "/en/html/guide/jar/guide.html",
    "text": "Guidelines\nGuidelines\nLearning more\nBeyond the sequence of examples provided here, the Logisim source code\nprovides copious additional examples, though they do not always illustrate\nthe same attention to readability and good design.\nFor maximum portability to future versions, you should stick as much\nas possible to the classes in the ...instance, ...data,\nand ...tools packages. Of course, you may use other packages'\nAPIs, but they are more vulnerable to changes in future versions of Logisim.\nI am generally willing to answer occasional requests for help. And bug\nreports and suggestions for improvements, of course, are always welcome.\nDistribution\nYou are free to distribute any JARs you develop without restriction.\nThe GPL restrictions do apply, however, if portions of your work are\nderived from portions of Logisim source code (released under the GPL).\nDeriving from the example code in this section of the User's Guide\ndoes not incur such restrictions; these examples are released under the\nMIT license.\nIf you would like to share your library with other Logisim users,\nI will be happy to provide a link to a hosting Web page or the\nJAR file itself through the Logisim Web site. If you think your library\nshould be built into the basic Logisim release, then I welcome your\nsuggestion, and I'll be happy to acknowledge your contribution in\nLogisim releases including the work."
  },
  {
    "id": 73,
    "title": "About the program",
    "url": "/en/html/guide/about/index.html",
    "text": "About the program\nAbout the program\nLogisim is open-source software. The source code is included\nin the src subdirectory of the distributed JAR file.\nIf you find Logisim useful, please let me know. Especially\ndo this if you are an educational institution; the information will\nhelp me in gaining support for the work.\nI welcome e-mails about Logisim, including bug reports, suggestions,\nand fixes. When you e-mail me, please remember that I have worked hard\nto produce Logisim without receiving any payment from you.\nIf you want\na right to complain about the software, then I would suggest shelling\nout the money for a competing program to Logisim. (I know of no\nopen-source competitors that approach Logisim's feature set.)\nNonetheless, I remain interested in continuing to improve Logisim, and\nyour suggestions will be most welcome.\nCopyright notice\nCopyright (c) 2005, Carl Burch.\nLogisim is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2 of\nthe License, or (at your option) any later version.\nLogisim is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\nGeneral Public License for more details.\nAcknowledgements\nThe source code to Logisim is primarily my own work; I must\nacknowledge my employers who fund my work as a professor, including\nthis program: I started the program at Saint John's\nUniversity (Collegeville, Minnesota, USA) in 2000-2004, and I have\ncontinued it at Hendrix College (Conway, Arkansas, USA) from 2004\nto present. I am very grateful to these colleges for\ngiving me the time and resources to work on this project. If only\nall colleges and universities had their act as together and cared as\nmuch about excellent teaching as these colleges do!\nSome other people who have been particularly helpful:\nTheldo Cruz Franqueira, Thanos Kakarountas, Ilia Lilov, Pablo Leal Ramos,\nand Uwe Zimmermann, who have contributed\nto translations packaged with Logisim. More information about the translations\ncan be found on International Preferences\npage.\nThe Spring 2005 CS61C class at the University of California, Berkeley,\nwhich endured the beta versions of Logisim 2.0. These students put up with\nmany bugs, and I am very appreciative for their\npatience and for their suggestions!\nThe Spring 2001 CSCI 150 classes at the College of Saint Benedict and\nSaint John's University, which used the most rudimentary versions of Logisim\nas it was being developed.\nSeveral pieces of Logisim come from others' packages that Logisim\nuses; several of these pieces are distributed as part of Logisim.\nSun's Java API (obviously)\nSun's JavaHelp project\nProvides the integrated help system from the Help menu.\nMRJAdapter, from Steve Roy\nIntegration with the Macintosh OS X platform.\nlaunch4j, from Grzegorz Kowalt\nAllows distribution of Logisim as a Windows executable.\nGIFEncoder, from Adam Doppelt\nSaves images as GIF files. This was itself based on C code\nwritten by Sverre H. Huseby.\nColorPicker, from Jeremy Wood\nProvides the color dialog box that pops up when configuring colors (as with\nthe LED component).\nJFontChooser, from Christos Bohoris\nProvides the font selection dialog box that pops up when selecting font\nattributes (such as with the Label Font attribute of many components).\nTableSorter, ascribed to Philip Milne, Brendon McLean, Dan van Enckevort,\nParwinder Sekhon, and ouroborus@ouroborus.org\nProvides the ability to sort the table in the\nGet Circuit Statistics dialog through clicking column headers.\nFarm-Fresh Web Icons, http://www.fatcow.com/free-icons\nProvides the icons for controlling simulation that appear under the simulation tree.\nThese icons are released under the Creative Commons Attribution 3.0 License,\nand they cannot be redistributed under the terms of the GPL.\nAnd finally, I want to thank all the users who have contacted me -\nwhether with bug reports, with suggestions, or just to let me know\nthat they're using Logisim in their classes. I have to leave these\nsuggesters anonymous, because I don't have their permission to mention\nthem here, but:\nThank you!"
  },
  {
    "id": 74,
    "title": "GNU General Public License",
    "url": "/en/html/guide/about/gpl.html",
    "text": "About This Program\nGNU GENERAL PUBLIC LICENSE\nVersion 2, June 1991\nCopyright (C) 1989, 1991 Free Software Foundation, Inc.\n51 Franklin St, Fifth Floor, Boston, MA\n02110-1301\nUSA\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\nPreamble\nThe licenses for most software are designed to take away your\nfreedom to share and change it.\nBy contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.\nThis\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.\n(Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)\nYou can apply it to\nyour programs, too.\nWhen we speak of free software, we are referring to freedom, not\nprice.\nOur General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\nTo protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.\nYou must make sure that they, too, receive or can get the\nsource code.\nAnd you must show them these terms so they know their\nrights.\nWe protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\nAlso, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.\nIf the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\nFinally, any free program is threatened constantly by software\npatents.\nWe wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.\nTo prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\nThe precise terms and conditions for copying, distribution and\nmodification follow.\nGNU GENERAL PUBLIC LICENSE\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.\nThe \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.\n(Hereinafter, translation is included without limitation in\nthe term \"modification\".)\nEach licensee is addressed as \"you\".\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.\nThe act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\na) You must cause the modified files to carry prominent notices\nstating that you changed the files and the date of any change.\nb) You must cause any work that you distribute or publish, that in\nwhole or in part contains or is derived from the Program or any\npart thereof, to be licensed as a whole at no charge to all third\nparties under the terms of this License.\nc) If the modified program normally reads commands interactively\nwhen run, you must cause it, when started running for such\ninteractive use in the most ordinary way, to print or display an\nannouncement including an appropriate copyright notice and a\nnotice that there is no warranty (or else, saying that you provide\na warranty) and that users may redistribute the program under\nthese conditions, and telling the user how to view a copy of this\nLicense.\n(Exception: if the Program itself is interactive but\ndoes not normally print such an announcement, your work based on\nthe Program is not required to print an announcement.)\nThese requirements apply to the modified work as a whole.\nIf\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.\nBut when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\na) Accompany it with the complete corresponding machine-readable\nsource code, which must be distributed under the terms of Sections\n1 and 2 above on a medium customarily used for software interchange; or,\nb) Accompany it with a written offer, valid for at least three\nyears, to give any third party, for a charge no more than your\ncost of physically performing source distribution, a complete\nmachine-readable copy of the corresponding source code, to be\ndistributed under the terms of Sections 1 and 2 above on a medium\ncustomarily used for software interchange; or,\nc) Accompany it with the information you received as to the offer\nto distribute corresponding source code.\n(This alternative is\nallowed only for noncommercial distribution and only if you\nreceived the program in object code or executable form with such\nan offer, in accord with Subsection b above.)\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.\nFor an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.\nHowever, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.\nAny attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n5. You are not required to accept this License, since you have not\nsigned it.\nHowever, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.\nThese actions are\nprohibited by law if you do not accept this License.\nTherefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.\nYou may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.\nIf you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.\nFor example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.\nMany people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.\nIn such case, this License incorporates\nthe limitation as if written in the body of this License.\n9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.\nSuch new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\nEach version is given a distinguishing version number.\nIf the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.\nIf the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.\nFor software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.\nOur decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\nNO WARRANTY\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\nTHE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.\nSHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\nEND OF TERMS AND CONDITIONS"
  },
  {
    "id": 75,
    "title": "Library Reference",
    "url": "/en/html/libs/index.html",
    "text": "Tool and Library Reference\nTool and Library Reference\nLogisim libraries hold components you can click and place into your circuits.\nLibraries are shown in the left navigation panel. Logisim comes with several\nbuilt-in libraries, but you can load additional external libraries from a Java\nJAR file or even load a Logisim \".circ\" file as a library to use its circuits in\nyour own.\nHint: Set the default properties of a component by\nchanging them while it is still in the library, before placing it in your\ncircuit, Logisim remembers those properties for next time you place another\nof that component.\nThe toolbar holds commonly used components, along with tools for editing and\ninteracting with circuits. You can customize the toolbar by right-clicking it.\nHint: Drag tools into the toolbar from any library for quick\naccess. You can even drag multiple copies of a component to the toolbar and\ngive each different default properties.\nTools and components available for the toolbar and in Logisim's built-in\nlibraries are documented below.\nMouse Tools for Toolbar \u2014 for\nediting and interacting with circuits\nPoke Tool \u2014 interact with running simulation\nMulti-Tool \u2014 select and move things, or draw wires\nMove Tool\u2014 just select and move things\nWiring Tool \u2014 just draw wires\nWire Cutter \u2014 delete wires or parts of wires\nText Tool \u2014 add or edit labels ad text comments\nMenu Tool \u2014 bring up the right-click context menu\nComment \u2014 add text comments\nWiring library \u2014 Basic elements needed for most circuits\nSplitter \u2014 join or split wires into buses\nPin \u2014 input to and output from a circuit\nProbe \u2014 display values on wires\nTunnel \u2014 make connections without drawing wires\nClock \u2014 oscillates between zero and one\nConstant \u2014 like an input, but with a fixed value\nBit Extender \u2014 zero-extend or sign-extend binary numbers\nGates library \u2014 Primitive combinational components\nNOT Gate \u2014 inverts a signal\nBuffer \u2014 does nothing, no-op\nAND, OR, NAND, NOR Gates \u2014 simple logic operations\nXOR, XNOR, Odd Parity, Even Parity \u2014 equality and parity operations\nTri-state Buffer, Tri-state Inverter \u2014 gates with three possible outputs\nPLA \u2014 Programmable Logic Array\nPlexers library \u2014 controlling and selecting groups of signals\nMultiplexer \u2014 select one value from of a group of wires\nDemultiplexer \u2014 send a value to one of a group of wires\nDecoder \u2014 enable one out of a group of wires\nPriority Encoder \u2014 check which wire among a group is enabled\nBit Selector \u2014 select one bit from a bus\nArithmetic library \u2014 computing with binary numbers\nAdder \u2014 add binary numbers\nSubtractor \u2014 subtract binary numbers\nMultiplier \u2014 multiply binary numbers\nDivider \u2014 divide binary numbers\nNegator \u2014 negate two's complement binary numbers\nComparator \u2014 compare binary numbers\nShifter \u2014 shift binary patterns left or right\nBit Adder \u2014 count the enabled bits in a bus value\nBit Finder \u2014 search for a bit in a bus value\nMemory library \u2014 storing data\nD, T, J-K, S-R Flip-Flops \u2014 store a single-bit\nRegister \u2014 store multiple bits\nCounter \u2014 store, increment, and decrement a number\nShift Register \u2014 store and shift a bit pattern\nRandom Generator \u2014 generate random numbers\nRAM \u2014 random-access memory\nROM \u2014 read-only memory\nInput/Output library \u2014 user interaction\nButton \u2014 a push-button for user input\nDIP Switch \u2014 a row of small switches for user input\nJoystick \u2014 arcade-style joystick for x,y user input\nKeyboard \u2014 ascii text user input\nLED \u2014 single-bit output as a colored light\nPort I/O \u2014 bi-directional input/output (useful for FPGAs)\nRGBLED \u2014 three-bit output as a multi-colored light\n7-Segment Display \u2014 display numbers or patterns\nHex Digit Display \u2014 display 4-bit data as a hex digit\nLED Matrix \u2014 a grid of 1-bit lights\nTTY \u2014 display ascii text\nFile Viewer \u2014 display lines from a file\nRGB Video \u2014 full-color video output\nAnalog library \u2014 simplistic non-digital components\nPower, Ground \u2014 signal source and sink\nTransistor \u2014 simplified PNP and NPN transistors\nTransmission Gate \u2014 block or transmit a signal\nPull Resistor \u2014 weakly pull signal to a default value\nBFH mega functions \u2014 miscellaneous advanced components\nDynamicClockControl \u2014 control FPGA clock speed dynamically\nBin2BCD \u2014 binary to binary-coded-decimal conveter\nBCD2SevenSegment \u2014 4-bit binary-coded-decimal to seven-segment adapter\nHex2SevenSegment \u2014 4-bit hex to seven-segment adapter"
  },
  {
    "id": 76,
    "title": "Wiring library",
    "url": "/en/html/libs/wiring/index.html",
    "text": "Wiring Library\nWiring Library\nThe Wiring library includes basic elements that are needed for most circuits.\nSplitter \u2014 join or split wires into buses\nPin \u2014 input to and output from a circuit\nProbe \u2014 display values on wires\nTunnel \u2014 make connections without drawing wires\nClock \u2014 oscillates between zero and one\nConstant \u2014 like an input, but with a fixed value\nBit Extender \u2014 zero-extend or sign-extend binary numbers"
  },
  {
    "id": 77,
    "title": "Splitter",
    "url": "/en/html/libs/wiring/splitter.html",
    "text": "Splitter\nSplitter\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe splitter creates a correspondence between a multi-bit value and several\nseparate subsets of those bits. Despite its name, it can either\nsplit a multi-bit value into component parts, or it can combine\ncomponent parts into a multi-bit value; or it can do both at once.\nA more complete description of splitters is found in the 'Splitters' section of the\nUser's Guide.\nLogisim treats splitters specially when propagating values within a\ncircuit: Whereas all other components have a computed delay for purposes\nof simulating their behavior, values propagate through splitters (as\nwell as wires) instantaneously.\nNote: The term splitter is a non-standard\nterm, which is unique to Logisim as far as I know. I am unaware of any\nstandard term for such a concept; the only term I have heard used is\nbus ripper, but this term is unnecessarily violent for my\ntastes.\nPins\nTo distinguish the several connecting points for a splitter, we refer\nto the single connecting point one side as its combined end,\nand we refer to the multiple connecting points on the other side as its\nsplit ends.\nCombined end (input/output bit width matches Bit Width In attribute)\nA value holding all of the bits traveling through the splitter.\nSplit ends (input/output, bit width computed based on Bit x attributes)\nThe number of split ends is specified in the Fan Out attribute, and\neach split end has an index that is at least 0 and less than the Fan Out\nattribute. For each split end, all bits for which Bit x\nrefers to its index travels through that split end; the order of these\nbits is the same as their order within the combined end.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Fan Out attribute,\nAlt-0 through Alt-9 alter both the Fan Out and Bit Width In attributes,\nand the arrow keys alter its Facing attribute.\nFacing\nThe location of the split ends relative to the combined end.\nFan Out\nThe number of split ends.\nBit Width In\nThe bit width of the combined end.\nAppearance\nSupports different ways of depicting the splitter in the circuit.\nThe Left-handed option (the default) draws a spine going left from the\ncombined end, with a labeled line coming from the spine for each split end.\nThe Right-handed option is the same except the spine goes right (if you're\nfacing according to the Facing attribute).\nThe Centered option centers the spine so it goes in roughly equal directions\nleft and right.\nAnd the Legacy option draws diagonal lines to each split end, without labels;\nthis option is primarily for compatibility with versions\nolder than 2.7.0, when this was the only option for splitter appearance.\nSpacing\nControls how far appart the split end pins are placed.\nBit x\nThe index of the split end to which bit x of the combined\nend corresponds. The split ends are indexed starting from 0 at the top\n(for a splitter facing east or west) or from 0 at the left/west (for a\nsplitter facing north or south). A bit can be specified to correspond to\nnone of the split ends. There is no way for a bit to correspond to\nmultiple split ends.\nSometimes you can avoid twiddling each individual Bit x attribute\nby bringing up the pop-up menu for a splitter (usually by right-clicking or\ncontrol-clicking it). The pop-up menu includes options labeled Distribute Ascending\nand Distribute Descending. The Distribute Ascending option distributes the bits\nso that each split end receives the same number of bits, starting from end 0.\n(If the number of split ends doesn't divide exactly into the number of bits,\nthen the bits are distributed as evenly as possible.)\nDistribute Descending does the same but starts from the highest-numbered end.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 78,
    "title": "Pin",
    "url": "/en/html/libs/wiring/pin.html",
    "text": "Pin\nPin\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA pin serves as an output from a circuit or as an input to a circuit, depending on the value\nof its 'Type' attribute. Logisim represents output\npins using a circle or rounded rectangle, and input pins are represented\nusing squares or rectangles. In either case, the individual bits of the\nvalue being sent or received is displayed within the component (except\nin printer view, when the bit width is shown instead).\nA pin is a convenient component for interacting with a circuit, and\nbeginning Logisim users need not use them in any other way. But a\nuser building a circuit using several subcircuits (as described in the\n`Subcircuits' section of\nthe User's Guide) will use pins also\nto specify the interface between an outer\ncircuit and the subcircuits it contains. In particular, a circuit layout's pin\ncomponents define the pins that appear on the subcircuit component when\nthe layout is used within another circuit. In such a circuit, the values\nsent and received to those locations on the subcircuit component are\ntied to the pins within the subcircuit layout.\nPins\nA pin component has only one pin. Counterintuitively, when the Pin\ncomponent's type is set to 'input', the pin will actually be an output\u2014\nthe Pin component in this case is taking input from the user (or from some other\ncircuit in which this layout is embedded) and outputting that value to the\nconnected wire. Conversely, when the Pin's type is set to 'output' the pin takes\ninput from the connected wire and outputs it to the screen for the user to see\n(or to some other circuit in which thhis layout is embedded). In either case,\nits bit width matches the Data Bits attribute, and its location depends on the\nFacing attribute.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nthe arrow keys alter its Facing attribute,\nand Alt with an arrow key alters its Label Location attribute.\nFacing\nThe side of the component where its input/output pin should be.\nType\nSpecifies whether the component is used to input values into the circuit, or\nto output values from the circuit.\nData Bits\nThe number of bits for the value that the pin handles.\nBehavior\nControls how an input pin behaves in several special cases, mostly involving\nerror and unknown values. Output pins do not have a Behavior attribute, as they\nwork the same in all circumstances: whatever value is carried by the connected\nwire is shown to the user and passed up to any parent circuit, and if no wire is\nconnected, an 'X' is used instead to indicate a floating value. For input pins,\nseveral behaviors are available:\nSimple. In most cases \"Simple\" behavior should be sufficient.\nFor an input controled by the user, the user can select either zero or one\n(or any combination of zeros and ones for a multi-bit input pin). For an\ninput controlled by a parent circuit, whatever value the parent sends (0, 1,\nE, or X, or some combination of them) is passed to the circuit, or zero is\nused if the parent does not have a wire connected to that pin. Note that\nwith \"Simple\" behavior, an input pin will never create a new floating value\n(X) or error value (E), though it can passes them along from a parent\ncircuit.\nTri-State. This behavior is nearly identical to \"Simple\"\nbehavior, except that for input pins controlled by the user, the user can\nadditional select \"X\" to indicate a floating input.\nPull Down and Pull Up. This behavior is nearly identical\nto \"Simple\" behavior, except that for input pins controlled by a parent\ncircuit: if the parent circuit attempts to send an unknown value (X) to this\npin, it will be converted automatically to either zero (for Pull Down) or one (for Pull\nUp) before being sent into the circuit. Note that this does not affect the\nparent circuit in any way\u2014the parent circuit wire will still show X,\nwhile the subcircuit will receive a zero or one.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nRadix\nThe number base used for displaying values (and entering values for input\npins).\nPoke Tool Behavior\nClicking an output pin has no effect, although the pin's attributes\nwill be displayed.\nClicking an input pin will toggle the bit that is clicked or, when the\n'Radix' is set to something other than binary, iterate through different\npossible values. The keyboard can also be used to enter values using the Poke\ntool.\nWhen viewing the state of a subcircuit\nas described in the `Debugging\nSubcircuits' of the User's Guide,\nthe value of each input pin is tied (\"pinned\") to whatever value the subcircuit\nis receiving from the containing parent circuit. Manually change the value of\nthe input pin break this link between the subcircuit's state and the containing\ncircuit's state, essentially creating a new isolated simulation of just this one\ncircuit, independent from any parent circuit. In this situation, any attempting\nto change the input pin's value using the Poke Tool will cause Logisim to warn\nthe user and confirm whether breaking this link is actually desired.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 79,
    "title": "Probe",
    "url": "/en/html/libs/wiring/probe.html",
    "text": "Probe\nProbe\nLibrary:\nWiring\nIntroduced:\n2.0.3 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA probe is an element that simply displays the value at a given point\nin a circuit. It does not itself interact with other components.\nIn most respects, the probe component duplicates the functionality found in a\nPin component configured as an output pin. The difference\nis that if the circuit is used as a subcircuit component, then an output pin\nwill be a part of that interface, whereas a probe is not. They also are\ndifferent in that the probe automatically adapts its width to whatever it is\nconnected to. Graphically, a probe looks like a pin but has a thinner, gray\nborder and a yellow background.\nPins\nA probe component has only one pin, which acts as an input to\nthe probe. The width that this pin accepts is adaptive: The probe will\nadapt to inputs of any width.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe side of the component where its input pin should be.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nRadix\nThe base (for example, binary, decimal, or hexadecimal) in which\nthe value is displayed.\nPoke Tool Behavior\nNone.\nFPGA SynthesisNone, but Probe components will be silently\nignored during FPGA synthesis."
  },
  {
    "id": 80,
    "title": "Tunnel",
    "url": "/en/html/libs/wiring/tunnel.html",
    "text": "Tunnel\nTunnel\nLibrary:\nWiring\nIntroduced:\n2.5.0 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nA tunnel acts like a wire in that it binds points together,\nbut unlike a wire the connection is not explicitly drawn.\nThis is helpful when you need to connect points far apart in the circuit\nand a network of wires would make the circuit much more ugly.\nThe below illustration illustrates how this works.\nHere, all three tunnels have the same label, a, and so\nthe three points to which the tunnels point are connected.\n(If one of the tunnels were labeled something else, like b,\nthen it would be part of a different set of tunnels.)\nThe tristate buffer at top emits a floating output\nsince its lower input is 0.\nThis normally leads the wire coming from the tristate buffer to be blue;\nbut here it is dark green because the floating output combines\nthrough the tunnel with the 0 from the pin at bottom.\nIf the control input into the tristate buffer changes to 1,\nthen the tristate buffer would feed 1 into the tunnel,\nwhich would combine with 0 from the pin at bottom to result in an error value; thus, we would then see red wires feeding through all three tunnels.\nPins\nA tunnel has only one pin, whose bit width matches the tunnel's\nData Bits attribute. This pin is bidirection, allowing values to flow in either\ndirection through the tunnel.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction toward which the tunnel points.\nData Bits\nThe number of bits for the tunnel.\nLabel\nThe text within the label associated with the tunnel.\nThis tunnel is connected to all other tunnels with exactly the same label.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 81,
    "title": "Pull Resistor",
    "url": "/en/html/libs/wiring/pull.html",
    "text": ""
  },
  {
    "id": 82,
    "title": "Clock",
    "url": "/en/html/libs/wiring/clock.html",
    "text": "Clock\nClock\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 13 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe clock toggles its output value on a regular schedule as long as\nauto-ticks are enabled via the\nSimulate menu, or when a manual\nhalf-tick or full-tick is selected from the same menu.\n(Auto-ticking are disabled by default.)\nA \"tick\" is Logisim's unit of time; the speed at which ticks occur can\nbe selected from the Simulate menu's Auto-Tick Frequency submenu.\nEach clock component's duty cycle can be independently configured using its High\nDuration and Low Duration attributes.\nNote that Logisim's simulation of clocks is quite unrealistic: In\nreal circuits, multiple clocks will drift from one another and will\nnever move in lockstep. But in Logisim, all clocks experience ticks at\nthe same rate.\nWarning: The auto-tick frequency is best-effort\u2014Logisim will\nattempt to toggle the clocks at the selected frequency, but does not provide\nany guarantees. Complex circuits will necessarily require more actual time\nto simulate, and will not be able to keep up with high clock frequencies.\nThe actual simulated frequency can be displayed (see the 'Window' tab of the\nLogisim Preferences).\nPins\nA clock has only one pin, an output with a bit width of 1, whose\nvalue will represent the current value of the clock. The location of\nthis pin is specified in the Facing attribute. The clock's value\nwill toggle on its schedule whenever ticks are enabled, and it will\ntoggle whenever it is clicked using the Poke\nTool.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe side of the component where its output pin should be.\nHigh Duration\nThe length of time within each cycle that the clock's output should\nbe 1.\nLow Duration\nThe length of time within each cycle that the clock's output should\nbe 0.\nLabel\nThe text within the label associated with the clock component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nClicking a clock component will toggle its current output value\nimmediately. Note that all clocks are tied to the same simulated notion\nof time, so poking any one clock will toggle all clocks in the current\nsimulation.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 83,
    "title": "Constant",
    "url": "/en/html/libs/wiring/constant.html",
    "text": "Constant\nConstant\nLibrary:\nWiring\nIntroduced:\n2.0 Beta 1 (in Gates library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nEmits the value specified in its Value attribute.\nPins\nThere is only one pin, an output whose bit width matches the Data Bits\nattribute. The location of this pin is specified in the Facing\nattribute. The component constantly outputs on this pin whatever\nvalue specified in the Value attribute.\nAttributes\nWhen the component is selected or being added,\nthe hexademical digits '0' through '9' and 'a' through 'f' alter its Value attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction in which the pin is located relative to where the\nvalue is drawn.\nData Bits\nThe bit width of the value placed onto the wire.\nValue\nThe value, written in hexademical, that is emitted by the component.\nThe number of bits used to specify the value cannot exceed the\ncomponent's bit width.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 84,
    "title": "Power/Ground",
    "url": "/en/html/libs/wiring/const01.html",
    "text": ""
  },
  {
    "id": 85,
    "title": "Transistor",
    "url": "/en/html/libs/wiring/transist.html",
    "text": ""
  },
  {
    "id": 86,
    "title": "Transmission Gate",
    "url": "/en/html/libs/wiring/transmis.html",
    "text": ""
  },
  {
    "id": 87,
    "title": "Bit Extender",
    "url": "/en/html/libs/wiring/extender.html",
    "text": "Bit Extender\nBit Extender\nLibrary:\nWiring\nIntroduced:\n2.5.0 (in Base library, moved to Wiring in 2.7.0)\nAppearance:\nBehavior\nThe bit extender transforms a value into a value of another bit width.\nFor values being transformed into a smaller bit width,\nthe value is simply truncated to keep the lowest-order bits.\nFor values being transformed into a large bit width,\nthe lowest-order bits are kept the same,\nand you have a choice about what the additional high-order bits will be:\nThey can all be 0, all be 1, all match the input's sign bit\n(its highest-order bit), or the bit extender component can have an additional one-bit\ninput that determines the value for the upper bits.\nPins\nWest edge (input, bit width from Bit Width In attribute)\nThe multi-bit input whose value is to be transformed.\nEast edge (output, bit width from Bit Width Out attribute)\nThe computed output.\nNorth edge (input, bit width 1)\nSpecifies what the additional bits in the output should be.\nThis pin is available only when the Extension Type attribute is Input.\nAttributes\nWhen the component is selected or being added,\nthe digits 0 through 9 alter the Bit Width In attribute\nand Alt-0 through Alt-9 alter its Bit Width Out attribute.\nBit Width In\nThe input's bit width.\nBit Width Out\nThe output's bit width.\nExtension Type\nAssuming the output bit width exceeds the input bit width,\nthis attribute configures what the additional output bits should be.\nIf Zero or One, the additional bits are 0 or 1 accordingly.\nIf Sign, the additional bits are taken to match the highest-order bit in the input.\nAnd if Input, the component has a second input on its north side whose one-bit value is used for the additional bits.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 88,
    "title": "Gates library",
    "url": "/en/html/libs/gates/index.html",
    "text": "Gates Library\nGates library\nThe Gates library includes a variety of simple\ncomponents, all of which have a single output whose value is\ndictated entirely by the component's current inputs.\nNOT Gate \u2014 inverts a signal\nBuffer \u2014 does nothing, no-op\nAND, OR, NAND, NOR Gates \u2014 simple logic operations\nXOR, XNOR, Odd Parity, Even Parity \u2014 equality and parity operations\nTri-state Buffer, Tri-state Inverter \u2014 gates with three possible outputs\nPLA \u2014 Programmable Logic Array"
  },
  {
    "id": 89,
    "title": "NOT Gate",
    "url": "/en/html/libs/gates/not.html",
    "text": "NOT Gate\nNOT Gate\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nShaped:\nRectangular:\nDIN 40700:\nBehavior\nThe NOT Gate emits the complement of whatever input\nit receives.\nThe truth table for a NOT gate is the following.\nxout\n01\n10\nIf the input is unspecified (i.e., floating) or an error, then the output\nwill be an error.\nA multi-bit NOT gate will perform the above transformation bitwise on\nits input.\nPins (assuming component faces east)\nWest edge (input, bit width according to Data Bits attribute)\nThe component's input.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, whose value is the complement of the input value.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's input and output.\nGate Size\nDetermines whether to draw a larger or a smaller version of the\ncomponent.\nOutput Value\nIndicates the set of possible outputs.\nWhen \"0/1\" is selected, both 0 and 1\nare possible outputs and the component behaves according to the table above.\nWhen \"0/floating\" is selected, the component will output a floating X value\nwhenever it would normally output a 1. Similarly, when \"floating/1\" is selected,\nthe component will output a floating X value whenever it would normally output\na 0. The floating output options allow for wired-or and wired-and connections,\nas illustrated below: At left, the Not Gates' Output Value attributes are floating/1\nand the resistor pulls to 0, giving wired-or behavior; at right, the Not Gates'\nOutput Value attributes are 0/floating and the resistor pulls to 1, giving\nwired-and behavior.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisAll basic gates support VHDL and Verilog synthesis.\nFloating outputs (selected with 'Output Value' attribute) are not supported for\nsynthesis."
  },
  {
    "id": 90,
    "title": "Buffer",
    "url": "/en/html/libs/gates/buffer.html",
    "text": "Buffer\nBuffer\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThe buffer simply passes through to its right output whatever input\nit receives on the left side.\nThe truth table for a one-bit buffer is the following.\nxout\n00\n11\nIf the input is unspecified (i.e., floating), then the output will also be\nunspecified - unless the \"Gate Output When Undefined\" option is \"Error for\nundefined inputs,\" in which case the output is an error. If the input is an\nerror value, then the output will also be.\nBuffers are the most useless of the gate components\nprovided in Logisim; its presence in the Gates library is just as much a\nmatter of completeness (a component for each possible\none-input truth table) as it is a matter of providing useful\nfunctionality. Still, it can be occasionally useful to ensure that\nvalues propagate in only one direction along a wire.\nPins (assuming component faces east)\nWest edge (input, bit width according to Data Bits attribute)\nThe input into the component.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, which always matches the input into the left side.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's inputs and outputs.\nOutput Value\nIndicates the set of possible outputs.\nWhen \"0/1\" is selected, both 0 and 1\nare possible outputs and the component behaves according to the table above.\nWhen \"0/floating\" is selected, the component will output a floating X value\nwhenever it would normally output a 1. Similarly, when \"floating/1\" is selected,\nthe component will output a floating X value whenever it would normally output\na 0. The floating output options allow for wired-or and wired-and connections,\nas illustrated below: At left, the Buffers' Output Value attributes are floating/1\nand the resistor pulls to 0, giving wired-or behavior; at right, the Buffers'\nOutput Value attributes are 0/floating and the resistor pulls to 1, giving\nwired-and behavior.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisAll basic gates support VHDL and Verilog synthesis.\nFloating outputs (selected with 'Output Value' attribute) are not supported for\nsynthesis."
  },
  {
    "id": 91,
    "title": "AND/OR/NAND/NOR Gate",
    "url": "/en/html/libs/gates/basic.html",
    "text": "AND/OR/NAND/NOR Gate\nAND, OR, NAND, NOR Gates\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nAND\nOR\nNAND\nNOR\nShaped:\nRectangular:\nDIN 40700:\nBehavior\nThe AND, OR, NAND, and NOT gates each compute the respective\nfunction of the inputs, and emit the result on the output.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even disconnected a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value E.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates are as follows. The letter E\nrepresents the error value, and the letter X represents the floating\nvalue (often Z is used to represent floating values).\nAND\n01E/X\n0000\n101E\nE/X0EE\nOR\n01E/X\n001E\n1111\nE/XE1E\nNAND\n01E/X\n0111\n110E\nE/X1EE\nNOR\n01E/X\n010E\n1000\nE/XE0E\nIn short, these components work as expected as long as all inputs\nare either 0 or 1.\nIf an input is neither 0 nor 1 (it is floating or it is the error value)\nthen the component treats it as both 0 and 1:\nIf the output would be the same both ways\n(as when an AND gate has one input that is definitely 0\nand a questionable second input), that will be the output value;\nbut if the output changes depending on whether it is 0 or 1,\nthe output is the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nPins (assuming component faces east)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of OR and NOR\ngates will be curved. Nonetheless, the input pins are in a line. Logisim\nwill draw short stubs illustrating this; and if you overshoot a stub, it\nwill silently assume that you did not mean to overshoot it. In \"printer\nview\", these stubs will not be drawn unless they are connected to\nwires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute. However, if shaped gates are selected,\nthen the gate will be drawn with wings to accommodate additional inputs\nbeyond what the shape naturally accommodates.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nOutput Value\nIndicates the set of possible outputs.\nWhen \"0/1\" is selected, both 0 and 1\nare possible outputs and the component behaves according to the table above.\nWhen \"0/floating\" is selected, the component will output a floating X value\nwhenever it would normally output a 1. Similarly, when \"floating/1\" is selected,\nthe component will output a floating X value whenever it would normally output\na 0. The floating output options allow for wired-or and wired-and connections,\nas illustrated below: At left, the Buffers' Output Value attributes are floating/1\nand the resistor pulls to 0, giving wired-or behavior; at right, the Buffers'\nOutput Value attributes are 0/floating and the resistor pulls to 1, giving\nwired-and behavior.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nNegate x\nIf yes, the input is negated before it is fed into the gate.\nInputs are counted from top-to-bottom if facing east or west,\nand left-to-right if facing north or south.\nPoke Tool Behavior\nNone.\nFPGA SynthesisAll basic gates support VHDL and Verilog synthesis.\nFloating outputs (selected with 'Output Value' attribute) are not supported for\nsynthesis."
  },
  {
    "id": 92,
    "title": "XOR/XNOR/Even/Odd Gate",
    "url": "/en/html/libs/gates/xor.html",
    "text": "XOR, XNOR, Odd Parity, Even Parity Gate\nXOR, XNOR, Odd Parity, Even Parity Gates\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1 for XOR/Odd/Even; 2.0 Beta 6 for XNOR\nAppearance:\nXOR\nXNOR\nOddParity\nEvenParity\nShaped:\nRectangular:\nDIN 40700:\nBehavior\nThe XOR, XNOR, Odd Parity, and Even Parity gates each compute\nthe respective function of the inputs, and emit the result on the\noutput.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value E.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates is the following.\nxyXOR\nXNOROddEven\n00\n01\n01\n01\n10\n10\n10\n10\n10\n11\n01\n01\nAs you can see, the Odd Parity gate and the XOR gate behave identically\nwith two inputs; similarly, the even parity gate and the XNOR gate\nbehave identically.\nBut if there are more than two specified inputs, the XOR gate will emit\n1 only when there is exactly one 1 input, whereas the Odd Parity gate\nwill emit 1 if there are an odd number of 1 inputs.\nThe XNOR gate will emit 1 only when there is not exactly one 1\ninput, while the Even Parity gate will emit 1 if there are an even\nnumber of 1 inputs. The XOR and XNOR gates include an attribute titled\nMultiple-Input Behavior that allow them to be configured to use the\nOdd Parity and Even Parity behavior.\nIf any of the\ninputs are the error value (e.g., if conflicting values are coming into\nthe same wire) or floating, then the output will be the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nNote: Many authorities contend that the shaped XOR\ngate's behavior should correspond to the odd parity gate, but there is\nnot agreement on this point.\nLogisim's default behavior for XOR gates is based\non the IEEE 91 standard. It is also consistent with the intuitive\nmeaning underlying the term exclusive or: A waiter asking\nwhether you want a side dish of mashed potatoes, carrots, peas, or cole\nslaw will only accept one choice, not three, whatever some authorities\nmay tell you. (I must admit, though, that I have not subjected this\nstatement to a rigorous test.) You can configure the XOR and XNOR gates\nto use parity by changing its Multiple-Input Behavior attribute.\nPins (assuming component faces east)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of XOR and\nXNOR gates will be curved. Nonetheless, the input pins are in a line.\nLogisim will draw short stubs illustrating this; and if you overshoot a\nstub, it will silently assume that you did not mean to overshoot it. In\n\"printer view\", these stubs will not be drawn unless they are connected\nto wires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute; however, if the number of inputs exceeds 3 (for a\nnarrow component) or 5 (for a wide component), then the gate will\nbe drawn with \"wings\" to be able to accommodate the number of inputs\nrequested.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nOutput Value\nIndicates the set of possible outputs.\nWhen \"0/1\" is selected, both 0 and 1\nare possible outputs and the component behaves according to the table above.\nWhen \"0/floating\" is selected, the component will output a floating X value\nwhenever it would normally output a 1. Similarly, when \"floating/1\" is selected,\nthe component will output a floating X value whenever it would normally output\na 0. The floating output options allow for wired-or and wired-and connections,\nas illustrated below: At left, the Buffers' Output Value attributes are floating/1\nand the resistor pulls to 0, giving wired-or behavior; at right, the Buffers'\nOutput Value attributes are 0/floating and the resistor pulls to 1, giving\nwired-and behavior.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nMultiple-Input Behavior (XOR and XNOR only)\nWhen three or more inputs are provided, the XOR/XNOR gate's output will\neither be based on whether exactly one input is 1 (the default) or an odd number\nof inputs are 1.\nNegate x\nIf yes, the input is negated before it is fed into the gate.\nInputs are counted from top-to-bottom if facing east or west,\nand left-to-right if facing north or south.\nPoke Tool Behavior\nNone.\nFPGA SynthesisAll basic gates support VHDL and Verilog synthesis.\nFloating outputs (selected with 'Output Value' attribute) are not supported for\nsynthesis."
  },
  {
    "id": 93,
    "title": "Controlled Buffer/Inverter",
    "url": "/en/html/libs/gates/controlled.html",
    "text": "Controlled Buffer/Inverter\nControlled Buffer/Inverter\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThe tri-state buffer and tri-state inverter, often called controlled\nbuffers/inverters, each have a one-bit \"control\"\ninput pin on the south side. The value at this control pin affects how\nthe component behaves:\nWhen the value on the control pin is 1,\nthen the component behaves just like the respective component, either a buffer or a NOT Gate (a.k.a\n\"inverter\").\nWhen the control pin value is 0 or unknown (i.e., floating), then the\ncomponent's output is floating, regardless of the other input pin.\nWhen the control pin value is an error value (such as would occur when two\nconflicting values are being fed into the input), then the output is an\nerror value.\nControlled buffers can be useful when you have a wire (often called a\nshared bus) whose value should match the output of one of several\ncomponents, each of which is independently controllable by some control signal.\nBy placing a tri-state buffer between each component\noutput and the bus, you can control whether that component's output is\nfed onto the bus or not.\nPins (assuming component faces east, control line right-handed)\nWest edge (input, bit width matches Data Bits attribute)\nThe component input that will be used to compute the output if the\ncontrol input is 1.\nSouth edge (input, bit width 1)\nThe component's control input.\nEast edge (output, bit width matches Data Bits attribute)\nThe component's output, which will be floating if the control input\nis 0 or floating, the error value if the control input is the error\nvalue, and will be computed based on the west-side input if the control\ninput is 1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\n(Tri-state inverter only) Determines whether to draw a larger or a smaller\nversion of the component.\nControl Line Location\nThe location of the control line, imagining we are facing the output\nfrom the input: If the component faces east and is right-handed,\nthe control line is to the south; but if it is left-handed,\nthe control line is to the north.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisTri-state devides are not supported for synthesis."
  },
  {
    "id": 94,
    "title": "Plexers library",
    "url": "/en/html/libs/plexers/index.html",
    "text": "Plexers Library\nPlexers library\nThe Plexers library includes control components.\nLike the components of the Gates library, all are combinational with their\noutputs determined completely by their current inputs,\nbut their purpose is generally for routing values between and among multiple\nsignals wires or buses.\nMultiplexer \u2014 select one value from of a group of wires\nDemultiplexer \u2014 send a value to one of a group of wires\nDecoder \u2014 enable one out of a group of wires\nPriority Encoder \u2014 check which wire among a group is enabled\nBit Selector \u2014 select one bit from a bus"
  },
  {
    "id": 95,
    "title": "Multiplexer",
    "url": "/en/html/libs/plexers/mux.html",
    "text": "Multiplexer\nMultiplexer\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nCopies an input on the west edge to the output on\nthe east edge; which of the inputs to copy is specified via the\ncurrent value received through the select input on the south edge.\nI find it useful to think of a multiplexer as analogous to a railroad\nswitch, controlled by the select input.\nNote: some authorities spell this\nmultiplexor,\nbut multiplexer is the predominant\nspelling.\nPins (assuming component faces east, select is bottom/left)\nWest edge, variable number (inputs, bit width matches Data Bits attribute)\nData values, one of which is to be routed to the output.\nEach input data value is numbered, starting with 0 on the north.\nEast edge (output, bit width matches Data Bits attribute)\nThe output value will match the input values on the west\nedge whose number is the same as the value currently received\nthrough the select input on the south.\nIf the select input contains any unspecified (i.e., floating) bits,\nthen the output is completely floating.\nSouth edge, left side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which input\non the west edge to route to the output on the east edge.\nSouth edge, right side (input, bit width 1)\nEnable (optional): When 0, the multiplexer's output consists of all floating bits,\nregardless of the data and select inputs.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of inputs to the multiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the multiplexer.\nDisabled Output\nSpecifies what each bit of the output should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, when disabled, the output is effectively disconnected from\nany other ports.\nInclude Enable?\nWhether the component should have an enable input.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 96,
    "title": "Demultiplexer",
    "url": "/en/html/libs/plexers/demux.html",
    "text": "Demultiplexer\nDemultiplexer\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nCopies the input on the west edge onto exactly one of the outputs on\nthe east edge; which of these outputs is specified via the\ncurrent value received through the input on the south edge.\nI find it useful to think of a demultiplexer as analogous to a railroad\nswitch, controlled by the select input.\nNote: Incidentally, some authorities spell this\ndemultiplexor,\nbut demultiplexer is the predominant\nspelling.\nPins (assuming component faces east, select is bottom/left)\nWest edge (input, bit width matches Data Bits attribute)\nThe value to be routed to one of the outputs on the east edge.\nEast edge, variable number (outputs, bit width matches Data Bits\nattribute)\nThe outputs are numbered starting with 0 on the north. An output\nwill match the west input if its number matches the value currently\nreceived through the select input on the south; otherwise, its value\nwill be either all-zeroes or all-floating, depending on the value of\nthe Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge, left side (input, bit width 1)\nEnable (optional): When 0, all outputs consist of all floating bits,\nregardless of the data and select inputs.\nSouth edge, right side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines to which output on\nthe east edge to route the value received on the west edge.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (specifying which side has the outputs).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the demultiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the demultiplexer.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nDisabled Output\nSpecifies what each bit of the outputs should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, when disabled the outputs are effectively disconnected from any other ports.\nInclude Enable?\nWhether the component should have an enable input.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 97,
    "title": "Decoder",
    "url": "/en/html/libs/plexers/decoder.html",
    "text": "Decoder\nDecoder\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nEmits 1 on exactly one output; which output is 1 depends on the\ncurrent value received through the input on the south edge. This component is\nequivalent to a Demultiplexer with a constant '1' as its input.\nPins (assuming component faces east, select is bottom/left)\nEast edge, variable number (outputs, bit width 1)\nThe outputs are numbered starting with 0 on the north. Each output\nwill be 1 if its number matches the value currently received through the\nselect input on the south; otherwise, its value will be either zero or\nfloating, depending on the value of the Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge, left side (input, bit width 1)\nEnable (optional): When 0, all outputs consist of all floating bits (or zeros),\nregardless of the select input.\nSouth edge, right side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which of the\noutputs is 1.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (specifying which side has the outputs).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the decoder will be\n2selectBits.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nDisabled Output\nSpecifies what each bit of the outputs should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, when disabled the outputs are effectively disconnected from any other ports.\nInclude Enable?\nWhether the component should have an enable input.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 98,
    "title": "Priority Encoder",
    "url": "/en/html/libs/plexers/priencod.html",
    "text": "Priority Encoder\nPriority Encoder\nLibrary:\nPlexers\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThe component has a number of inputs on its west edge, with the first\nlabeled 0 and the other numbered from there. The component determines\nthe indices of the inputs whose values are 1, and it emits the highest index.\nFor example, if inputs 0, 2, 5, and 6 are all 1, with the others being 0, then the priority encoder\nemits a value of 110 (six in binary). If no inputs are 1, or if the component is\ndisabled, then the output of the priority encoder is floating.\nThe priority encoder is designed so that a number of encoders can be\ndaisy-chained to accommodate additional inputs. In particular, the component\nincludes an enable input and an enable output. Whenever the enable input is 0,\nthe component is disabled, and the output will be all floating bits. The enable\noutput is 1 whenever the component is enabled and none of the indexed inputs are\n1. Thus, you can take two priority encoders and connect the enable output\nof the first to the enable input of the second: If any of the indexed inputs\nto the first are 1, then the second will be disabled and so its output will be\nall floating. But if none of the first's indexed inputs are 1, then its output\nwill be all-floating bits, and the second\npriority encoder will be enabled and it will identify the highest-priority\ninput with a 1.\nThe group select output of the priority encoder is 1 whenever the priority\nencoder is enabled and finds a 1 on one of the indexed inputs. When\nchaining priority encoders together, this output can be used to identify\nwhich, if any, of the encoders was triggered.\nPins (assuming component faces east)\nWest edge, variable number (inputs, bit width 1)\nInput values, indexed from 0 at the top/west end of the edge.\nEast edge, upper pin (output, bit width matches Select Bits attribute)\nOutput: the highest index among those inputs whose value is 1 - or all\nfloating bits if no inputs are 1 or if the component is disabled via the\nEnable In input.\nEast edge, lower pin (output, bit width 1)\nGroup Signal: 1 if the component is enabled and at least one indexed input\nhas a value of 1; otherwise this output is 0.\nSouth edge (input, bit width 1)\nEnable In: if 0, the component is disabled; otherwise the component is\nenabled.\nNorth edge (output, bit width 1)\nEnable Out: 1 if this component is enabled and none of the indexed inputs\nare 1; otherwise the output is 0.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nSelect Bits\nThe bit width of the component's primary output.\nThe number of indexed inputs to the priority encoder will be\n2selectBits.\nDisabled Output\nSpecifies what each bit of the output should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, the output is effectively disconnected from any other ports.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis.\n-"
  },
  {
    "id": 99,
    "title": "Bit Selector",
    "url": "/en/html/libs/plexers/selector.html",
    "text": "Bit Selector\nBit Selector\nLibrary:\nPlexers\nIntroduced:\n2.0.5\nAppearance:\nBehavior\nGiven an input of several bits, this will divide it into several\nequal-sized groups (starting from the lowest-order bit) and output the group\nselected by the select input. This component is essentially equivalent to a\nsplitter with all of the split ends connected to the inputs of a multiplexer.\nFor example, if we have an eight-bit input 01010101, and we are to have\na three-bit output, then group 0 will be the lowest-order three bits 101,\ngroup 1 will be the next three bits, 010, and group 2 will be the next three\nbits 001. (Any bits beyond the top are filled in with 0.) The select\ninput will be a two-bit number that selects which of these three groups\nto output; if the select input is 3, then 000 will be the output.\nPins (assuming component faces east)\nWest edge (input, bit width matches Data Bits attribute)\nData value from which bits should be selected for the output.\nEast edge (output, bit width matches Output Bits attribute)\nA group of bits from the data value, as selected by the select\ninput.\nSouth edge (input, bit width is quotient of Data Bits and Output Bits, rounded up)\nSelect input: Determines which of the bit groups should be routed\nto the output.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Output Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's data input.\nOutput Bits\nThe bit width of the component's output.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 100,
    "title": "Arithmetic library",
    "url": "/en/html/libs/arith/index.html",
    "text": "Arithmetic Library\nArithmetic library\nThe Arithmetic library includes combinational\ncomponents that perform arithmetic operations on unsigned and\ntwo's-complement values.\nAdder \u2014 add binary numbers\nSubtractor \u2014 subtract binary numbers\nMultiplier \u2014 multiply binary numbers\nDivider \u2014 divide binary numbers\nNegator \u2014 negate two's complement binary numbers\nComparator \u2014 compare binary numbers\nShifter \u2014 shift binary patterns left or right\nBit Adder \u2014 count the enabled bits in a bus value\nBit Finder \u2014 search for a bit in a bus value"
  },
  {
    "id": 101,
    "title": "Adder",
    "url": "/en/html/libs/arith/adder.html",
    "text": "Adder\nAdder\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nThis component adds the two values coming in via the west inputs and\noutputs the sum on the east output. The component is designed so that it\ncan be cascaded with other adders to add more bits than is\npossible with a single adder: The carry-in input provides a\none-bit value to be added into the sum also (if it is specified), and a\ncarry-out output provides a one-bit overflow value that can be fed to\nanother adder.\nIf either of the addends contains some floating bits or some error\nbits, then the component will perform a partial addition. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nOne of the two values to add.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe other of the two values to add.\nNorth edge, labeled c in (input, bit width 1)\nA carry value to add into the sum. If the value is unknown (i.e.,\nfloating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the sum of the two values\ncoming in the west edge, plus the cin\nbit.\nSouth edge, labeled c out (output, bit width 1)\nThe carry bit computed for the sum. If the values added together as\nunsigned values yield a result that fits into dataBits\nbits, then this bit will be 0; otherwise, it will be 1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be added and of the result.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 102,
    "title": "Subtractor",
    "url": "/en/html/libs/arith/subtractor.html",
    "text": "Subtractor\nSubtractor\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nThis component subtracts values coming in via the west inputs\n(the upper minus the lower) and outputs the difference on the east\noutput. The component is designed so that it can be cascaded with other\nsubtractors to provide subtract more bits than is possible with a single\nsubtractor: The borrow-in input provides a one-bit value to be borrowed\nout of the difference (if the borrow-in input is specified), and a\nborrow-out output indicates whether the component needs to borrow an\nupper-order bit to complete the subtraction without underflow (assuming\nunsigned subtraction).\nInternally, the subtractor simply performs a bitwise NOT on the\nsubtrahend, and add this to the minuend along with the NOT of the\nborrow-in input. (The minuend is the first operand (upper\ninput) to the subtraction, and the subtrahend is the second\n(lower input). I happen to like the antiquated terms.)\nIf either of the operands contains some floating bits or some error\nbits, then the component will perform a partial subtraction. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe minuend of the subtraction; that is, the number from which to\nsubtract.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe subtrahend of the subtraction; that is, the number to subtract\nfrom the minuend.\nNorth edge, labeled b in (input, bit width 1)\nIf 1, then 1 is borrowed out of the difference. If the value is\nunknown (i.e., floating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the difference of the two\nvalues coming in the west edge, minus the\nbin bit.\nSouth edge, labeled b out (output, bit width 1)\nThe borrow bit computed for the difference. If the values subtracted\nas unsigned values yield a negative value, then this bit will be 1;\notherwise, it will be 0.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be subtracted and of the result.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 103,
    "title": "Multiplier",
    "url": "/en/html/libs/arith/multiplier.html",
    "text": "Multiplier\nMultiplier\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 20\nAppearance:\nBehavior\nThis component multiplies two values coming in via the west inputs\nand outputs the product on the east output. The component is designed so\nthat it can be cascaded with other multipliers to multiply a\nmultiplicand with more bits than is possible with a single multiplier:\nThe carry-in input provides a multi-bit value to be added into the\nproduct (if it is specified), and a carry-out output provides the upper\nhalf of the product result, which can be fed into another\nmultiplier.\nIf the multiplicand, the multiplier, or the carry-in input contain\nsome floating bits or some error bits, then the component will perform a\npartial multiplication. That is, it will compute as many low-order bits\nas possible. But above the floating or error bit, the result will have\nfloating or error bits. Note that if the carry-in input is completely\nfloating, then it will be assumed to be all-zeroes.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe multiplicand (that is, the first of the two numbers to\nmultiply).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe multiplier (that is, the second of the two numbers to multiply).\nNorth edge, labeled c in (input, bit width matches Data Bits attribute)\nA carry value to add into the product. If all bits of the value are\nunknown (i.e., floating), then they are assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the product of the two values\ncoming in the west edge, plus the cin\nvalue.\nSouth edge, labeled c out (output, bit width matches Data Bits attribute)\nThe upper dataBits bits of the product.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be multiplied and of the result.\nNumeric Type\nWhether the multiplication should be performed using signed\n(two's complement) or unsigned arithmetic.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL synthesis."
  },
  {
    "id": 104,
    "title": "Divider",
    "url": "/en/html/libs/arith/divider.html",
    "text": "Divider\nDivider\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nThis component divides two values coming in via the west inputs and\noutputs the quotient on the east output. The component is designed so\nthat it can be cascaded with other dividers to provide support a\ndividend with more bits than\nis possible with a single divider: The upper input provides the\nupper dataBits bits of the dividend (if it is specified at\nall), and the rem bits provide the remainder, which can be\nfed as the upper input into another divider.\nIf the divisor is 0, then no division is performed (i.e., the divisor\nis assumed to be 1).\nThe magnitude of the remainder will always be between 0 and\n|divisor|-1, with a sign matching the divisor.\nThe quotient will always be an integer so that:\nquotient \u00d7 divisor + remainder = dividend\nIf the quotient or remainder does not fit into\ndataBits bits, then only the lower dataBits bits\nwill be reported. The component does not provide any method for\naccessing the upper dataBits bits of the quotient or remainder.\nIf either of the operands contains some floating bits or some error\nbits, then the component's outputs will be either entirely floating or\nentirely error values.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe lower dataBits bits of the dividend (that is, the\nfirst operand for the division).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe divisor (that is, the second operand for the division)\nNorth edge, labeled upper (input, bit width matches Data Bits attribute)\nThe upper dataBits bits of the dividend (that is, the\nfirst operand for the division).\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the quotient, as specified\nabove.\nSouth edge, labeled rem (output, bit width matches Data Bits attribute)\nThe remainder of the division. This value will always be between 0\nand divisor-1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be divided and of the result.\nNumeric Type\nWhether the division should be performed using signed\n(two's complement) or unsigned arithmetic.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL synthesis. Divider component synthesis\nis broken when upper input is not connected in signed mode."
  },
  {
    "id": 105,
    "title": "Negator",
    "url": "/en/html/libs/arith/negator.html",
    "text": "Negator\nNegator\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nComputes the two's-complement negation of the input.\nThis negation\nis performed by maintaining all the lower-order bits up to the\nlowest-order 1, and complementing all bits above that.\nIf the value to be negated happens to be the least negative value,\nthen its negation (which cannot be represented in two's-complement\nform), is still the least negative value.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe value to negate.\nEast edge, labeled -x (output, bit width matches Data Bits attribute)\nThe negation of the input. If the input happens to be the least\nnegative value representable in dataBits bits, however, then\nthe output matches the input.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's input and output.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 106,
    "title": "Comparator",
    "url": "/en/html/libs/arith/comparator.html",
    "text": "Comparator\nComparator\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nCompares two values, either as unsigned values or as two's-complement\nvalues, depending on the Numeric Type attribute. Normally, one of the\noutputs will be 1, and the other two outputs will be 0.\nThe comparison is performed starting at the most significant bits in\neach number and descending downward in parallel until a location is\nfound where the two values disagree. If, however, an error value or\na floating value is encountered during this descent, then all outputs\nwill match that error or floating value.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe first of the two values to be compared.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe second of the two values to be compared.\nEast edge, labeled > (output, bit width 1)\n1 if the first input is greater than the second input, 0 if\nthe first input is less than or equal the second input.\nEast edge, labeled = (output, bit width 1)\n1 if the first input equals the second input, 0 if\nthe first input is not equal the second input.\nEast edge, labeled < (output, bit width 1)\n1 if the first input is less than the second input, 0 if\nthe first input is greater than or equal the second input.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's inputs.\nNumeric Type\nWhether the comparison should be performed using signed\n(two's complement) or unsigned arithmetic.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 107,
    "title": "Shifter",
    "url": "/en/html/libs/arith/shifter.html",
    "text": "Shifter\nShifter\nLibrary:\nArithmetic\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThis component includes two inputs, data and dist, and\nit has one output, which is the result of shifting data by\ndist places. Both data and output have the same number of\nbits in them. The component supports the following shift types:\nLogical Left: All bits in data are shifted up dist places,\nwith the bottom dist places filled with 0's. For example,\n11001011 logically shifted left twice is 00101100. (The top two ones are lost.)\nLogical Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with 0's. For example,\n11001011 logically shifted right twice is 00110010. (The bottom two ones are\nlost.)\nArithmetic Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with repetitions of\nwhatever the uppermost bit in data. For example, 11001011\narithmetically shifted right twice is 11110010.\nRotate Left: All bits in data are shifted up dist\nplaces, with the top dist places wrapped around into the bottom.\nFor example, 11001011 rotated left twice is 00101111.\nRotate Right: All bits in data are shifted down dist\nplaces, with the bottom dist places wrapped around into the top.\nFor example, 11001011 rotated right twice is 11110010.\nNote that if dist contains any floating or error inputs, then\nthe output is composed entirely of error values, since there is no way to\nguess how far to shift the input.\nPins\nWest edge, north end (input, bit width matches the Data Bits attribute)\nThe value to be shifted.\nWest edge, south end (input, bit width is computed as below)\nThe number of bits by which to shift the data input.\nThis input should have as many bits as is the minimum number to indicate\nany shift distance from 0 up to one less than Data Bits; that is, it should\nbe the ceiling of the base-2 logarithm of Data Bits. For example, if Data Bits\nwere 8, this input would require 3 bits; but if it were 9, it would require\n4 bits.\nEast edge (output, bit width matches the Data Bits attribute)\nThe result of shifting the input value by the input distance.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the data input and of the output.\nShift Type\nOne of the five possible shift types as outlined above (Logical Left,\nLogical Right, Arithmetic Right, Rotate Left, Rotate Right).\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 108,
    "title": "Bit Adder",
    "url": "/en/html/libs/arith/bitadder.html",
    "text": "Bit Adder\nBit Adder\nLibrary:\nArithmetic\nIntroduced:\n2.6.0\nAppearance:\nBehavior\nThe component determines how many 1 bits are in its input(s) and emits the\ntotal number of 1 bits on its output. For example, given the 8-bit input 10011101,\nthe output would be 5, since there are five 1-bits in the input\n(the first, the last, and a string of three bits in the middle).\nIf any of the input bits are floating or error values, then the output will\ncontain error bits in the output corresponding to the range of possible outputs\ndepending on whether those floating/error values are counted as zeroes or ones.\nFor instance, if the 14-bit input is 111x10110x1101, then the output must be\nat least 9 (if the x's are interpreted as zeroes)\nand at most 11 (if they are interpreted as ones).\nThus, the output will be 10EE: The upper two bits will be 1 and 0 since all integers\nbetween 9 and 11 have 1 and 0 as their top two bits, but the lower two bits are EE\nsince integers between 9 and 11 vary within these bits.\nPins\nWest edge (inputs, bit width matches Data Bits attribute)\nThe inputs whose 1 bits are to be counted. The number of inputs is based\non the Number of Inputs attribute.\nEast edge (output, bit width computed as described below)\nThe number of input bits which are 1. The bit width of the output is the\nminimum number of bits to store the maximum possible value (which would be\nthe product of the Data Bits attribute and the Number of Inputs attribute).\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute and\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input(s).\nNumber of Inputs\nThe number of input values.\nPoke Tool Behavior\nNone.\nFPGA SynthesisNone."
  },
  {
    "id": 109,
    "title": "Bit Finder",
    "url": "/en/html/libs/arith/bitfinder.html",
    "text": "Bit Finder\nBit Finder\nLibrary:\nArithmetic\nIntroduced:\n2.6.1\nAppearance:\nBehavior\nThe component takes a multi-bit input and determines the the index of a bit,\nwhere the index is computed by counting from 0 as the lowest-order bit.\nExactly which index it computes depends on the Type attribute, as illustrated\nby the examples in the below table for the 8-bit sample input 11010100.\nTypeOutput for 11010100\nLowest-order 12\nHighest-order 17\nLowest-order 00\nHighest-order 05\nFor the lowest-order 1, the output is 2 because if you index the bits\nstarting from 0 for the lowest-order bit, the first 1 you will find is\nat index 2. (The bits at indices 0 and 1 are both 0.)\nFor the highest-order 1, the output is 7 because the topmost 1 bit is at index 7\n(again counting from the lowest-order bit as 0).\nThe component's output on the south edge indicates whether the desired bit\nwas found at all. In the above examples involving the input 11010100,\nthe south output is 1 in all cases.\nBut if the input were 00000000 and the component is to find the\nlowest-order 1, then the south output would be 0 \u2014 and the output on the\neast edge would be 0 as well.\nIf while searching for the desired value, a value that is neither 0 or 1 is\nfound (the bit could be floating or an error value),\nthen both outputs will consist entirely of error bits.\nNote that this occurs only if the problematic bit is encountered before finding\nthe desired bit: For the input x1010100, the output would still be 2 if\nthe lowest-order 1 is desired; but we would get error values if the component's\ntype indicates to search for the highest-order 1 or the highest-order 0, since\nthere is an erroneous bit in a higher-order bit than either the highest-order 0\nor the highest-order 1.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe multibit input that is to be searched for the desired bit.\nEast edge (output, bit width computed as described below)\nThe index of the desired bit, counting from 0 for the lowest-order bit.\nThe bit width is the\nminimum number of bits to store the maximum possible index, which is one\nless than the value of the Data Bits attribute.\nSouth edge (output, bit width 1)\n1 if the desired bit is found, 0 if all input bits are the inverse of the\ndesired bit, and the error value if a non-0, non-1 value is found before the\ndesired bit.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input.\nType\nIndicates which bit to search for \u2014 the lowest-order 0,\nthe highest-order 0, the lowest-order 1, or the highest-order 1.\nPoke Tool Behavior\nNone.\nFPGA SynthesisNone."
  },
  {
    "id": 110,
    "title": "Memory library",
    "url": "/en/html/libs/mem/index.html",
    "text": "Memory Library\nMemory library\nThe Memory library includes components that remember information.\nD, T, J-K, S-R Flip-Flops \u2014 store a single-bit\nRegister \u2014 store multiple bits\nCounter \u2014 store, increment, and decrement a number\nShift Register \u2014 store and shift a bit pattern\nRandom Generator \u2014 generate random numbers\nRAM \u2014 random-access memory\nROM \u2014 read-only memory"
  },
  {
    "id": 111,
    "title": "D/T/J-K/S-R Flip-Flop",
    "url": "/en/html/libs/mem/flipflops.html",
    "text": "D, T, J-K, S-R Flip-Flops\nD, T, J-K, S-R Flip-Flops\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nDTJ-KS-R\nClassic Logisim:\nANSI:\nBehavior\nEach flip-flop stores a single bit of data, which is emitted through\nthe Q output on the east side. Normally, the value can be\ncontrolled via the inputs to the west side. In particular, the value\nchanges when the clock input, marked by a triangle on\neach flip-flop, rises from 0 to 1 (or otherwise as configured); on this rising\nedge, the value changes according to the table below.\nD Flip-Flop\nT Flip-Flop\nJ-K Flip-Flop\nS-R Flip-Flop\nDQ\n00\n11\nTQ\n0Q\n1Q'\nJKQ\n00\nQ\n01\n0\n10\n1\n11\nQ'\nSRQ\n00\nQ\n01\n0\n10\n1\n11\n??\nAnother way of describing the different behavior of the flip-flops\nis in English text.\nD Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop becomes the value of the D\ninput (Data) at that instant.\nT Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop either toggles or remains the same\ndepending on whether the T\ninput (Toggle) is 1 or 0.\nJ-K Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\ntoggles if the J and K inputs are both 1\nand the value remains the same if both are 0;\nif they are different, then the value becomes 1 if the J\n(Jump) input is 1 and 0 if the K (Kill)\ninput is 1.\nS-R Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\nremains unchanged if R and S are both 0,\nbecomes 0 if the R input (Reset) is 1, and\nbecomes 1 if the S input (Set) is 1.\nThe behavior in unspecified if both inputs are 1.\n(In Logisim, the value in the flip-flop remains unchanged.)\nBy default, the clock triggers on a rising edge \u2014 that is, when the\nclock input changes from 0 to 1. However, the\nTrigger attribute allows this to change to a falling edge (when the clock\ninput changes from 1 to 0), a high level (for the duration that the clock input\nis 1), or a low level (for the duration that the clock input is 0). The\nlevel-trigger options are unavailable for the T and J-K flip-flops, because\na flip-flop behaves unpredictably when told to toggle for an indeterminate\namount of time.\nPins (assuming \"Classic Logisim\" appearance)\nWest edge, marked by triangle (input, bit width 1)\nClock input: At the instant that this input value switches from 0 to\n1 (the rising edge), the value will be updated according to the other\ninputs on the west edge.\nAs long as this remains 0 or 1, the other\ninputs on the west edge have no effect.\nWest edge, other labeled pin(s) (input(s), bit width 1)\nThese inputs control how the flip-flop's value changes during the\nrising edge of the clock. Their exact behavior depends on the\nflip-flop; the above tables summarize their behavior.\nEast edge, labeled Q, north end (output, bit width 1)\nOutputs the value currently stored by the flip-flop.\nEast edge, south end (output, bit width 1)\nOutputs the complement of the value currently stored by the\nflip-flop.\nSouth edge, east end (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the flip-flop's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nSouth edge, center end (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current bit\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, west end (input, bit width 1)\nAsynchronous set: When 1 or undefined, this input has no effect.\nWhen 1, the flip-flop's value is pinned to 1. This occurs asynchronously\n- that is, without regard to the current clock input value. As long as\nthis input is 1, the other inputs have no effect, except for the\nasynchronous reset input, which has priority.\nAttributes\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the flip-flop should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the flip-flop should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0. Note that the latter two options\nare unavailable for T and J-K flip-flops.\nLabel\nThe text within the label associated with the flip-flop.\nLabel Font\nThe font with which to render the label.\nInclude Enable?\nWhether the flip-flip should have a clock-enable input pin.\nShow in Registers Tab\nWhether the value of the flip-flip should appear in the \"State\" tab at the\nbottom left of the canvas, which can be useful for seeing all of the state\nvalues contained in a circuit at a glance.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nClicking a flip-flop using the Poke Tool toggles the bit stored in\nthe flip-flop, unless the asynchronous set/reset inputs currently\npin the flip-flop's value.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 112,
    "title": "Register",
    "url": "/en/html/libs/mem/register.html",
    "text": "Register\nRegister\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nClassic Logisim:\nANSI:\nBehavior\nA register stores a single multi-bit value, which is displayed in\nhexadecimal within its rectangle, and is emitted on its\nQ output. When the clock input\n(indicated by a triangle on the south edge) indicates so,\nthe value stored in the register changes to the value of the\nD input at that instant. Exactly when the clock input indicates\nfor this to happen is configured via the Trigger attribute.\nThe reset input resets the register's value to 0 (all\nzeroes) asynchronously; that is, as long as reset\nis 1, the value is pinned to 0, regardless of the clock input.\nPins (assuming \"Classic Logisim\" appearance)\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the register.\nWest edge, labeled D (input, bit width matches Data Bits attribute)\nData input: At the instant that the clock value rises from 0 to 1,\nthe register's value changes to the value of the D input at\nthat instant.\nWest edge, labeled en (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current value\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock input: At the instant that this input value rises from 0 to\n1 (the rising edge), the register's value will be updated to the value\nof the D input.\nSouth edge, labeled 0 (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the register's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in the register.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the register should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0.\nLabel\nThe text within the label associated with the register.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to render the label.\nInclude Enable?\nWhether the register should have a clock-enable input pin.\nShow in Registers Tab\nWhether the value of the register should appear in the \"State\" tab at the\nbottom left of the canvas, which can be useful for seeing all of the state\nvalues contained in a circuit at a glance.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nClicking the register brings keyboard focus to the register\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the register.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 113,
    "title": "Counter",
    "url": "/en/html/libs/mem/counter.html",
    "text": "Counter\nCounter\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nClassic Logisim:\nANSI:\nBehavior\nThe counter holds a single value, whose value is emitted on the output\nQ. Each time the clock input (diagrammed with a triangle on the\ncomponent's south edge) triggers according to its Trigger attribute,\nthe value in the counter may update based on\nthe two inputs on the component's west edge: The upper input is called\nload and the lower is called count, and they are\ninterpreted as follows.\nloadcounttrigger action\n0 or X0\nThe counter remains unchanged.\n0 or X1 or X\nThe counter increments.\n10\nThe counter loads the value found at the\nD input.\n11 or X\nThe counter decrements.\nThe range of counting can be configured using the Maximum\nValue attribute. When the counter reaches this value, the next\nincrement wraps the counter back to 0; and if it is at 0,\nthen a decrement will wrap the counter around back to its maximum value.\nIn addition to the output Q, the component also includes a\nsingle-bit output carry. This is 1 whenever the counter is at its\nmaximum and the load and count inputs indicate that the\ncomponent should increment on the next step - or when the counter is at 0\nand the load and count inputs indicate to decrement at\nthe next step.\nThe clear input resets the counter's value to 0 (all\nzeroes) asynchronously; that is, as long as the clr input\nis 1, the value is pinned to 0, regardless of the clock input.\nPins (assuming \"Classic Logisim\" appearance)\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the counter.\nEast edge, lower pin (output, bit width 1)\nCarry: When load and count indicate to increment,\nthis output is 1 whenever the counter is at its maximum. When load\nand count indicate to decrement, this output is 1 whenever the\ncounter is at 0. At all other times, this output is 0.\nWest edge, top pin (input, bit width 1)\nLoad: When this is 1 while the count input is 0, the counter\nwill load the value found at the data input at the next clock\ntrigger - or, if the count input happens to be 1, the counter's\nvalue will decrement.\nWest edge, middle pin labeled D\n(input, bit with matches Data Bits attribute)\nData: When the clock triggers while load is 1\nand count is 0, the counter's value changes to the value found at\nthis input.\nWest edge, lower pin labeled ct (input, bit width 1)\nCount: When this is 1 or unconnected, the value in the counter increments\nwhenever the clock input is triggered - or it decrements if the load\ninput happens to also be 1.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the counter updates as indicated by the load and\ncount inputs.\nSouth edge, labeled 0 (input, bit width 1)\nClear: When 0 or undefined, this input has no effect.\nAs long as it is 1, the counter's value is asynchronously pinned to 0. This\noccurs asynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nMaximum Value\nThe maximum value, at which point the counter will set its carry output.\nAction On Overflow\nThe behavior when the counter attempts to increment beyond the maximum value\nor decrement beyond 0. Four possible actions are supported:\nWrap around\nThe next value is 0 (if incrementing - the maximum value if decrementing)\nStay at value\nThe counter's value remains at the maximum (or 0 if decrementing)\nContinue counting\nThe counter continues incrementing/decrementing, keeping the number of bits\nas provided by the Data Bits attribute\nLoad next value\nThe next value is loaded from the D input.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the counter should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nLabel Location\nThe relative direction in which to render the label.\nShow in Registers Tab\nWhether the value of the register should appear in the \"State\" tab at the\nbottom left of the canvas, which can be useful for seeing all of the state\nvalues contained in a circuit at a glance.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nClicking the counter brings keyboard focus to the component\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the counter.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 114,
    "title": "Shift Register",
    "url": "/en/html/libs/mem/shiftreg.html",
    "text": "Shift Register\nShift Register\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nClassic Logisim:\nANSI:\nBehavior\nThis register consists of several stages, where each clock may lead to\neach stage receiving the value in the previous stage, while a new value is\nloaded into the first stage. The component optionally also supports parallel\nloads and stores to all stages' values.\nThe clear input resets all stages to 0 (all\nzeroes) asynchronously; that is, as long as the clear input\nis 1, all values are pinned to 0, regardless of the clock input.\nPins\n* An asterisk marks pins that exist only when the Parallel Load attribute\nis enabled.\nWest edge, top pin (input, bit width 1)\nShift: When 1 or disconnected, all stages advance with the clock trigger;\nbut if it is 0, no advance takes place. This input is ignored if the Load\ninput is 1.\nWest edge, middle pin (input, bit width matches Data Bits attribute)\nData: When advancing the stages, the value found at this input is loaded\ninto the first stage.\nWest edge, bottom pin marked with triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the\nTrigger attribute, the component may advance the stages or load new values.\n*North edge, left pin (input, bit width 1)\nLoad: When this 1, the values found on the other north-edge pins are\nloaded into all stages at the next clock trigger. When 0 or disconnected, no\nload occurs.\n*North edge, other pins (input, bit width matches Data Bits attribute)\nData: These values are loaded into all stages when the clock is triggered\nwhile the load input is 1. The leftmost input corresponds to the\nyoungest stage.\nSouth edge, left pin (input, bit width 1)\nClear: When this is 1, all stages are asynchronously reset to 0, and all\nother inputs are ignored.\n*South edge, other pins (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in each stage, with the youngest stage\nreflected on the leftmost of the pins (next to the clear input).\nEast edge (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in the final (oldest) stage.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Stages attribute\nand Alt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in each stage.\nNumber of Stages\nThe number of stages included in the component.\nParallel Load\nIf yes, then the component includes inputs and outputs facilitating\nparallel access to all the stages' values.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nShow in Registers Tab\nWhether the value of the register should appear in the \"State\" tab at the\nbottom left of the canvas, which can be useful for seeing all of the state\nvalues contained in a circuit at a glance.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nIf the Parallel Load attribute is no, or if the Data Bits attribute is more\nthan 4, then poking the register has no effect. Otherwise, clicking the\ncomponent will bring keyboard focus to the clicked stage\n(indicated by a red rectangle), and typing a hexadecimal digit will\nchange the value stored in that stage.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 115,
    "title": "Random",
    "url": "/en/html/libs/mem/random.html",
    "text": "Random\nRandom\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nClassic Logisim:\nANSI:\nBehavior\nThis component iterates through a pseudorandom sequence of numbers, which\nsteps forward to the following number in the sequence each time the clock is\ntriggered while the component is enabled. Technically speaking, the algorithm\nused to compute the pseudorandom sequence is a linear\ncongruential generator: Starting from a seed\nr0, the following number\nr1 is the number\nr1 =\n(25,214,903,917 r0 + 11)\nmod 248\nThe next value r2\nis computed from r1\nusing the same computation, and so forth. This sequence is of 48-bit numbers;\nthe value seen from the component is the low-order bits as configured\nby its Data Bits attribute, after first throwing out the lower 12 bits of\nthe current seed.\nBesides the clock input, the component also includes an enable\ninput, which leads the clock input to be ignored when enable is 0,\nand the reset input, which resets the component's value asynchronously\nto the initial seed r0.\nThe initial seed is user-configurable. If it is configured at 0 (which is\nthe default), then the seed is based on the current time; when instructed\nto reset through the reset input, the component computes a new\nseed based on the new current time.\nPins (assuming \"Classic Logisim\" appearance)\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the component.\nWest edge, top pin, labeled with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the component steps to the following number in its sequence.\nWest edge, bottom pin (input, bit width 1)\nEnable: The component is enabled when this input is disconnected or 1;\nbut if it is 0, then the clock input is ignored.\nSouth edge (input, bit width 1)\nReset: When this is 1, the pseudorandom sequence asynchronously resets to\nthe initial seed. (If seed is 0, this new seed should be different from the\ninitial seed used previously.)\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nSeed\nThe starting value used for the pseudorandom sequence. If this is 0\n(the default), then the starting value is based on the time that the random\nsequence began.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the component should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nLabel Location\nThe relative direction in which to render the label.\nShow in Registers Tab\nWhether the value of the register should appear in the \"State\" tab at the\nbottom left of the canvas, which can be useful for seeing all of the state\nvalues contained in a circuit at a glance.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nWhen using \"Classic Logisim\" appearnce, clicking within the component will\ngenerate a new random number, advancing the value stored by one step in the\nsequence of random numbers. Pressing Backspace or\nDelete will reset the state using the initial seed.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 116,
    "title": "RAM",
    "url": "/en/html/libs/mem/ram.html",
    "text": "RAM\nRAM\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nSeparate Data BusesBidirectional Data bus\nClassic Logisim:\nANSI:\nBehavior\nThe RAM component, easily the most complex component in Logisim's\nbuilt-in libraries, stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). The circuit can load and\nstore values in RAM, either one at a time, in pairs, or four at a time. Also, the user can modify individual values\ninteractively via the Poke Tool, or the user can edit, export, or import the\ncontents via the Menu Tool.\nCurrent values are displayed in the component. Addresses are shown in hex to\nthe left of the display area, and memory contents are shown in hex inside the\ndisplay area. The value at the currently selected address is displayed with a\ndark highlight and white text.\nThe RAM component supports two different interfaces, depending on the\nDatabus implementation attribute.\nOne bidirectional data bus\nThe component includes a single port on its east side that serves for both\nloading and storing data. Which operation is performed\u2014loading or\nstoring\u2014depends on the inputs labeled\nL and S: L=1 (or floating) indicates to load (from RAM to the data bus) the data at the address\ndesignated on the component's west side, and S=1 indicates to store (from the data\nbus to RAM) the data given on the port into the given address. To transmit data into and out of the component in both\ndirections on a single bus wire, you will need to use a\nTri-State Buffer, as illustrated in the\nexample below, or other components that support floating outputs (e.g.\ncomponents that have an 'Output Value' attribute with support for floating\noutputs).\nSeparate data bus for read and write\nTwo data ports are provided\u2014one input data port on the west side\nfor storing data into RAM, and a separate output port on the east side for\nloading data from RAM. This style of data interface removes the necessity of\ndealing with the Tri-State Buffers and so it generally easier to use. With this\ninterface, the output port will always be enabled, and there is no L\ncontrol port: effectively, the RAM will load values to the output databus on\nevery cycle. The S control port controls whether data is stored.\nSingle, Dual, and Quad Lines Modes\nLogisim RAM has a 'Line Size' attribute that controls how many locations\n(\"lines\") of memory are accessed at a time. Setting 'Line Size' to 'Single' is\nthe simplest case: at most one location is accessed during each clock cycle, and\nthere is one databus labeled D (either a single bidirectional port,\nor a pair of one input and one output port both labeled D). When\n'Line Size' is set to 'Dual', however, the RAM component can read or write up to\ntwo locations simultaneously, and there are two databuses (either two\nbidirectional ports, or two pairs of unidirectional ports), labeled D\nand 1. In 'Quad' mode, RAM will read or write up to four locations,\nwith four databuses labeled D, 1, 2, and\n3. The addresses accessed are all consective: for 'Dual' line mode,\nRAM will access addresses A and A+1; for 'Quad' line mode,\nRAM will access addresses A, A+1,\nA+2, and\nA+3.\nIn 'Single' line mode, the single input S controls\nwhether a store operation is performed for the given address.\nIn 'Dual' and 'Quad' line modes, there are additional inputs to control which\nbytes (if any) are stored during a store operation. For example, in 'Quad' mode,\nthere are control signals labeled S0, S1, S2,\nand S3, which control whether a store is performed for addresses\naddresses A, A+1,\nA+2, and A+3,\nrespectively.\nAddress Alignment\nIn 'Dual' and 'Quad' line modes, the selected address must be aligned to a\nmultiple of 2 or 4, respectively. There is no support for mis-aligned accesses.\nThis means the lowest bit or lowest two bits of the address must always be zero\nin those modes. If the address is mis-aligned, RAM will not store data, and it\nwill output all error (E) values instead of loading data from the RAM contents.\nThe decision to omit support in Logisim for mis-aligned addresses is\ndeliberate. Support for mis-aligned addresses is not trivial in many actual\nscenarios: a memory chip may require multiple row accesses, for example, in\norder to perform a mis-aligned read. In addition, FPGA synthesis is\nsubstantially simpler when mis-aligned addresses are not permitted.\nImporting and Exporting Memory Contents\nThe contents of memory can be imported from an external data file, or exported\nto an external file. A variety of file formats are supported: see Memory Import/Export Format in the\nUser's Guide for details.\nPins (assuming \"Classic Logisim\" appearance)\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values in memory is currently being accessed by the\ncircuit. In 'Dual' and 'Quad' line mode, the address A must be a\nmultiple of 2 or 4, respectively, and two or four consecutive addresses are\naccessed starting at address A.\nD on west edge (input, bit width matches Data Bit Width attribute)\nThis input is present only if \"separate data buses\" is selected\nfor the Databus implementation attribute. When a store is requested (via the clock changing\nfrom 0 to 1 while S is 1 and S0 if present is also 1), the\nvalue found at this port is stored into memory at the currently selected address.\n1 on west edge (input, bit width matches Data Bit Width attribute)\nThis input is present only if \"Dual\" or \"Quad\" line mode is selected and\n\"separate data buses\" is selected for the Databus implementation attribute. When a store\nis requested (via the clock changing from 0 to 1 while S1 is 1), the\nvalue found at port 1is stored into memory at A+1, i.e. 1\nlocation beyond the currently selected address.\n2 and 3 on west edge (inputs, bit width matches Data Bit Width attribute)\nThese inputs are present only if \"Quad\" line mode is selected and\n\"separate data buses\" is selected for the Databus implementation attribute. They behave\nsimilarly to the 1 input, but using control signals S2 and\nS3, respectively, and addresses A+2 and A+3,\nrespectively.\nD on east edge (input/output or output, bit width matches Data Bit Width attribute)\nIf L is 1 or floating (or if the L input is not\npresent), then the RAM component emits the value found at the currently selected\naddress on this port, unless the address is mis-aligned in which case an error\n(E) value is emitted instead. If there is a single bidirectional load/store\nport, the value read from this port is stored whenever a store is\nrequested.\n1, 2, 3 on east edge (inputs/outputs or\noutputs, bit width matches Data Bit Width attribute) These ports are\npresent only if \"Dual\" or \"Quad\" line mode is selected. They each behave\nsimilarl to the D input/output or output port, but using addresses\nA+1,\nA+2, and A+3, respectively.\nS on west edge (input, bit width 1)\nStore: When it is 1, a clock pulse will result\nin storing data into memory at the current selected address(es).\nS0, S1, S2, and S3 on west edge\n(inputs, bit width 1) Store i: Only present in \"Dual\" or \"Quad\" line\nmodes, these individually control the store behavior for each of the selected\nlines. Address A+i is only written when both S and\nSi are 1.\ntriangle on west edge (input, bit width 1)\nClock input: Controls the timing of store requests.\nWhen S is 1, and the clock input rises from 0 to 1 (or is triggered\naccording to the 'Trigger' attribute) while S is 1 (and some of the\nSi inputs, if present, are also 1), then the value at the data input\nbus(es) is immediately written into the currently selected address. Note that\nthe clock has no effect on load actions: loads happen asynchronously and\ncontinously, regardless of the clock triggers.\nL on west edge (input, bit width 1)\nLoad: This port is only present if there bidirectional load/store ports are\nused. When L=1, the bidirectional data port or ports are set to\noutput mode, and the value at the current selected address(es) are output to\nthose data ports.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nRAM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nLine Size\nAllows for Single, Dual, or Quad line mode.\nTrigger\nConfigures how the clock input is interpreted. This only affects store\noperations. When a store operation is selected via the S and\nSi inputs, the value rising edge indicates that the memory\nshould store values at the instant when the clock rises from 0 to 1. The\nfalling edge value indicates that it should update at the instant the\nclock falls from 1 to 0. The high level value indicates that the memory\nshould update continuously whenever the clock input is 1. And the low\nlevel value indicates that it should update continuously when the clock\ninput is 0.\nMemory Type\nIf set to 'Volatile' the memory contents will be lost when the simulation is\nreset or when Logisim exits. In addition, FPGA synthesis will initialize\nvolatile memory to all zeros. If set to 'Non-Volatile', the memory contents will\nbe retained even when the simulation is reset or when Logisim exits, and FPGA\nsynthesis will use the current contents of the memory at the time sythesis\noccurs to initialize the FPGA memory.\nDatabus implementation\nConfigures which of the two styles of data interface is used for communicating data\ninto and out of the RAM.\nLabel\nThe text within the label associated with the register.\nLabel Font\nThe font with which to render the label.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nClicking the RAM component brings keyboard and mouse focus to the RAM\n(indicated by a red rectangle), allowing for the contents to be viewed or\nedited. Because Poke Tool editing all takes place within a very small space, the\ninterface for this is severely but necessarily constrained.\nFor all but the\nsimplest editing, it is more convenient to right-click the RAM and select \"Edit\nContents...\" to bring up the integrated hex\neditor.\nThe Poke Tool has two modes of operation: You can edit the address displayed,\nand you can edit an individual value at some memory location.\nEditing Addresses: Use the Poke Tool and click anywhere within the\nmemory component but outside the gray box holding the memory contents.\nLogisim will draw a red rectangle around the address at the upper left corner.\nFrom here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the address (assuming the new address\nisn't too large) and scroll the memory contents to show that address.\nScrolling with the mouse wheel increments or decrements the address\nand scrolls the memory forward or backward.\nThe Down (or Enter)\nkey will increment the address and scroll the memory contents forward by one\nrow.\nThe Up (or Backspace\nor Delete) keys will also increment or decrement\nthe address to key will decrement the address and scroll the memory contents\nbackwards by one row.\nThe Page Down (or Space) and Page Up keys will\nincrement or decrement the address to scroll the memory contents forward or\nbackward by one full page.\nEditing Contents: Use the Poke Tool and click anywhere within the\nmemory component within the gray box holding the memory contents.\nLogisim will draw a red rectangle around the memory cell currently being\nedited. From here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the contents of that cell.\nScrolling with the mouse wheel moves up or down to an adjacent memory\ncell.\nThe Up, Down, Left, and Right arrow keys\nmove to an adjacent memory cell.\nThe Page Up and Page\nDown keys move up or down by a full page.\nThe Backspace (or Delete) and Tab (or Space) keys similarly move to the previous or next\nmemory cell.\nMenu Tool Behavior\nRight-clicking the RAM component brings up several actions in a context menu:\nEdit Contents...: Brings up the integrated hex editor to view and\nedit the entire memory contents in a separate window\nClear Contents: Resets all values in memory to all\nzeros.\nLoad Memory Image...: Loads entirely new memory\ncontents by importing from a file. A variety of file formats are supported:\nsee Memory Import/Export\nFormat in the User's Guide for details.\nSave Memory Image...: Saves the entire contents of\nmemory to an external file. A variety of file formats are supported:\nsee Memory Import/Export\nFormat in the User's Guide for details.\nFPGA SynthesisSupports VHDL synthesis. Only rising and falling edge\ntriggers are supported. Non-Volatile memory is only supported on Altera devices.\nOnly the \"separate data bus\" interface option is supported for synthesis."
  },
  {
    "id": 117,
    "title": "ROM",
    "url": "/en/html/libs/mem/rom.html",
    "text": "ROM\nROM\nLibrary:\nMemory\nIntroduced:\n2.1.0\nAppearance:\nClassic Logisim:\nANSI:\nBehavior\nThe ROM component stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). It behaves similarly to a\nRAM with\nthe 'Non-Volatile' attribute set, but with a greatly simplified interface: a\ncircuit can access the current values in ROM, but it cannot change them, so\nthere is no clock, no control inputs, and there is only one output-only data\nbus. The user can modify individual values interactively via the Poke Tool, or\nthe user can edit, export, or import the contents via the Menu Tool.\nThe ROM component's contents are stored as an attribute of the component.\nThis allows the ROM contents to be set before placing the component into the\ncircuit. Multiple ROM components can be kept in the toolbar, each configured\nwith different contents. The contents are non-volatile, and persist across\nsimulation resets or when Logisim exits.\nCurrent values are displayed in the component. Addresses are displayed in hex\nto the left of the display area. Inside the display area, each value is listed\nin hex. The value at the currently selected address will be displayed in inverse\ntext (white on dark gray).\nSingle, Dual, and Quad Lines Modes\nLogisim ROM has a 'Line Size' attribute that controls how many locations\n(\"lines\") of memory are accessed at a time. Setting 'Line Size' to 'Single' is\nthe simplest case: at most one location is accessed at a time, and there is one\noutput labeled D. When 'Line Size' is set to 'Dual', however, the ROM\ncomponent reads two locations simultaneously, and there are two outputs, labeled\nD and 1. In 'Quad' mode, ROM will read four locations,\nwith four databuses labeled D, 1, 2, and\n3. The addresses accessed are all consective: for 'Dual' line mode,\nROM will access addresses A and A+1; for 'Quad' line mode,\nROM will access addresses A, A+1,\nA+2, and\nA+3.\nAddress Alignment\nIn 'Dual' and 'Quad' line modes, the selected address must be aligned to a\nmultiple of 2 or 4, respectively. There is no support for mis-aligned accesses.\nThis means the lowest bit or lowest two bits of the address must always be zero\nin those modes. If the address is mis-aligned the ROM will output all error (E)\nvalues instead of loading data from the ROM contents.\nThe decision to omit support in Logisim for mis-aligned addresses is\ndeliberate. Support for mis-aligned addresses is not trivial in many actual\nscenarios: a memory chip may require multiple row accesses, for example, in\norder to perform a mis-aligned read. In addition, FPGA synthesis is\nsubstantially simpler when mis-aligned addresses are not permitted.\nImporting and Exporting Memory Contents\nThe contents of memory can be imported from an external data file, or exported\nto an external file. A variety of file formats are supported: see Memory Import/Export Format in the\nUser's Guide for details.\nPins (assuming \"Classic Logisim\" appearance)\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values is currently being accessed by the circuit.\nD on east edge (input/output, bit width matches Data Bit Width attribute)\nOutputs the value at the currently selected address.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nROM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nLine Size\nAllows for Single, Dual, or Quad line mode.\nContents\nStores the contents of memory.\nLabel\nThe text within the label associated with the register.\nLabel Font\nThe font with which to render the label.\nAppearance\nSelects between the \"Classic Logisim\" appearance style, which is somewhat\nmore compact, or \"ANSI\" style, which is more conventional but larger.\nPoke Tool Behavior\nClicking the ROM component brings keyboard and mouse focus to the ROM\n(indicated by a red rectangle), allowing for the contents to be viewed or\nedited. Because Poke Tool editing all takes place within a very small space, the\ninterface for this is severely but necessarily constrained.\nFor all but the\nsimplest editing, it is more convenient to right-click the ROM and select \"Edit\nContents...\" to bring up the integrated hex\neditor.\nThe Poke Tool has two modes of operation: You can edit the address displayed,\nand you can edit an individual value at some memory location.\nEditing Addresses: Use the Poke Tool and click anywhere within the\nmemory component but outside the gray box holding the memory contents.\nLogisim will draw a red rectangle around the address at the upper left corner.\nFrom here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the address (assuming the new address\nisn't too large) and scroll the memory contents to show that address.\nScrolling with the mouse wheel increments or decrements the address\nand scrolls the memory forward or backward.\nThe Down (or Enter)\nkey will increment the address and scroll the memory contents forward by one\nrow.\nThe Up (or Backspace\nor Delete) keys will also increment or decrement\nthe address to key will decrement the address and scroll the memory contents\nbackwards by one row.\nThe Page Down (or Space) and Page Up keys will\nincrement or decrement the address to scroll the memory contents forward or\nbackward by one full page.\nEditing Contents: Use the Poke Tool and click anywhere within the\nmemory component within the gray box holding the memory contents.\nLogisim will draw a red rectangle around the memory cell currently being\nedited. From here:\nTyping R or r will\nclear the contents of memory.\nTyping hex digits will change the contents of that cell.\nScrolling with the mouse wheel moves up or down to an adjacent memory\ncell.\nThe Up, Down, Left, and Right arrow keys\nmove to an adjacent memory cell.\nThe Page Up and Page\nDown keys move up or down by a full page.\nThe Backspace (or Delete) and Tab (or Space) keys similarly move to the previous or next\nmemory cell.\nFPGA SynthesisSupports VHDL and Verilog synthesis. With Verilog,\nonly 'Single' line mode is supported."
  },
  {
    "id": 118,
    "title": "Input/Output library",
    "url": "/en/html/libs/io/index.html",
    "text": "Input/Output Library\nInput/Output library\nThe Input/Output library includes components that are meant to\ncorrespond to typical components found in electronics for interfacing\nwith a user.\nButton \u2014 a push-button for user input\nDIP Switch \u2014 a row of small switches for user input\nJoystick \u2014 arcade-style joystick for x,y user input\nKeyboard \u2014 ascii text user input\nLED \u2014 single-bit output as a colored light\nPort I/O \u2014 bi-directional input/output (useful for FPGAs)\nRGBLED \u2014 three-bit output as a multi-colored light\n7-Segment Display \u2014 display numbers or patterns\nHex Digit Display \u2014 display 4-bit data as a hex digit\nLED Matrix \u2014 a grid of 1-bit lights\nTTY \u2014 display ascii text\nFile Viewer \u2014 display lines from a file\nRGB Video \u2014 full-color video output"
  },
  {
    "id": 119,
    "title": "Button",
    "url": "/en/html/libs/io/button.html",
    "text": "Button\nButton\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nOutputs 0 normally; but when the user is pressing the\nthe button using the Poke Tool, the output is 1.\nPins\nA button has only one pin, a 1-bit output, which is 0 except when the\nuser is pressing the button using the Poke Tool, when it is 1.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe location of the output pin relative to the component.\nColor\nThe color with which to display the button.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nPoke Tool Behavior\nWhen the mouse button is pressed, the component's output will be 1.\nUpon releasing the mouse button, the output reverts back to 0.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 120,
    "title": "Joystick",
    "url": "/en/html/libs/io/joystick.html",
    "text": "Joystick\nJoystick\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThe user can drag the red knob within the rounded-square area, and the outputs\nupdate to indicate the knob's current x- and\ny-coordinates. This is meant to emulate the joysticks known from\nthe days of classical arcade games.\nPins\nWest edge, north pin (output, bit width matches Bit Width attribute)\nIndicates knob's x-coordinate, to be interpreted as an unsigned\ninteger whose value will never be 0. Thus, a value of 1 represents the far left,\nand the maximum value for the bit width indicates the far right. When the knob\nis at rest (in the center), the value has the bit pattern 10...00.\nWest edge, south pin (output, bit width matches Bit Width attribute)\nIndicates knob's y-coordinate, whose value ranges as with the\nx-coordinate pin. When the knob is pulled to the top, this output's\nvalue is 1, and when the knob is pulled to the bottom, the output is the\nmaximum value for the bit width selected.\nAttributes\nWhen the component is selected or being added,\nAlt-2 through Alt-5 alter its Bit Width attribute.\nBit Width\nThe number of bits used to indicate each of the knob's coordinates.\nNumeric Type\nSelects between \"Unsigned\" and \"2's Complement\" representation for the\noutput.\nReturn to Center?\nWhether the joystick should automatically return to center when not being\nused.\nColor\nThe knob's color as it is drawn on the screen.\nPoke Tool Behavior\nPressing the mouse button while within the joystick area moves the knob to\nthat location and updates the outputs. Dragging the mouse continues to move\nthe knob and update the outputs, keeping the knob within the joystick's area.\nReleasing the mouse button reverts the knob back to its rest position, if the\n'Return to Center?' attribute is \"yes\".\nFPGA SynthesisNone."
  },
  {
    "id": 121,
    "title": "Keyboard",
    "url": "/en/html/libs/io/keyboard.html",
    "text": "Keyboard\nKeyboard\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThis component allows the circuit to read keys typed from the keyboard -\nas long as the keys are representable in the 7-bit ASCII code.\nAfter clicking the component using the poke tool, the user can type characters,\nwhich accumulate in a buffer. At all times, the ASCII value for the leftmost\ncharacter in the buffer is sent out the rightmost output. When the clock input\nis triggered, the leftmost character disappears from the buffer and the new\nleftmost character is sent on the rightmost output.\nThe supported characters for the buffer include all the printable ASCII\ncharacters, as well as space, newline, backspace, and control-L. In addition,\nthe left-arrow and right-arrow keys move the cursor within the buffer, and the\ndelete key deletes the character to the right of the cursor (if any).\nThe component is asynchronous in the sense that when the buffer is empty and\nthe user types a character, that character is sent immediately as an output,\nwithout any wait for a clock pulse.\nPins\nWest edge, marked by a triangle (input, bit width 1)\nClock - when triggered while the read-enable pin isn't 0, the leftmost\ncharacter from the buffer is deleted,\nand the outputs are updated to reflect the buffer's new status.\nSouth edge, leftmost pin (input, bit width 1)\nRead Enable - when 1 (or floating or error), a clock edge will consume\nthe leftmost character from the buffer. The clock input is ignored when\nRead Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the buffer is emptied and does not accept further\ncharacters.\nSouth edge, second pin from right (output, bit width 1)\nAvailable - this is 1 when the buffer contains at least one character\nand 0 when the buffer is empty.\nSouth edge, rightmost pin (output, bit width 7)\nData - the 7-bit ASCII code for the leftmost character in the buffer,\nor 0 if the buffer is empty.\nAttributes\nBuffer Length\nThe number of characters that the buffer can hold at once.\nASCII Size\nThe number of bits to use for the output port.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the leftmost character is consumed (when enabled by the Read\nEnable input). If it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nPressing the mouse button into the component gives keyboard focus to the\ncomponent, and a vertical-bar cursor will be displayed.\nEach character typed will then be inserted into the buffer, as long as the\nbuffer hasn't reached its capacity and the character is one of those that the\ncomponent supports: the printable characters within the 7-bit ASCII code, as\nwell as space, backspace, newline, and control-L. Additionally, the user may\ntype the left-arrow and right-arrow keys to change the location of the cursor\nwithin the buffer, and the user may type the delete key to delete the buffer\ncharacter (if any) just to the right of the cursor.\nFPGA SynthesisSupports VHDL synthesis. The Clear signal is not yet\nsupported for synthesis."
  },
  {
    "id": 122,
    "title": "LED",
    "url": "/en/html/libs/io/led.html",
    "text": "LED\nLED\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nDisplays the value of its input by coloring the LED (as specified\nby its Color attribute) or not depending on whether the input is 1 or 0.\n(The LED component is basically redundant with an output pin, except\nfor a somewhat different appearance. Some users, though, thought it would\nbe nice to include.)\nPins\nA LED has only one pin, a 1-bit input which is used to determine whether\nto display the LED colored (when the input is 1) or darkened (when the input\nis anything else).\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe location of the input pin relative to the component.\nOn Color\nThe color to display when the led is \"On\".\nOff Color\nThe color to display when the led is \"Off\".\nActive On High?\nIf yes, then the LED is \"On\" when the input is 1, and \"Off\"\notherwise. If no, it is \"On\" when the input is 0, and \"Off\"\notherwise.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 123,
    "title": "7-Segment Display",
    "url": "/en/html/libs/io/7seg.html",
    "text": "7-Segment Display\n7-Segment Display\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nDisplays the values of its eight one-bit inputs. Segments are either\ncolored or light gray depending on the inputs. The correspondence is as\nfollows.\n(Manufacturers vary as to how they map inputs to segments; the\ncorrespondence used here is based on Texas Instruments'\nTIL321.)\nPins\nNorth edge, first from left (input, bit width 1)\nControls the middle horizontal segment.\nNorth edge, second from left (input, bit width 1)\nControls the upper vertical segment on the left side.\nNorth edge, third from left (input, bit width 1)\nControls the upper horizontal segment.\nNorth edge, fourth from left (input, bit width 1)\nControls the upper vertical segment on the right side.\nSouth edge, first from left (input, bit width 1)\nControls the lower vertical segment on the left side.\nSouth edge, second from left (input, bit width 1)\nControls the bottom horizontal segment.\nSouth edge, third from left (input, bit width 1)\nControls the lower vertical segment on the right side.\nSouth edge, fourth from left (input, bit width 1)\nControls the decimal point.\nAttributes\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nActive On High?\nIf yes, then the segments light when the corresponding input is 1.\nIf no, they light when the corresponding input is 0.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 124,
    "title": "Hex Digit Display",
    "url": "/en/html/libs/io/hexdig.html",
    "text": "Hex Digit Display\nHex Digit Display\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nUsing a seven-segment display, shows the hexadecimal digit corresponding to\nthe four-bit input. If any of the inputs are not 0/1 (either floating or error),\nthen the display shows a dash ('-'). A separate one-bit input controls the\ndisplay of the decimal point.\nPins\nSouth edge, first from left (input, bit width 4)\nThis input is interpreted as an unsigned four-bit number, and the\ncorresponding hexadecimal digit is displayed. If any of the bits are floating\nor error, then a dash ('-') is displayed.\nSouth edge, second from left (input, bit width 1)\nControls the decimal point. If this is left unconnected, the decimal point\nremains off.\nAttributes\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL and Verilog synthesis."
  },
  {
    "id": 125,
    "title": "LED Matrix",
    "url": "/en/html/libs/io/dotmat.html",
    "text": "LED Matrix\nLED Matrix\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nDisplays a small grid of pixels, whose values are determined by the current\ninputs. The grid can have up to 32 rows and 32 columns.\nPins\nThe interface to the component varies depending on the value of the\nInput Format attribute. It has three possible values.\nColumns\nThe inputs are lined along the component's south edge, with one\nmultibit input for each column of the matrix. Each input has as many bits\nas there are rows in the matrix, with the low-order bit corresponding to the\nsouthmost pixel in the column. A 1 indicates to light the corresponding pixel,\nwhile a 0 indicates to keep the pixel dim. If any of the bits for a column are\neither floating or error values, then all pixels in the column are lit.\nRows\nThe inputs are lined along the component's west edge, with one multibit\ninput for each row of the matrix. Each input has as many bits as there are\ncolumns in the matrix, with the low-order bit corresponding to the rightmost\npixel in the row. As with the Columns format, a 1 indicates to light the\ncorresponding pixel, and a 0 indicates to keep the pixel dim. If any bits for\na row are floating or error values, then all pixels in the row are lit.\nSelect Rows/Columns\nThere are two inputs on the component's west edge. The upper multibit\ninput has as many bits as there are columns in the matrix, with the low-order\nbit corresponding to the rightmost column. The lower multibit input has as\nmany bits as there are rows in the matrix, with the low-order bit corresponding\nto the bottom row. If any bits in either input are floating or error\nvalues, all pixels in the matrix are lit. Normally, though, a pixel at a\nparticular row-column location is lit if the corresponding column bit in the\nupper input is 1 and the corresponding row bit in the lower input is 1.\nFor example, for a 5x7 matrix, if the first input is 01010 and the second is\n0111010, then the second and fourth columns are lit for the second, third,\nfourth, and sixth rows; the result appears to be a pair of exclamation points.\n(This input format may seem unintuitive, but LED matrixes are sold commercially\nwith exactly this interface. Lite-On sells such components, for example.)\nAttributes\nInput Format (read-only after component is created)\nSelects how the pins correspond to pixels, as outlined above.\nMatrix Columns\nSelects how many columns are in the matrix, which may range from 1 up to\n32.\nMatrix Rows\nSelects how many rows are in the matrix, which may range from 1 up to\n32.\nOn Color\nSelects the color of a pixel when it is lit.\nOff Color\nSelects the color of a pixel when it is dim.\nLight Persistence\nWhen this is other than 0, a pixel that is lit remains lit\nfor the given number of clock ticks after the component's inputs indicate\nthat the pixel should become dim.\nDot Shape\nThe square option means that each pixel is drawn as a 10x10 square, filling\nthe component with no gaps between pixels. The circle option means that each\npixel is drawn as a diameter-8 circle, with gaps between each circle. The circle\noption is more difficult to interpret, but it more closely approximates the\noff-the-shelf LED matrix components.\nPoke Tool Behavior\nNone.\nFPGA SynthesisNone."
  },
  {
    "id": 126,
    "title": "TTY",
    "url": "/en/html/libs/io/tty.html",
    "text": "TTY\nTTY\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThis component implements a very simple dumb terminal. It receives a sequence\nof ASCII codes and displays each printable character. When the current row\nbecomes full, the cursor moves to the following line, possibly scrolling all\ncurrent rows up if the cursor was already in the bottom row. The only supported\ncontrol sequences are: backspace (ASCII 8), which deletes the last character in\nthe final row, unless the final row is already empty; newline (ASCII 10), which\nmoves the cursor to the beginning of the following line, scrolling if necessary;\nand form-feed (ASCII 12, typed as control-L), which clears the screen.\nPins\nWest edge, upper pin (input, bit width 7)\nData - this is the ASCII value of the next character to be entered into\nthe terminal.\nWest edge, lower pin marked by triangle (input, bit width 1)\nClock - when triggered while the write-enable pin isn't 0, the\ncurrent ASCII value on the Data input is processed by the terminal.\nSouth edge, leftmost pin (input, bit width 1)\nWrite Enable - when 1 (or floating or error), a clock edge will result\nin processing a new character from the data input. The clock and data inputs are\nignored when Write Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the terminal is cleared of all data, and all other inputs\nare ignored.\nAttributes\nRows\nThe number of rows displayed in the terminal.\nColumns\nThe maximum number of characters displayed in each row of terminal.\nASCII Size\nThe number of bits to use for the input port.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the data input is processed (when enabled by the write-enable\nand clear inputs).\nIf it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nColor\nThe color with which to draw the text appearing in the terminal.\nBackground\nThe color with which to draw the terminal's background.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nFPGA SynthesisSupports VHDL synthesis. The Clear signal is not yet\nfully supported for synthesis."
  },
  {
    "id": 127,
    "title": "Base library",
    "url": "/en/html/libs/base/index.html",
    "text": "Base Library\nMouse Tool Library\nThe Mouse Tool Library includes tools for editing and interacting with\ncircuits. This library is only visible when you right-click the toolbar and\nselect \"Customize...\", as these tools normally only appear in the toolbar.\nPoke Tool \u2014 interact with running simulation\nMulti-Tool \u2014 select and move things, or draw wires\nMove Tool\u2014 just select and move things\nWiring Tool \u2014 just draw wires\nWire Cutter \u2014 delete wires or parts of wires\nText Tool \u2014 add or edit labels or text comments\nMenu Tool \u2014 bring up the right-click context menu\nComment \u2014 add text comments"
  },
  {
    "id": 128,
    "title": "Poke Tool",
    "url": "/en/html/libs/base/poke.html",
    "text": "Poke Tool\nPoke Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.0 Beta 1\nBehavior\nThe Poke Tool is for manipulating the current values associated with\ncomponents.\nClicking user-defined component reveals a magnifiying glass\nthat can be clicked to\nreveal the inner state of that subcircuit. Clicking a wire segment using the\nPoke tool displays the value currently carried by the wire. The is particularly\nuseful for multi-bit wires, whose black color provide no visual feedback about\nwhat value the wire is carrying.\nHint: For multi-bit values, you can configure how values are\ndisplayed (in binary, decimal, or hexadecimal, for example) using the Layout pane of the Logisim\nPreferences dialog box.\nFor other components, the precise behavior of the Poke Tool varies depending\non which component is clicked; this behavior is documented in the `Poke Tool\nBehavior' section of each individual component. The following components all\nhave support for the Poke Tool.\nWiring library\nPin\nClock\nMemory library\nD, T, J-K, S-R Flip-Flops\nRegister\nCounter\nShift Register\nRandom Generator\nRAM\nROM\nInput/Output library\nButton\nDip switch\nJoystick\nKeyboard\nPort I/O\nFile Viewer\nAttributes\nNone.\nClicking on a component supporting the Poke Tool, though, will\ndisplay that component's attributes."
  },
  {
    "id": 129,
    "title": "Edit Tool",
    "url": "/en/html/libs/base/edit.html",
    "text": "Multi-Tool\nMulti-Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.3.0\nBehavior\nThe Multi-Tool allows the user to select and rearrange existing components,\nand to add, move, and rearrange wires. Exactly what the tool does depends on\nwhere the user presses the mouse on the canvas. This tool is a combination of\nthe\nMove Tool and\nthe\nWiring Tool.\nDrawing Wires\nWhen the mouse is over a wiring point for an existing component,\nor if it is atop a current wire, the Multi-Tool will display a small green circle\naround the mouse's location. Clicking and dragging will create new wire\nsegments. All wires in Logisim are either horizontal or vertical, never\ndiagonal, but logisim will create an \"L\" shaped sequence of wire segments for\nyou if you drag diagonally.\nHint: Press space while dragging to bend a wire's path..\nYou can do this repeatedly to make a complicated zig-zag\npath for the wire by pressing space at each place the wire should turn a\ncorner. Press backspace while dragging to straighten a wire's path.\nEach backspace will remove a corner point resulting in fewer turns and a\nmore direct path.\nClick and drag the end of a wire to shorten or extend it, or click and drag\nthe middle of a wire segment and drag along the wire to open a gap.\nHover over the wiring point of a component to see a description of that\ninput or output.\nSome components draw short stubs near the points to which wires can connect,\nsuch as the OR gate and controlled buffer. Logisim will silently\ncorrect attempts to create wires that slightly overshoot the stub's\nend.\nSelecting, Moving, and Editing\nA simple click on wire or a component, without dragging, will simply\nselect the the component or wire segment. Holding shift\nwhile clicking a wire or component will add it to the current selection if it\nwas not there already, or will remove it if it was. After selecting the desired\nitems in the selection, you can of course cut/copy/paste/delete/duplicate all\nthe items via the Edit menu.\nClick then drag the mouse on the background (i.e. starting at a location\nnot contained within any components) to begin a rectangular selection. All\ncomponents that are fully contained by the rectangle will be selected. Holding\nshift while making a rectanglar selection will add the\nnew elements if they were not there already, or will remove them if they\nwere.\nClicking and dragging a currently-selected component or wire segment will\nbegin moving all elements of the selection.\nBy default, Logisim will compute a way to add new wires, or remove or shorten\nexisting wires, so that no existing connections are lost during the move.\nIf you're performing a move where you do not want these changes to be made, you\ncan press the shift key during the move. If you want to\ndisable this behavior entirely, go to Project > Options, select the Canvas\ntab, and uncheck the Keep Connections When Moving box; in this case, the\nconnections are computed only when the shift key\nis down.\nNote: Dragging a selection containing wires can somteimes lead to\nsurprises. If you drag a selection including some wires on top of some other\nwires, all wires are merged, and the newly-merged wires are added the\nselection.\nAs a result, if you then drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior is\nin keeping with the rule in Logisim that wires never overlap. And it does\nnot normally constitute a major problem: Logisim will draw the full\nselection in the midst of dropping, and you should not drop it until you are\nsure it is in the correct location.\nSome keys have an effect when items have been selected.\nRotate components using the arrow keys\nUp\nDown\nLeft\nRight. This\nchanges the Facing attribute for all components in the\nselection that have such an attribute.\nRemove components and wires using\nDelete or\nBackspace keys.\nThese will delete everything selected from the circuit.\nDuplicate components and wires using the\nInsert key. This will create a duplicate of all\ncurrently-selected wires and components.\nWhen duplicating a selection or pasting, Logisim does not immediately place\nthe new components into the circuit; instead, the selection will be a collection\nof \"ghosts,\" which will be dropped into the circuit as soon as they are either\ndeselected or dragged to another location.\nObsolete/Broken Features\nPressing the Alt key when clicking causes the click to be ignored.\nIf, however, the user presses the Alt key at a point in the middle of\nthe wire, then the green circle will disappear. A mouse press selects the wire,\nand a mouse drag moves it.\nHowever, if the Alt key is pressed at a location not contained within\nany components, this initiates the addition of a new wire. A small green circle\nis drawn in such a circumstance to indicate this.\nAttributes\nNone. Selecting a component, though, will display its attributes.\nWith multiple components selected, attributes shared by all are shown,\nblank if they have different values and otherwise with the value they\nall have in common. (Wires are ignored if there are any non-wires in\nthe selection.) Changes to the attribute value affect all selected\ncomponents."
  },
  {
    "id": 130,
    "title": "Select Tool",
    "url": "/en/html/libs/base/select.html",
    "text": "Move Tool\nMove Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.0 Beta 1\nBehavior\nThe Move Tool allows the user to select and rearrange existing components and\nwires. It behaves identically to the\nMulti-Tool, except that it can't add new\nwire segments or directly modify existing wires. It is mainly only for selecting\nand moving things.\nA simple click on wire or a component, without dragging, will simply\nselect the the component or wire segment. Holding shift\nwhile clicking a wire or component will add it to the current selection if it\nwas not there already, or will remove it if it was. After selecting the desired\nitems in the selection, you can of course cut/copy/paste/delete/duplicate all\nthe items via the Edit menu.\nClick then drag the mouse on the background (i.e. starting at a location\nnot contained within any components) to begin a rectangular selection. All\ncomponents that are fully contained by the rectangle will be selected. Holding\nshift while making a rectanglar selection will add the\nnew elements if they were not there already, or will remove them if they\nwere.\nClicking and dragging a currently-selected component or wire segment will\nbegin moving all elements of the selection.\nBy default, Logisim will compute a way to add new wires, or remove or shorten\nexisting wires, so that no existing connections are lost during the move.\nIf you're performing a move where you do not want these changes to be made, you\ncan press the shift key during the move. If you want to\ndisable this behavior entirely, go to Project > Options, select the Canvas\ntab, and uncheck the Keep Connections When Moving box; in this case, the\nconnections are computed only when the shift key\nis down.\nNote: Dragging a selection containing wires can somteimes lead to\nsurprises. If you drag a selection including some wires on top of some other\nwires, all wires are merged, and the newly-merged wires are added the\nselection.\nAs a result, if you then drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior is\nin keeping with the rule in Logisim that wires never overlap. And it does\nnot normally constitute a major problem: Logisim will draw the full\nselection in the midst of dropping, and you should not drop it until you are\nsure it is in the correct location.\nSome keys have an effect when items have been selected.\nRotate components using the arrow keys\nUp\nDown\nLeft\nRight. This\nchanges the Facing attribute for all components in the\nselection that have such an attribute.\nRemove components and wires using\nDelete or\nBackspace keys.\nThese will delete everything selected from the circuit.\nDuplicate components and wires using the\nInsert key. This will create a duplicate of all\ncurrently-selected wires and components.\nWhen duplicating a selection or pasting, Logisim does not immediately place\nthe new components into the circuit; instead, the selection will be a collection\nof \"ghosts,\" which will be dropped into the circuit as soon as they are either\ndeselected or dragged to another location.\nAttributes\nNone. Selecting a component, though, will display its attributes.\nWith multiple components selected, attributes shared by all are shown,\nblank if they have different values and otherwise with the value they\nall have in common. (Wires are ignored if there are any non-wires in\nthe selection.) Changes to the attribute value affect all selected\ncomponents."
  },
  {
    "id": 131,
    "title": "Wiring Tool",
    "url": "/en/html/libs/base/wiring.html",
    "text": "Wiring Tool\nWiring Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.0 Beta 1\nBehavior\nThe wiring tool is for creating wire segments that carry\nvalues from one endpoint to another. It behaves similarly to wires. It behaves\nsimilarly to the\nMulti-Tool, except that it does not select\ncomponents, it only adds new wires and modifies existing wires.\nClicking and dragging anywhere on the canvas will create a new wire or modify an\nexisting wire segment. Wires in Logisim are either horizontal or vertical, never\ndiagonal, but logisim will create an \"L\" shaped sequence of wire segments for\nyou if you drag diagonally.\nHint: Press space while dragging to bend a wire's path..\nYou can do this repeatedly to make a complicated zig-zag\npath for the wire by pressing space at each place the wire should turn a\ncorner. Press backspace while dragging to straighten a wire's path.\nEach backspace will remove a corner point resulting in fewer turns and a\nmore direct path.\nClick and drag the end of a wire to shorten or extend it, or click and drag\nthe middle of a wire segment and drag along the wire to open a gap.\nClick and drag on a blank area of the canvas to start a completely new\nwire.\nHover over the wiring point of a component to see a description of that\ninput or output.\nSome components draw short stubs near the points to which wires can connect,\nsuch as the OR gate and controlled buffer. Logisim will silently\ncorrect attempts to create wires that slightly overshoot the stub's\nend.\nAttributes\nThe wiring tool does not itself have attributes, but the wire segments that\nit creates do.\nDirection\nIndicates whether the wire segment is horizontal or vertical.\nThe value of this attribute cannot be changed.\nLength\nIndicates how many pixels long the wire is.\nThe value of this attribute cannot be changed."
  },
  {
    "id": 132,
    "title": "Text Tool",
    "url": "/en/html/libs/base/text.html",
    "text": "Text Tool\nText Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.0 Beta 1\nBehavior\nThe Text Tool can add free-form text comments to a circuit, or create and\nedit labels associated with components. Most components in the built-in\nlibraries support labels, though some do not.\nFor components that can take a label but have none assigned to it currently,\nclick anywhere within the component to add a label. If there is already\na label, click with the label to edit it.\nClick any blank area of the canvas to add a new text comment, or click an\nexisting text comment to edit it.\nAttributes\nWhen editing a label for a component, that component's attributes are\ndisplayed.\nText comments have the following attributes:\nText\nThe text appearing in the comment. This can be edited by changing the\nattribute in the attribute table, or using the\nText Tool directly the\ncanvas.\nFont\nThe font used for the comment.\nHorizontal Alignment\nControls the horiztonal alignment, as well as where the text appears relative to\nthe origin (i.e. where the mouse was clicked when creating the comment).\n\"Left\"\nuses left-alignment, and positions the text so its left edge is at the origin.\n\"Right\" uses right-alignment, and positions the text so its right edge is at the\norigin. \"Center\" horiztonally centers each line, and positions the text\nhorizontally so the center is at the origin.\nVertical Alignment\nControls the where the text appears relative to the origin (i.e. where the\nmouse was clicked when creating the comment). \"Base\" positions the text so the\norigin is at the baseline of the first line of text. \"Top\" positions the text so\nthe origin is at the top of first line of the text. \"Bottom\" positions the text\nso the origin is at the bottom of the last line of text. \"Center\" centers the\ntext vertically at the origin."
  },
  {
    "id": 133,
    "title": "Menu Tool",
    "url": "/en/html/libs/base/menu.html",
    "text": "Menu Tool\nMenu Tool\nLibrary:\nMouse Tools\nIntroduced:\n2.0 Beta 1\nBehavior\nThe Menu Tool is the default action when right-clicking, or left clicking\nwith Control held. This tool brings up a\ncontext-sensitive pop-up menu with actions, including some that might be\nrelevent to the component that was clicked.\nHint: You can change the default mouse click behavior using\nthe Mouse tab of the project options. This lets you\nchange what each mouse button does.\nThe contents of the pop-up menu depends on what was clicked. Most components\nallow cut, copy, paste, delete, and similar actions. For user-defined\ncomponents, the \"View..\" item will open up the corresponding subcircuit to\nreveal its inner state, in the same way as the magnifying glass\nwhen using the\nPoke Tool.\nAttributes\nNone."
  },
  {
    "id": 134,
    "title": "Text",
    "url": "/en/html/libs/base/label.html",
    "text": ""
  }
]
