[
  {
    "id": 1,
    "title": "Logisim R\u00e9f\u00e9rences",
    "url": "/fr/html/guide/index.html",
    "text": "Guide de l'utilisateur Logisim\nGuide l'utilisateur Logisim\nLogisim est un outil p\u00e9dagogique pour dessiner et simuler des circuits digitaux. Avec\nson interface simplifi\u00e9e pour la simulation pendant leur construction, il est assez\nais\u00e9 d'appr\u00e9hender les principes de fonctionnement des circuits logiques.\nAvec la possibilit\u00e9 d'int\u00e9grer des sous-circuits pour construire de plus larges circuits,\net la possibilit\u00e9 de tirer des nappes de c\u00e2bles d'un seul mouvement de souris, Logisim\npeut \u00eatre utilis\u00e9 (et est effectivement utilis\u00e9) pour dessiner et simuler des CPU au complet\ndans un cadre d'enseignement.\nDes \u00e9tudiants des hautes \u00e9cole et des universit\u00e9s du monde entier utilisent Logisim pour\nun \u00e9ventail d'activit\u00e9, parmi lesquelles:\nA module in general-education computer science surveys\nA unit in sophomore-level computer organization courses\nOver a full semester in upper-division computer architecture courses\nLe guide de l'utilisateur Logisim, que vous \u00eatre en train de lire, est la\nr\u00e9f\u00e9rence officielle des fonctions de Logisim. En premi\u00e8re partie, une s\u00e9rie\nde sections introduit la plupart des composants de Logisim. Ces sections sont \u00e9crites de\nmani\u00e8re \u00e0 pouvoir \u00eatre lue du d\u00e9but \u00e0 la fin. Ceci afin d'apprendre les fonctions\nessentielles de Logisim.\nGuide du d\u00e9butant\nLibrairies et attributs\nSous-circuit\nNappe de c\u00e2blage\nAnalyse combinatoire\nLes sections qui suivent sont pour la plupart une collection de r\u00e9f\u00e9rences et d'explications des\npoints moins importants de Logisim.\nR\u00e9f\u00e9rence pour les menus\nComposants m\u00e9moire\nJournalisation\nV\u00e9rification en ligne de commande\nPr\u00e9f\u00e9rences de l'application\nLes options de projet\nLa propagation des valeurs\nLibrairies JAR\nA propos du programme"
  },
  {
    "id": 2,
    "title": "Guide pour d\u00e9buter avec Logisim",
    "url": "/fr/html/guide/index.html",
    "text": "Guide de l'utilisateur Logisim\nGuide l'utilisateur Logisim\nLogisim est un outil p\u00e9dagogique pour dessiner et simuler des circuits digitaux. Avec\nson interface simplifi\u00e9e pour la simulation pendant leur construction, il est assez\nais\u00e9 d'appr\u00e9hender les principes de fonctionnement des circuits logiques.\nAvec la possibilit\u00e9 d'int\u00e9grer des sous-circuits pour construire de plus larges circuits,\net la possibilit\u00e9 de tirer des nappes de c\u00e2bles d'un seul mouvement de souris, Logisim\npeut \u00eatre utilis\u00e9 (et est effectivement utilis\u00e9) pour dessiner et simuler des CPU au complet\ndans un cadre d'enseignement.\nDes \u00e9tudiants des hautes \u00e9cole et des universit\u00e9s du monde entier utilisent Logisim pour\nun \u00e9ventail d'activit\u00e9, parmi lesquelles:\nA module in general-education computer science surveys\nA unit in sophomore-level computer organization courses\nOver a full semester in upper-division computer architecture courses\nLe guide de l'utilisateur Logisim, que vous \u00eatre en train de lire, est la\nr\u00e9f\u00e9rence officielle des fonctions de Logisim. En premi\u00e8re partie, une s\u00e9rie\nde sections introduit la plupart des composants de Logisim. Ces sections sont \u00e9crites de\nmani\u00e8re \u00e0 pouvoir \u00eatre lue du d\u00e9but \u00e0 la fin. Ceci afin d'apprendre les fonctions\nessentielles de Logisim.\nGuide du d\u00e9butant\nLibrairies et attributs\nSous-circuit\nNappe de c\u00e2blage\nAnalyse combinatoire\nLes sections qui suivent sont pour la plupart une collection de r\u00e9f\u00e9rences et d'explications des\npoints moins importants de Logisim.\nR\u00e9f\u00e9rence pour les menus\nComposants m\u00e9moire\nJournalisation\nV\u00e9rification en ligne de commande\nPr\u00e9f\u00e9rences de l'application\nLes options de projet\nLa propagation des valeurs\nLibrairies JAR\nA propos du programme"
  },
  {
    "id": 3,
    "title": "Guide du d\u00e9butant",
    "url": "/fr/html/guide/tutorial/index.html",
    "text": "Tutoriel pour d\u00e9buter\nTutoriel pour d\u00e9buter\nBienvenu \u00e0 Logisim!\nLogisim vous permet de dessiner et simuler des circuits digitaux.\nIl est destin\u00e9 \u00e0 \u00eatre utilis\u00e9 comme un outil d'enseignement, pour\nvous aider \u00e0 apprendre comme de tels circuits fonctionnent.\nComme premier exercice pratique, construisons un circuit XOR: c'est un\ncircuit qui prend deux entr\u00e9es (que nous appellerons x et y)\net dont la sortie est 0 si les deux entr\u00e9es sont identiques et 1 si elles\nsont diff\u00e9rentes.\nLa table de v\u00e9rit\u00e9 suivante illustre ce fonctionnement.\nNous pouvons dessiner un tel circuit sur le papier.\nMais justement, parce que c'est sur le papier, ne signifie pas que c'est\ncorrecte. Pour v\u00e9rifier notre travail, nous allons le dessiner dans Logisim\net le tester. Comme bonus suppl\u00e9mentaire, nous obtiendrons un circuit qui\na l'air bien mieux que ce que nous aurions pu dessiner \u00e0 la main.\nEtape 0: S'orienter\nEtape 1: Ajouter des portes logiques\nEtape 2: Ajouter des c\u00e2bles\nEtape 3: Ajouter du texte\nEtape 4: Tester le circuit\nBonne chance avec votre construction de circuits!"
  },
  {
    "id": 4,
    "title": "Etape 0: S'orienter'",
    "url": "/fr/html/guide/tutorial/tutor-orient.html",
    "text": "Tutoriel: S'orienter\nEtape 0: S'orienter\nLorsque vous d\u00e9marrer Logisim, vous verrez une fen\u00eatre semblable \u00e0 l'llustration suivante.\nCertains d\u00e9tails pourraient \u00eatre l\u00e9g\u00e8rement diff\u00e9rents suivant le syst\u00e8me utilis\u00e9.\nL'espace de Logisim est divis\u00e9 en trois parties appel\u00e9es le panneau\nde navigation, la table des attributs, et la\nsurface de travail (ou zone d'\u00e9dition). Au dessus de ces trois parties se trouvent\nla barre de menu et la barre d'outils.\nNous pouvons rapidement mettre de c\u00f4t\u00e9 le panneau de navigation et la table des\nattributs: nous ne les examinerons pas dans ce tutoriel, et vous pouvez\njuste les ignorer. Par ailleurs, la barre de menu s'explique d'elle-m\u00eame.\nIl nous reste la barre d'outils et la surface de travail. La surface de travail et\nl'endroit ou vous dessinez votre circuit; et la barre d'outils contient les outils\nqui nous permettrons d'y arriver."
  },
  {
    "id": 5,
    "title": "Etape 1: Ajouter des portes logiques",
    "url": "/fr/html/guide/tutorial/tutor-gates.html",
    "text": "Tutoriel: Ajouter des portes logiques\nEtape 1: Ajouter des portes logiques\nRappelez-vous que nous essayons de construire le circuit suivant dans Logisim.\nJe sugg\u00e8re de construire le circuit en ins\u00e9rant d'abord les portes logiques\ncomme sorte de charpente et de les connecter ensuite avec des c\u00e2bles.\nLa premi\u00e8re chose que nous allons faire c'est d'ajouter deux portes AND (portes ET).\nCliquez sur l'outil AND dans la barre d'outils\n(, l'avant dernier outil list\u00e9).\nEnsuite cliquez sur l'aire d'\u00e9dition ou vous voulez placer la premi\u00e8re porte logique AND.\nFaites attention \u00e0 laisser suffisamment de place \u00e0 gauche. Ensuite cliquez \u00e0 nouveau sur\nl'outil et placez la deuxi\u00e8me porte AND juste en dessous.\nPrenez note des cinq point sur la partie gauche de la porte logique AND. Ce sont les\nemplacements ou les c\u00e2bles peuvent \u00eatre connect\u00e9s. Il se trouve que nous n'en\nutiliserons que deux pour notre circuit XOR; mais pour d'autres circuits, vous\npourriez trouver utile d'avoir plus de deux c\u00e2bles arrivant \u00e0 une porte logique AND.\nMaintenant ajoutez les autres portes. D'abord cliquez sur l'outil OR\n();\nensuite cliquez \u00e0 l'endroit ou vous voulez placer votre porte. Placez ainsi\nles deux portes NOT sur la surface en utilisant l'outil NOT\n().\nJ'ai laiss\u00e9 un petit peu de place entre les portes NOT et les portes AND; si\nvous le souhaitez, vous pouvez cependant les placer l'une contre l'autre et \u00e9conomiser\nla peine d'avoir \u00e0 les inter-connecter avec un c\u00e2ble plus tard.\n\u00a8Maintenant nous voulons ajouter les deux entr\u00e9esx et y dans notre\ndiagramme. S\u00e9lectionnez l'outil Entr\u00e9e\n(),\net d\u00e9poser les pins (point d'entr\u00e9e ou connecteur).\nVous devez \u00e9galement placer un pin de sortie \u00e0 c\u00f4t\u00e9 de la sortie de la\nporte logique OR en utilisant l'outil sortie.\n().\n(De nouveau, je laisse un petit peu d'espace entre la porte OR et le pin\nde sortie, mais vous pouvez choisir de les coller l'un \u00e0 l'autre.)\nSi vous n'\u00eates pas satisfait avec l'emplacement de quelque chose, vous pouvez\nle s\u00e9lectionner avec l'outil d'\u00e9dition\n()\net le d\u00e9placer \u00e0 l'endroit souhait\u00e9. Ou vous pouvez le supprimer compl\u00e8tement en\ns\u00e9lectionnant l'outil effacer dans le menu Editer ou en pressant la touche effacer.\nAlors que vous disposez chaque composant du circuit, vous remarquerez qu'aussit\u00f4t que\nle composant est plac\u00e9, Logisim revient \u00e0 l'outil d'\u00e9dition de telle fa\u00e7on que vous\npuissiez d\u00e9placer le composant qui vient d'\u00eatre plac\u00e9 ou (comme nous le verrons) connecter\nle composant \u00e0 d'autres en cr\u00e9ant des c\u00e2bles. Si vous voulez ajouter une copie du composant\nnouvellement plac\u00e9, il suffit de presser Control-D pour dupliquer la s\u00e9lection.\n(Certains syst\u00e8mes utilisent d'autres touches, comme la touche commande sur les\nsyst\u00e8mes OSX. Il faut alors adapter)."
  },
  {
    "id": 6,
    "title": "Etape 2: C\u00e2blers",
    "url": "/fr/html/guide/tutorial/tutor-wires.html",
    "text": "Tutoriel: Ajouter des c\u00e2bles\nEtape 2: Ajouter des c\u00e2bles\nApr\u00e8s avoir plac\u00e9 tous les composants sur la surface de travail, vous \u00eates pr\u00eat\n\u00e0 ajouter des c\u00e2bles. S\u00e9lectionnez l'outil d'\u00e9dition\n().\nLorsque le pointeur est au-dessus d'un point qui peut \u00eatre connect\u00e9, un petit\ncercle vert appara\u00eetra autour. Pressez le bouton de la souris \u00e0 cet endroit\net tirez jusqu'\u00e0 l'endroit ou vous voulez que le c\u00e2ble arrive.\nLogisim est plus ou moins intelligent pour l'ajout de c\u00e2bles: lorsqu'un c\u00e2ble\nse termine contre un autre c\u00e2ble, Logisim les connecte automatiquement. Vous pouvez\n\u00e9galement \"rallonger\" ou \"raccourcir\" un c\u00e2ble en d\u00e9pla\u00e7ant l'une de ses\nextr\u00e9mit\u00e9s avec l'outil d'\u00e9dition.\nLes c\u00e2bles dans Logisim sont horizontaux ou verticaux. Pour connecter\nl'entr\u00e9e sup\u00e9rieure de la porte NOT avec la porte AND, j'ai donc ajout\u00e9\ntrois diff\u00e9rents c\u00e2bles.\nLogisim connecte automatiquement les c\u00e2bles au portes logiques et les\nuns aux autres. Ceci inclut le trac\u00e9 automatique du cercle \u00e0 une\nintersection en T comme ci-dessus pour indiquer que les c\u00e2bles sont\ninterconnect\u00e9s.\nLorsque vous tracez des c\u00e2bles, vous pourriez voir des c\u00e2bles bleus ou gris.\nBleu indique dans Logisim que la valeur \u00e0 cet endroit est \"inconnue\", and le gris\nindique que le cable n'est pas connect\u00e9 \u00e0 quoique ce soit. Ce n'est pas r\u00e9el\nprobl\u00e8me tant que vous \u00eates en train de construire le circuit. Mais lorsque vous\navez termin\u00e9, aucun c\u00e2ble ne devrait rester bleu ou gris. (Les pattes non connect\u00e9es\nde la porte logique OR resteront bleu, c'est en ordre).\nSi vous avez encore un c\u00e2ble bleu ou gris lorsque vous pensez que tout est connect\u00e9,\nalors quelque chose n'est pas correct. C'est tr\u00e8s important que vous\nconnectiez les c\u00e2bles \u00e0 la bonne place. Logisim dessine de petit points\nsur le composant pour indiquer ou les c\u00e2bles devraient se connecter.\nPendant votre travail, vous verrez ces petits points passer de bleu \u00e0 vert clair\nou vert fonc\u00e9.\nUne fois que tous les c\u00e2bles sont connect\u00e9s, tous les c\u00e2bles que vous avez\najout\u00e9s devront \u00eatre vert clair ou vert fonc\u00e9."
  },
  {
    "id": 7,
    "title": "Etape 3: Ajouter du texte",
    "url": "/fr/html/guide/tutorial/tutor-text.html",
    "text": "Tutoriel: Ajouter du texte\nEtape 3: Ajouter du texte\nIl n'est pas n\u00e9cessaire d'ajouter du texte dans votre circuit pour le faire fonctionner,\nmais si vous voulez pr\u00e9senter votre circuit \u00e0 quelqu'un (comme un enseignant),\nalors quelques \u00e9tiquettes permettront de mieux pr\u00e9senter le r\u00f4le\ndes diff\u00e9rents \u00e9l\u00e9ments de votre circuit.\nS\u00e9lectionnez l'outil texte\n().\nVous pouvez cliquer sur un pin d'entr\u00e9e et commencer \u00e0 taper pour\nlui assigner une \u00e9tiquette. (Il est pr\u00e9f\u00e9rable de cliquer directement sur\nle pin d'entr\u00e9e plut\u00f4t que de cliquer \u00e0 l'endroit o\u00f9 vous voulez placer le\ntexte, car de cette mani\u00e8re l'\u00e9tiquette se d\u00e9placera avec le pin).\nVous pouvez faire pareil avec le pin de sortie. Ou vous pouvez juste cliquer\nsur n'importe quel ancien emplacement et commencer \u00e0 taper du texte pour\nmettre une \u00e9tiquette n'importe o\u00f9 ailleurs."
  },
  {
    "id": 8,
    "title": "Etape 4: Tester votre circuit",
    "url": "/fr/html/guide/tutorial/tutor-test.html",
    "text": "Tutoriel: Tester votre circuit\nEtape 4: Tester votre circuit\nLa derni\u00e8re \u00e9tape est de tester notre circuit pour s'assurer qu'il fait\neffectivement ce que nous en attendons. Logisim est en fait d\u00e9j\u00e0 en train\nde simuler le circuit. Regardons \u00e0 nouveau nous en \u00e9tions.\nNotez que les deux pins d'entr\u00e9e sont \u00e0 0; et qu'il en est de m\u00eame pour le pin de sortie.\nCela nous indique d\u00e9j\u00e0 que le circuit calcule un 0 quand les deux entr\u00e9es sont \u00e0 0.\nMaintenant essayons une autre combinaison aux entr\u00e9es. S\u00e9lectionnez l'outil\npousser\n() et commencer \u00e0 pousser (presser) les entr\u00e9es\nen cliquant dessus. Chaque fois que vous poussez une entr\u00e9e, sa valeur change.\nPar exemple nous pouvons d'abord pousser l'entr\u00e9e du bas.\nQuand vous changez une valeur d'entr\u00e9e, Logisim vous indique quelles valeurs\nvoyagent le long des c\u00e2bles en les coloriant en vert clair pour indiquer une valeur \u00e0 1\nou en vert fonc\u00e9 (presque noir) pour indiquer une valeur \u00e0 0. Vous remarquerez aussi\nque la sortie a chang\u00e9 \u00e0 1.\nJusque l\u00e0 nous avons test\u00e9 les deux premi\u00e8res lignes de notre table de v\u00e9rit\u00e9,\net le r\u00e9sultat (0 and 1) correspond aux sorties souhait\u00e9es.\nEn poussant \u00e0 nouveau les pin (interrupteurs) dans des configurations diff\u00e9rentes,\nnous pouvons v\u00e9rifier les deux autres lignes. Si elles correspondent, alors\nnous avons r\u00e9ussi: le circuit fonctionne!\nPour compl\u00e9ter votre travail, vous pourriez vouloir imprimer ou sauvegarder\nvotre circuit. Le menu fichier vous permet de le faire, et bien s\u00fbr il vous\npermet aussi de sortir de Logisim. Mais pourquoi quitter maintenant?\nMaintenant que vous avez fini ce tutoriel, vous pouvez exp\u00e9rimenter plus avant\navec Logisim et construire vos propres circuits. Si vous souhaitez construire des\ncircuits plus sophistiqu\u00e9s, alors vous devriez parcourir le reste de l'aide pour\nvoir ce que vous pouvez faire d'autre. Logisim est un outil puissant qui vous\npermet de construire et tester d'immense circuits, ce petit exemple pas-\u00e0-pas\nn'a fait qu'en effleurer la surface."
  },
  {
    "id": 9,
    "title": "Librairies et attributs",
    "url": "/fr/html/guide/attrlib/index.html",
    "text": "Librairies et attributs\nLibrairies et attributs\nDans cette section, nous allons examiner comment utiliser deux r\u00e9gions principales\nde la fen\u00eatre Logisim. Le panneau de navigation et\nla table des attributs.\nLe panneau de navigation\nLa table des attributs\nAttributs des outils et des composants"
  },
  {
    "id": 10,
    "title": "Le panneau de navigation",
    "url": "/fr/html/guide/attrlib/explore.html",
    "text": "Le panneau de navigation\nLe panneau de navigation\nLogisim organise les outils dans des librairies. Elles sont\naffich\u00e9es comme des dossier dans la panneau de navigation; pour acc\u00e9der aux composants\nd'une librairie, il faut d'abord double cliquer sur le dossier correspondant.\nCi-dessous vous voyez ouverte la librairie des Portes logiques and le porte\nNAND s\u00e9lectionn\u00e9e. Vous voyez que Logisim est maintenant pr\u00eat \u00e0 ajouter des portes\nNAND dans le circuit.\nSi vous regarder le chois des portes logiques dans la librairie des portes logiques,\nvous remarquerez que n'avions pas le besoin de d\u00e9velopper un circuit XOR auparavant:\nc'est inclus dans Logisim.\nQuand vous cr\u00e9ez un projet, il inclut directement un certain nombre de librairies:\nC\u00e2blage: Les composants qui ont directement avoir avec le c\u00e2blage.\nLes portes logiques: Les composants qui r\u00e9alisent de simples fonctions logiques.\nPLexeurs: Des composants combinatoires plus complexes comme des multiplexeurs et des d\u00e9codeurs.\nArithmetique: Des composants qui effectuent des op\u00e9rations arithm\u00e9tiques.\nM\u00e9moire: Des composant qui m\u00e9morisent des informations comme des bascules, des registres et de la RAM.\nI/O: Des composants qui sont l\u00e0 pour permettre des interactions avec l'utilisateur.\nBase: Des outils qui sont int\u00e9gr\u00e9 dans l'interface de Logisim, c'est pourquoi vous n'aurez\nprobablement pas besoin d'ouvrir cette librairie.\nLogisim vous permet d'ajouter plus de librairies en utilisant le sous-menu\ncharger une librairie dans le menu Projet.\nVous pouvez voir que Logisim a trois cat\u00e9gories de librairies.\nLes librairies int\u00e9gr\u00e9es sont des librairies qui sont distribu\u00e9es\navec Logisim. Ces derni\u00e8res sont document\u00e9es dans\nLibrairie de r\u00e9f\u00e9rence.\nLes librairies Logisim sont des projets construits dans\nLogisim et sauvegard\u00e9es comme des projets logisim. Vous pouvez d\u00e9velopper\nun ensemble de circuits dans un seul projet (comme d\u00e9crit dans la section\nSous-circuit de ce guide)\net utiliser cet ensemble de circuit comme une librairie dans d'autres projets.\nLes librairies JAR qui sont des librairie qui sont d\u00e9velopp\u00e9es\nen Java mais ne sont pas distribu\u00e9es avec Logisim. Vous pouvez t\u00e9l\u00e9charger une\nlibrairie \u00e9crite par quelqu'un d'autre, ou vous pouvez \u00e9crire votre\npropre librairie comme expliqu\u00e9 dans la section Librairies Jar de ce guide.\nD\u00e9velopper une librairie JAR est bien plus difficile que de d\u00e9velopper une librairie Logisim, mais\nle composant peut \u00eatre bien plus riche en incluant des attributs et des\ninteractions avec l'utilisateur.\nLes librairies int\u00e9gr\u00e9es (autres que Base) sont \u00e9crites en utilisant les\nm\u00eames API que les librairies JAR. Elles d\u00e9montrent donc les possibilit\u00e9s,\nen terme de fonctionnalit\u00e9, qu'une librairie JAR peut supporter.\nCertaines des librairies JAR sont distribu\u00e9es sans aucune information \u00e0 propos\nd'avec quelle classe Java il faut d\u00e9buter. Quand un tel JAR est charg\u00e9, Logisim\nvous demandera alors d'indiquer un nom de classe. Ce nom de classe devrait\n\u00eatre fourni par celui qui distribue le fichier JAR.\nPour enlever une librairie, choisissez enelver Librairie ... depuis le\nmenu Projet. Logisim vous emp\u00eachera d'enlever des librairies qui contiennent\ndes composant actuellement utilis\u00e9es dans le circuit, qui apparaissent dans\nla barre d'outils ou qui sont li\u00e9es au pointeur.\nPar ailleurs, une librairie contient en fait d'un point de vue technique des outils,\net non des composants. Par cons\u00e9quent, dans la librairie de base vous trouvez l'outil Pousser\n(), l'outil \u00e9diter\n(), et d'autres outils qui ne\ncorrespondent pas directement \u00e0 des composants particuliers.\nLa plupart des librairies, contiennent malgr\u00e9 tout des outils pour ajouter\ndes composants; toutes les autres librairies que la librairie Base sont ainsi."
  },
  {
    "id": 11,
    "title": "Le tableau des attributs",
    "url": "/fr/html/guide/attrlib/attr.html",
    "text": "La table des attributs\nLa table des attributs\nLa plupart des composants ont des attributs, qui sont\ndes propri\u00e9t\u00e9s pour configurer comment les composants se comportent\net apparaissent. La table des attributs permet d'afficher\nles valeurs des attributs.\nPour s\u00e9lectionner les attributs d'un composant, cliquez sur le composant\nen utilisant l'outil d'\u00e9dition().\n(Il est aussi possible de faire un clic droite (ou control-clic) sur le\ncomposant et choisir Afficher les attributs du menu contextuel. Il est\naussi possible d'afficher les attributs du composant avec l'outil\npousser\n() ou l'outil texte\n() .)\nL'\u00e9cran ci-dessous illustre ce qui se passe apr\u00e8s avoir s\u00e9lectionn\u00e9\nl'entr\u00e9e en haut d'un circuit XOR et de d\u00e9filer en bas pour voir\nle label Police de l'attribut.\nPour modifier la valeur d'un attribut, cliquez sur cette valeur.\nL'interface de modification d\u00e9pendra de quel attribut il s'agit de\nmodifier; dans le cas de la Police du label, une bo\u00eete de dialogue\nappara\u00eetra pour s\u00e9lectionner la nouvelle police; mais dans le cas de certains\nattributs (comme le label), il vous sera propos\u00e9 un champ texte,\nalors que dans d'autre cas, un menu d\u00e9roulant vous permettra\nde s\u00e9lectionner une valeur.\nChaque type de composant a un ensemble diff\u00e9rent d'attributs; pour\napprendre ce qu'ils signifient, la document appropri\u00e9e se trouve\ndans la\nLibrairie de r\u00e9f\u00e9rences.\nSi vous avez s\u00e9lectionn\u00e9 plusieurs composant en utilisant l'outil\nd'\u00e9dition, alors la table d'attribut ne montrer que les attributs communs\naux diff\u00e9rents composants s\u00e9lectionn\u00e9s (\u00e0 l'exclusion des c\u00e2bles). Si les\ncomposants s\u00e9lectionn\u00e9s n'ont pas la m\u00eame valeur pour un attribut, alors\nla valeur pour cette attribut sera un espace blanc. Vous pouvez changer\nla valeur pour tous les attributs s\u00e9lectionn\u00e9 en une fois en \u00e9ditant cette\nvaleur."
  },
  {
    "id": 12,
    "title": "Attributs des outils et des composants",
    "url": "/fr/html/guide/attrlib/tool.html",
    "text": "Attributs des outils\nAttributs des outils\nChaque outil pour ajouter des composants dans un circuit a aussi un ensemble\nd'attributs, qui sont attribu\u00e9s aux composants cr\u00e9\u00e9s par l'outils, bien\nque par la suite les attributs d'un composant puissent \u00eatre modifi\u00e9s ind\u00e9pendamment\ndes attributs de l'outil. Quand vous s\u00e9lectionnez un outil, Logisim\nva mettre \u00e0 jour la table des attributs pour afficher les attributs de l'outil.\nSupposons par exemple que nous voulions cr\u00e9er de plus petites portes AND.\nPour le moment, chaque fois que nous s\u00e9lectionnions l'outil AND, il cr\u00e9e\nune grande porte AND. Mais si nous \u00e9ditons les attributs juste apr\u00e8s\navoir s\u00e9lectionn\u00e9 l'outil (avant de placer une porte AND dans le circuit), alors\nnous allons changer les attributs pour l'outil, de cette fa\u00e7on les porte AND que nous\najouterons dans le futur en utilisant cet outil seront plus petites.\nMaintenant, nous pouvons effacer les deux portes AND existantes et en\najouter de nouvelles \u00e0 la place. Cette fois, elles seront plus petites.\n(si vous choisissez de r\u00e9duire le nombre d'entr\u00e9es \u00e0 3, la porte logique\nAND aura alors des extensions verticales \u00e0 gauche. Mais vous devrez \u00e9galement\nrec\u00e2bler le circuit de fa\u00e7on \u00e0 ce que les c\u00e2bles atteignent le flanc gauche\nde la porte AND.)\nAvec certains outils, l'ic\u00f4ne de l'outil refl\u00e8te certaines valeurs des\nattributs. Un exemple de cela et l'outil Pin, dont l'ic\u00f4ne s'affiche\nselon ce que l'attribut affichage dit.\nLes outils dans la barre d'outils ont tous un ensemble d'attributs s\u00e9par\u00e9\nde l'outil correspondant dans le panneau d'exploration. C'est pourquoi,\nm\u00eame si nous changeons l'outil AND de la barre d'outils pour cr\u00e9er une\npetite porte logique AND, la porte logique AND de la librairie restera\nplus grande, sauf si nous changeons ses attributs\nEn fait, les outils pin dans la barre d'outil par d\u00e9faut sont deux instance\ndes pins de la librairie de cablage, mais les ensembles d'attributs sont\ndiff\u00e9rents. L'ic\u00f4ne pour l'outil pin est repr\u00e9sent\u00e9 par un circle\ndans un car\u00e9 suivant la valeur de son attribut \"Sortie ?\"\nLogisim fourni des raccourci pratiques pour changer l'attribut d'apparence\nqui contr\u00f4le la direction dans laquelle se trouve la repr\u00e9sentation du composant:\npresser la touche fl\u00e8che gauche quand l'outil est s\u00e9lectionn\u00e9 va automatiquement\nchanger l'orientation du composant."
  },
  {
    "id": 13,
    "title": "Sous-circuits",
    "url": "/fr/html/guide/subcirc/index.html",
    "text": "Subcircuits\nSubcircuits\nAs you build circuits that are more and more sophisticated, you will\nwant to build smaller circuits that you can use multiple times\nas a module nested within larger circuits.\nIn Logisim, such a smaller circuit that is used in a larger\ncircuit is called a subcircuit.\nIf you're familiar with computer programming, you're familiar with\nthe subprogram concept, whether it's called a subroutine,\nfunction, method, or procedure in your\nfavored language.\nThe subcircuit concept is analogous to this, and it serves the same purpose:\nTo break a large job into bite-sized pieces,\nto save the effort of defining the same concept multiple times, and to\nfacilitate debugging.\nCreating circuits\nUsing subcircuits\nEditing subcircuit appearance\nDebugging subcircuits\nLogisim libraries"
  },
  {
    "id": 14,
    "title": "Cr\u00e9er des circuits",
    "url": "/fr/html/guide/subcirc/creating.html",
    "text": "Creating circuits\nCreating circuits\nEvery Logisim project is actually a library of circuits. In\nits simplest form, each project has only one circuit (called\n\"main\" by default), but it is easy to add more:\nSelect Add Circuit... from the Project menu, and type any name\nyou like for the new circuit you want to create.\nSuppose we want to build a 2-to-1 multiplexer named \"2:1 MUX.\"\nAfter adding the circuit, Logisim will look like this.\nIn the explorer pane, you can now see that the project now\ncontains two circuits, \"main\", and \"2:1 MUX.\" Logisim draws a\nmagnifying glass over the icon of the circuit currently being\nviewed; the current circuit name also appears in the window's\ntitle bar.\nAfter editing the circuit to appear like a 2:1 multiplexer,\nwe might end up with the following circuit."
  },
  {
    "id": 15,
    "title": "Utiliser des sous-circuits",
    "url": "/fr/html/guide/subcirc/using.html",
    "text": "Using subcircuits\nUsing subcircuits\nNow suppose we want to build a 4-to-1 multiplexer using\ninstances of our 2-to-1 multiplexer. Of course, we would first create\na new circuit, which we'll call \"4:1 MUX.\" To add 2-to-1 multiplexers\ninto our circuit, we click the 2:1 MUX circuit once in the\nexplorer pane to select it as a tool, and then we can add copies of\nit, represented as boxes, by clicking within the canvas.\nIf you were to double-click the 2:1 MUX circuit in the explorer pane,\nthen the window would switch to editing the 2:1 MUX circuit instead.\nAfter building up the circuit, we end up with the following.\nOur circuit for a 4-to-1 multiplexer uses three copies of the\n2-to-1 multiplexer, each drawn as a box with pins along the side.\nThe pins on this box correspond to the input and output pins in the\n2:1 MUX circuit.\nThe two pins on the west side of the box correspond\nto the two pins that face east in the 2:1 MUX circuit; the pin on\nthe box's east side corresponds to the 2:1 MUX's west-facing pin\n(which happens to be an output pin); and the pin on the box's south\nside corresponds to the 2:1 MUX's north-facing pin.\nThe order of\nthe two pins on the box's west side correspond to the same top-down\nordering from the subcircuit's design.\n(If there were several pins\non the box's north or south side, they would correspond to the same\nleft-right order in the subcircuit.)\nIf the pins in the subcircuit's layout have labels associated with\nthem, then Logisim will display that label in a tip\n(that is, a temporary text box) when the user hovers the mouse over the\ncorresponding location of the subcircuit component. (If you find these\ntips irritating, you can disable them via the\nPreferences window's Layout\ntab.)\nSeveral other components will display these tips, too: For some of the\npins of a built-in flip-flop,\nfor example, hovering over it explains what that pin does.\nIncidentally, every pin to a circuit must be either an input or\nan output. Many manufactured chips have pins that behave as an input\nin some situations and as an output in others; you cannot construct\nsuch chips within Logisim (at least, in the current version).\nLogisim will maintain different state information for all subcircuits\nappearing in a circuit. For example, if a circuit contains a\nflip-flop, and that circuit is used as a subcircuit several\ntimes, then each subcircuit's flip-flop will have its own value\nwhen simulating the larger circuit.\nNow that we have the 4-to-1 multiplexer defined, we can now use it\nin other circuits. Logisim has no limits on how deeply circuits\ncan be nested - though it will object to nesting circuits within\nthemselves!\nNote: There's nothing wrong with editing a\ncircuit that is being used as a subcircuit; in fact, this is quite\ncommon. Be aware, though, that any changes to a circuit's pins (adding,\ndeleting, or moving them) will rearrange them also in the containing\ncircuit. Thus, if you change any pins in a circuit, you will also\nneed to edit any circuits using it as a subcircuit."
  },
  {
    "id": 16,
    "title": "Editer l'apparence d'un sous-circuit",
    "url": "/fr/html/guide/subcirc/appear.html",
    "text": "Editing subcircuit appearance\nEditing subcircuit appearance\nDefault appearance\nBy default, when a subcircuit is placed within a larger circuit, it is drawn\nas a rectangle with a notch indicating the north end of the subcircuit's\nlayout. Pins will be placed on the rectangle's border based on their facing:\nPins that face east in the layout (and typically appear on the west side\nof the layout) will be placed on the rectangle's west side,\naccording to their top-down ordering in the layout.\nPins that face south in the layout (typically toward the north side of the layout)\nwill be placed on the rectangle's north side, according to the left-to-right\nordering in the layout.\nThe default rectangle can optionally include some letters that will appear\nin the middle of the rectangle. To specify this, select the selection tool\n() and click the background of the circuit's\nlayout. This will show the circuit attributes in the attribute table, including\nthe Shared Label, Shared Label Facing, and Shared Label Font attributes.\nThe value of the Shared Label attribute will be drawn in the rectangle's center;\nthe Shared Label Facing attribute customizes which direction the text is drawn,\nand of course the Shared Label Font attribute customizes the font used.\nCustomized appearance\nThe default appearance is very usable, and indeed Logisim existed for many\nyears with no other option. If, however, you prefer that the subcircuit be\ndrawn differently, you can select Edit Circuit Appearance from the\nProject menu, and Logisim's interface will switch from its regular\nlayout-editing interface to an interface for drawing the circuit's\nappearance.\n(You can also click the far-right icon ()\nin the explorer pane's upper toolbar.)\nBelow, we are editing the 2:1 multiplexer's appearance so that\nit is drawn with the usual trapezoid rather than a rectangle.\nWith the appearance for the 2:1 multiplexer drawn as above,\nthe layout for the 4:1 multiplexer would then appear as the following.\nThe appearance editor is like a traditional drawing program, but there\nare a few special symbols for indicating how the drawing works when placed\ninto a circuit's layout. These special symbols cannot be removed.\nThe green circle with a line coming out of it, which we'll call the anchor.\nThere is exactly one anchor in each subcircuit appearance.\nEach component in a circuit has a single point identifying its location;\na user sees this when creating a new component:\nThe mouse click identifies just a single location, and the component is placed\nrelative to that (usually with the primary output at the mouse's location)\nThe anchor identifies the mouse's location relative to the overall drawing\nwhen the subcircuit is created.\nThe anchor also identifies the appearance's facing, as indicated by the\ndirection the anchor's line points from its circle. When placing the subcircuit\ninto a layout, the user can change the subcircuit's facing; the anchor's facing\nindicates in which direction the appearance is oriented. In our example, the\nanchor is facing east, and each instance of the subcircuit in the 4:1 multiplexer\nis also facing east, so they are all drawn in the same orientation as the 2:1\nmultiplexer's appearance.\nThe blue circles and squares with dots in them are the subcircuit's\nports. There are exactly as many ports as there are input and output\npins in the circuit.\nPorts corresponding to inputs are drawn as squares, while ports corresponding\nto outputs are drawn as circles.\nEach port indicates how a wire connecting into the\ncircuit will correspond to an input or output pin within the layout.\nWhen you select a port, Logisim will indicate the corresponding pin\nby popping up a miniature diagram of the layout in the window's bottom right\ncorner, with the corresponding pin(s) drawn in blue. This does not happen when\nall ports are selected.\nThe toolbar contains tools for adding additional shapes, as listed below\nwith descriptions of how the shift and alt key modifies the tool behavior. In\naddition, clicking or dragging the mouse with the control key pressed regularly\nsnaps the mouse position to the nearest grid point.\nSelect, move, copy, and paste shapes.\nAdd or edit text.\nCreate a line segment. Shift-drag keeps the line's angle at a multiple of 45\u00b0.\nCreate a quadratic Bezier curve.\nFor the first drag, where you specify the curve's endpoints,\nshift-drag keeps the endpoints at an angle that is a multiple of 45\u00b0.\nThen you click to indicate the control point's location;\nshift-click ensures the curve is symmetric,\nwhile alt-click draws the curve through the control point.\nCreate a sequence of connected lines, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the angle between the\nprevious vertex and the current one is a multiple of 45\u00b0.\nDouble-click or press the Enter key to complete the\nshape.\nCreate a rectangle through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate a rectangle with rounded corners through dragging from one corner to the opposite corner.\nShift-drag to create a square, and alt-drag to create the rectangle starting\nfrom the center.\nCreate an oval through dragging from one corner of its bounding box to the opposite corner.\nShift-drag to create a circle, and alt-drag to create the oval starting\nfrom the center.\nCreate an arbitrary polygon, whose vertices are indicated by\na succession of clicks. Shift-clicking ensures that the vertex is at a 45\u00b0\nangle from the previous one. Double-click, press the Enter key, or click the\nstarting vertex to complete the shape."
  },
  {
    "id": 17,
    "title": "D\u00e9boguer un sous-circuit",
    "url": "/fr/html/guide/subcirc/debug.html",
    "text": "Debugging subcircuits\nDebugging subcircuits\nAs you test larger circuits, you will likely find bugs. To nail down\nwhat's going wrong, exploring what's going on in the subcircuits while\nrunning the overall circuit can help. To enter the subcircuit's state, you can\nuse any of three different techniques. The most straightforward is probably\nto view the simulation hierarchy by clicking the second icon in the explorer\npane's upper toolbar (), or by selecting\n\"View Simulation Tree\" from the Project menu. This switches\nthe explorer pane so that it shows the hierarchy of subcircuits being simulated.\nDouble-clicking an element in this hierarchy will display what is happening\ninside that subcircuit.\nThe second way you can enter a subcircuit is to bring up its popup menu\nby right-clicking or control-clicking it, and then choosing the View option.\nAnd the third way is to first ensure the Poke Tool is selected\nand then click the subcircuit you want to enter;\na magnifying glass will appear over the subcircuit's center, and\ndouble-clicking the magnifying glass will enter\nthe subcircuit's state.\nIn any case, once you enter the subcircuit, you'll see that the pins' values\nin the subcircuit match the values being sent through them from the containing\ncircuit.\nWhile in the subcircuit, you are allowed to alter the circuit. If the\nchanges affect any of the subcircuit's outputs, they are propagated into the\ncontaining circuit. One exception: The subcircuit inputs are determined based on\nthe values coming into the circuit from the supercircuit, so it doesn't make\nsense to toggle those values. If you attempt to poke a subcircuit's input,\na dialog will pop up asking, The pin is tied to the supercircuit state.\nCreate a new circuit state? Clicking No will cancel the toggle request,\nwhile clicking Yes will create a copy of the viewed state,\ndivorced from the outer circuit, with the input pin toggled.\nOnce you have completed viewing and/or editing, you can return to the parent circuit\neither by double-clicking the parent circuit in the explorer pane, or via the Go Out\nTo State submenu of the Simulate menu."
  },
  {
    "id": 18,
    "title": "Librairies Logisim",
    "url": "/fr/html/guide/subcirc/library.html",
    "text": "Logisim libraries\nLogisim libraries\nEvery Logisim project is automatically a library that can be loaded\ninto other Logisim projects: Just save it into a file and then load\nthe library within another project. All of the circuits defined in the\nfirst project will then be available as subcircuits for the second.\nThis feature allows you to reuse common components across projects\nand to share favorite components with your friends (or students).\nEach project has a designated \"main circuit,\" which can be changed\nto refer to the current circuit via the Set As Main Circuit option\nin the Project menu. The only significance of this is that\nthe main circuit is the one that is displayed when you first open\nthe project.\nThe default name of the circuit in a newly created file\n(\"main\") has no significance at all, and you can feel free to delete\nor rename that circuit.\nWith a loaded Logisim library, you are allowed to view circuits and\nmanipulate their states, but Logisim will prevent you from altering\nthe circuits' design and other data stored within the file.\nIf you want to alter a circuit in a loaded Logisim library, then\nyou need to open it separately within Logisim. As soon as you save\nit, the other project should automatically load the modified version\nimmediately; but if it does not, you can right-click the library\nfolder in the explorer pane and select Reload Library."
  },
  {
    "id": 19,
    "title": "Nappe de c\u00e2bles",
    "url": "/fr/html/guide/bundles/index.html",
    "text": "Groupes de c\u00e2bles\nGroupes de c\u00e2bles\nDans un simple circuit Logisim, la plupart des c\u00e2ble ne transportent qu'un seul bit;\nmais Logisim permet \u00e9galement de cr\u00e9er des groupes de cables (nappes de c\u00e2bles) qui\ntransportent plusieurs bits.\nLe nombre de bits circulant le long de ce c\u00e2ble et la largeur en bit\nde ce c\u00e2ble.\nCr\u00e9er des groupes\nS\u00e9parateurs\nCouleurs des c\u00e2bles"
  },
  {
    "id": 20,
    "title": "Cr\u00e9er une nappe",
    "url": "/fr/html/guide/bundles/creating.html",
    "text": "Cr\u00e9er des Nappes de c\u00e2bles\nCr\u00e9er des Nappes de c\u00e2bles\nChaque entr\u00e9e/sortie de chaque composant dans un circuit a une largeur de bit\nassoci\u00e9e. Souvent la largeur est de 1, et il n'y a pas moyen de changer\ncela, mais plusieurs composants de la librairie de Logisim incluent des\nattributs qui vous permettent de changer la largeur de bit des entr\u00e9es et sorties.\nLa saisie d'\u00e9cran ci-dessous illustre un circuit simple pour trouver la combinaison AND\nd'entr\u00e9es \u00e0 trois bit. Noter comment la sortie \u00e0 trois bit est la combinaison AND des\ndeux entr\u00e9es. Tous les composants ont \u00e9t\u00e9 modifi\u00e9s pour g\u00e9rer avec des donn\u00e9es trois bits\nvia l'attribut Data Bit; l'\u00e9cran montre les attributs de la porte logique AND, y compris\nle Data Bits de 3.\nTous les composants dans Logisim d\u00e9finissent une largeur en bit\npour chaque entr\u00e9e et sortie. Par contraste, la largeur d'un c\u00e2ble est\nnon-d\u00e9finie: par contre, la largeur du c\u00e2ble s'adapte aux composants\nauxquels il est attach\u00e9.\nSi un c\u00e2ble relie deux composants avec des largeurs en bits diff\u00e9rentes,\nLogisim se plaint d'une \"Largeur incompatible\" et indique l'endroit du\nconflit avec de l'orange.\nDans l'exemple ci-dessous, les Bits Data du pin de sortie ont \u00e9t\u00e9 chang\u00e9s\n\u00e0 une largeur de 1, et Logisim se plaint que le c\u00e2ble est\nconnect\u00e9 \u00e0 une\nvaleur \u00e0 trois bits et une valeur \u00e0 un bit.\nLes c\u00e2bles qui relient des points incompatibles (repr\u00e9sent\u00e9 en orange) ne\ntransporte aucune valeur.\nPour les c\u00e2bles \u00e0 un seul bit, vous pouvez voir d'un seul coup d'oeil quelle\nvaleur est transport\u00e9e par le c\u00e2ble pare que Logisim les colorise avec du vert\nclair ou fonc\u00e9 en fonction de la valeur.\nCe n'est pas le cas pour des c\u00e2bles multi-bits: ils sont simplement noirs.\nVous pouvez malgr\u00e9 tout sonder le c\u00e2ble en cliquant dessus avec l'outil\npousser. ().\nCette valeur de sonde est utile pour d\u00e9boguer les circuits utilisant des nappes\nde c\u00e2bles."
  },
  {
    "id": 21,
    "title": "Eclat\u00e9",
    "url": "/fr/html/guide/bundles/splitting.html",
    "text": "S\u00e9parateurs\nS\u00e9parateurs\nQuand vous travailler avec des valeurs \u00e0 plusieurs bits, vous voudrez souvent\nrediriger diff\u00e9rents bits dans diff\u00e9rentes directions. L'outil de la librairie\nSplitter () vous permet de r\u00e9aliser cela.\nSupposons par exemple que vous vouliez un circuit qui combine avec une porte AND les\ndeux quartets de son entr\u00e9e \u00e0 huit bits (les quatre bits de poids fort et les quatre bit\nde poids faible). Nous aurons une valeur \u00e0 huit bit venant du pin (bus) d'entr\u00e9e et nous\nvoulons s\u00e9parer ceci en deux valeur \u00e0 quatre bits. Dans le circuit ci-dessous, nous avons\nutilis\u00e9 un s\u00e9parateur pour r\u00e9aliser cela; l'entr\u00e9e 8 bits est connect\u00e9 \u00e0 l'entr\u00e9e\ndu s\u00e9parateur, qui la divise en deux quartets, qui sont entr\u00e9s dans la porte logique AND\net ensuite le r\u00e9sultat est en sortie.\nDans cet exemple, le s\u00e9parateur s\u00e9pare une valeur en entr\u00e9e en plusieurs\nvaleurs en sortie. Mais les s\u00e9parateurs peuvent aussi travailler d'une autre fa\u00e7on: il peut\ncombiner plusieurs valeurs en une seule. En fait, ils n'ont pas de direction: ils\npeuvent envoyer une valeur dans une direction \u00e0 un moment et dans une autre plus tard, et\nils peuvent m\u00eame faire les deux en m\u00eame temps, comme dans l'exemple ci-dessous ou une valeur\nvoyage vers l'Est \u00e0 travers les deux s\u00e9parateurs, ensuite elle est re-dirig\u00e9e vers l'Ouest \u00e0\ntravers les s\u00e9parateurs \u00e0 nouveau, et ensuite de nouveau vers l'Est ou elle atteint sa sortie.\nLa cl\u00e9 pour comprendre les s\u00e9parateurs tient dans leurs attributs.\nDans ce qui suit, le terme terminaison s\u00e9par\u00e9e fait r\u00e9f\u00e9rence \u00e0 l'un\ndes multiples c\u00e2bles d'un c\u00f4t\u00e9, tandis que terminaison combin\u00e9e fait r\u00e9f\u00e9rence\n\u00e0 la seule sortie de l'autre c\u00f4t\u00e9.\nL'attribut pr\u00e9sentation d\u00e9finit ou la terminaison s\u00e9par\u00e9e devrait \u00eatre\npositionn\u00e9e par rapport \u00e0 la terminaison combin\u00e9e.\nL'attribut Sortie ventil\u00e9e d\u00e9fini combien de terminaisons s\u00e9par\u00e9es il doit\ny avoir.\nL'attribut Largeur de bit en entr\u00e9e sp\u00e9cifie la largeur en bit de la terminaison\ncombin\u00e9e.\nL'attribut Bit x d\u00e9fini quel terminaison s\u00e9par\u00e9e correspond\n\u00e0 quel bit x de la terminaison combin\u00e9e. Si plusieurs bits correspondent \u00e0 la m\u00eame\nterminaison s\u00e9par\u00e9e, alors l'ordre relatif sera le m\u00eame que dans la terminaison combin\u00e9e.\nLes s\u00e9parateurs Logisim ne peuvent pas avoir un bit de la sortie combin\u00e9e qui corresponde\n\u00e0 plusieurs terminaisons s\u00e9par\u00e9es.\nNotez que chaque changement \u00e0 la sortie ventil\u00e9e ou \u00e0 la largeur en bit dans les attributs va\nremettre \u00e0 z\u00e9ro les attributs de tous les bits x de fa\u00e7on \u00e0 distribuer les\nbits de la valeur combin\u00e9e aussi r\u00e9guli\u00e8rement que possible selon les terminaisons s\u00e9par\u00e9es."
  },
  {
    "id": 22,
    "title": "Couleur des c\u00e2bles",
    "url": "/fr/html/guide/bundles/colors.html",
    "text": "Couleurs du c\u00e2blage\nCouleurs du c\u00e2blage\nNous sommes maintenant en mesure de r\u00e9sumer l'ensemble\nde l'arc-en-ciel des couleurs que Logisim peut utiliser pour les c\u00e2bles.\nLe circuit suivant les illustre toutes.\nGris: La largeur en bit du cabl\u00e2ge est\ninconnue. Ceci arrive parce que le c\u00e2ble n'est attach\u00e9 \u00e0\naucune entr\u00e9e ni sortie de composant. (Toutes les entr\u00e9es et sorties ont\nune largeur de bit d\u00e9finie.)\nBleu: Le c\u00e2ble transporte une valeur \u00e0 un bit, mais rien\nne force une valeur sp\u00e9cifique sur le c\u00e2ble. Nous appelons ceci une un bit\nflotant; certains l'appel une valeur de haute imp\u00e9dence.\nDans cet exemple, le composant qui envoie une valeur sur le c\u00e2ble est\nun bit \u00e0 trois \u00e9tats, il peut donc \u00e9mettre cette valeur flottante.\nVert fonc\u00e9: Le c\u00e2ble transporte une valeur \u00e0 un bit de 0.\nVert clair: Le c\u00e2ble transporte une valeur \u00e0 un bit de 1.\nNoir: Le c\u00e2ble transporte une valeur de plusieurs bits.\nCertains ou tous les bits peuvent \u00eatre ind\u00e9termin\u00e9s.\nRouge: Le c\u00e2ble transporte une valeur d'erreur. Ceci arrive souvent\nparce qu'une porte logique ne peut pas d\u00e9terminer correctement sa sortie,\npeut-\u00eatre parce qu'elle ne re\u00e7oit aucune entr\u00e9e. Ceci peut aussi arriver parce que deux\ncomposants essayent d'envoyer deux valeurs diff\u00e9rentes sur le c\u00e2ble.\nThe wire is carrying an error value; Ceci arrive dans l'exemple ci-dessus parce que l'un des\nbits de sortie envoie 0 sur le c\u00e2ble et l'autre envoie 1 sur le m\u00eame c\u00e2ble, ce qui\ncause un conflit.\nLes c\u00e2bles multi-bit deviennent rouge quand l'un des bits transporte une valeur d'erreur.\nOrange: Les composants reli\u00e9s au c\u00e2ble n'ont pas la\nm\u00eame largeur de bits. Un c\u00e2ble orange est effectivement \"cass\u00e9\": il ne\ntransporte aucune valeur entre les composants. Ici nous avons reli\u00e9 un composant\n\u00e0 deux bits \u00e0 un composant \u00e0 un bit, ils sont donc incompatibles."
  },
  {
    "id": 23,
    "title": "Analyse combinatoire",
    "url": "/fr/html/guide/analyze/index.html",
    "text": "Analyse combinatoire\nAnalyse combinatoires\nTous les circuits appartiennent \u00e0 l'une des deux cat\u00e9gories:\nDans un circuit combinatoire, toutes les sorties\ndu circuit sont strictement une combinaison des entr\u00e9es\ndu circuit.\nAlors que dans un circuit s\u00e9quentiel, certaines\nsorties d\u00e9pendent des entr\u00e9es ant\u00e9rieures (la s\u00e9quence des\nentr\u00e9es au cours du temps).\nLes circuits de la cat\u00e9gorie combinatoire est la plus simple des deux.\nThe category of combinational circuits is the simpler of the\ntwo. Les professionnels utilisent trois techniques principales\npour r\u00e9sumer le comportement de tels circuits.\nDes circuits logiques\nDes expressions bool\u00e9ennes, qui permettent une repr\u00e9sentation alg\u00e9brique\ndu fonctionnement du circuit.\nDes tables de v\u00e9rit\u00e9 qui \u00e9num\u00e8rent toutes les combinaisons d'entr\u00e9es possibles\net les sorties correspondantes.\nLe module d'Analyse Combinatoire permet de convertir une repr\u00e9sentation\ndans n'importe laquelle des trois autres. Ceci est une fa\u00e7on particuli\u00e8rement\npratique de cr\u00e9er et comprendre des circuits avec une poign\u00e9e d'entr\u00e9es et de\nsorties \u00e0 un bit.\nOuvrir l'analyse combinatoire\nEditer la table de v\u00e9rit\u00e9\nCr\u00e9er une expression\nConstruire un circuit"
  },
  {
    "id": 24,
    "title": "Ouvrir l'analyse combinatoire",
    "url": "/fr/html/guide/analyze/open.html",
    "text": "Ouvrir l'Analyse Combinatoire\nOuvrir l'Analyse Combinatoire\nL'essentiel du module d'Analyse Combinatoire est accessible par une seule\nfen\u00eatre du m\u00eame nom qui vous permet de voir la table de v\u00e9rit\u00e9 et les\nexpressions bool\u00e9ennes. Cette fen\u00eatre s'ouvre de deux mani\u00e8res.\nVia le menu Window\nS\u00e9lectionnez l'analyse combinatoire et la fen\u00eatre \"Analyse Combinatoire\"\nappara\u00eetra. Si vous n'avez encore jamais vu cette fen\u00eatre, cette derni\u00e8re\nne repr\u00e9sente aucun circuit.\nIl ne peut y avoir qu'une seule fen\u00eatre \"Analyse Combinatoire\"\ndans Logisim, quel que soit le nombre de projets ouverts. Il n'y a\naucun moyen d'ouvrir deux fen\u00eatre \"Analyse Combinatoire\" en m\u00eame temps.\nVia le menu Projet\nDepuis une fen\u00eatre d'\u00e9dition de circuit, il est aussi possible de\ndemander \u00e0 Logisim l'analyse du circuit courant en s\u00e9lectionnant\nl'option \"Analyser le circuit\" depuis le menu Projet.\nAvant que Logisim ouvre la fen\u00eatre, il va \u00e9laborer les expression\nbool\u00e9ennes et la table de v\u00e9rit\u00e9 correspondante au circuit et les\nafficher pour la visualisation.\nPour qu'une analyse soir couronn\u00e9e de succ\u00e8s, chaque entr\u00e9e doit \u00eatre\nli\u00e9e \u00e0 un pin d'entr\u00e9e et chaque sortie \u00e0 un pin de sortie.\nLogisim n'analysera que les circuits avec au plus huit entr\u00e9es ou huit\nsorties, et toutes devront \u00eatre des pin simples. Dans le cas contraire,\nvous verrez un message d'erreur et la fen\u00eatre n'appara\u00eetra pas.\nDans l'\u00e9laboration d'expressions bool\u00e9ennes correspondant \u00e0 un circuit,\nLogisim essayera d'abord de construire une expression bool\u00e9enne\ncorrespondant exactement aux portes logiques du circuit. Mais si le circuit\nutilise des composants qui ne sont pas des portes logiques (comme par exemple\nun multiplexeur), ou si le circuit a plus de 100 niveaux de profondeur\n(imporbable), alors il affichera une bo\u00eete de dialogue pour vous avertir\nqu'il n'est pas possible de d\u00e9river des expressions bool\u00e9ennes et\nLogisim va \u00e0 la place d\u00e9river des expressions bas\u00e9es sur la table de v\u00e9rit\u00e9 qui sera\nelle-m\u00eame d\u00e9riv\u00e9e en testant (silencieusement) chaque combinaison\nen entr\u00e9e et en lisant le r\u00e9sultat en sortie (m\u00e9thode brute-force).\nApr\u00e8s l'analyse du circuit, il n'y pas de liaison entre le circuit et\nl'analyse combinatoire. Ce qui veut dire que des changements dans le circuit\nne vont pas \u00eatre refl\u00e9t\u00e9s dans la fen\u00eatre et des changements dans les\nexpressions bool\u00e9ennes et/ou la table de v\u00e9rit\u00e9 n'auront pas d'impact\nsur le circuit.\nVous pouvez bien s\u00fbr toujours r\u00e9-analyser le circuit; et comme nous le verrons\nplus tard, vous pouvez remplacer le circuit par un circuit correspondant\n\u00e0 ce qui appara\u00eet dans la fen\u00eatre d'analyse combinatoire.\nLimitations\nLogisim n'essayera pas de d\u00e9tecter des circuits s\u00e9quentiels: si vous\ndemandez l'analyse d'un circuit s\u00e9quentiel, il cr\u00e9era une table de\nv\u00e9rit\u00e9 et les expressions bool\u00e9ennes correspondantes, bien que cela\nne refl\u00e9tera pas correctement le comportement du circuit. (En fait la\nd\u00e9tection de circuits s\u00e9quentiels peut \u00eatre prouv\u00e9e comme impossible),\ncomme cela reviendrait \u00e0 r\u00e9soudre le probl\u00e8me de l'arr\u00eat.\nVous pouvez bien s\u00fbr esp\u00e9rer que Logisim fera quelques essais - mais ce\nn'est pas le cas.) En cons\u00e9quence, le syst\u00e8me d'analyse combinatoire ne\ndevrait pas \u00eatre utilis\u00e9 sans discernement: ne l'utilisez que si vous\n\u00eatre s\u00fbrs que le circuit \u00e0 analyser est vraiment combinatoire!\nLogisim effectuera peut-\u00eatre des changements inattendus au circuit original:\nle syst\u00e8me d'analyse combinatoire exige que chaque entr\u00e9e et sortie ait un\nnom unique qui soit conforme aux r\u00e8gles des identifiants Java. (En gros, chaque\ncaract\u00e8re doit \u00eatre soir une lettre, soir un chiffre and le premier caract\u00e8re\ndoit \u00eatre une lettre. Les espaces ne sont pas autoris\u00e9s!)\nIl essaye d'utiliser les labels existants des pins and d'utiliser une\nliste de valeurs par d\u00e9faut si les labels n'existent pas. Si un seul label\nne respecte pas les r\u00e8gles des identifiants Java, alors Logisim essayera\nsi possible d'inf\u00e9rer un label valide.\nIncidemment, l'ordre des entr\u00e9es dans la table de v\u00e9rit\u00e9\ncorrespondra \u00e0 l'ordre descendant dans le circuit original, avec des\nliens d\u00e9coup\u00e9s dans l'ordre gauche-droite. (Le m\u00eame ordre s'applique\npour les"
  },
  {
    "id": 25,
    "title": "Editer la table de v\u00e9rit\u00e9",
    "url": "/fr/html/guide/analyze/table.html",
    "text": "Editer la table de v\u00e9rit\u00e9\nEditer la table de v\u00e9rit\u00e9\nEn ouvrant la fen\u00eatre d'analyse combinatoire, vous verrez cinq onglets.\nCe document vous apporte de l'aide pour les trois premiers onglets:\nEntr\u00e9es, Sorties et Table.\nDans la suite du guide vous trouverez une description des deux onglets:\nExpression et Karnaugh.\nLes onglets entr\u00e9es et sorties\nL'onglet Entr\u00e9es vous permet d'afficher et \u00e9diter la liste des entr\u00e9es.\nPour ajouter des entr\u00e9es, il suffit de les entrer dans le champ pr\u00e9vu en\nbas et de cliquer Ajouter. Si vous voulez renommer une entr\u00e9e existante,\ns\u00e9lectionnez la dans la partie du haut \u00e0 gauche, tapez le nom\net cliquez Renommer.\nPour supprimer une entr\u00e9e, il suffit de la s\u00e9lectionner dans\nla liste et cliquer supprimer. Vous pouvez aussi r\u00e9organiser les\nentr\u00e9es (ce qui impact sur l'ordre des colonnes dans la table de\nv\u00e9rit\u00e9 et la g\u00e9n\u00e9ration du circuit) en utilisant les boutons\nmonter ou descendre sur une entr\u00e9e.\nToutes les actions impactent directement sur la table de v\u00e9rit\u00e9.\nL'onglet Sorties fonctionne exactement de la m\u00eame mani\u00e8re que l'onglet\ndes Entr\u00e9es, sauf qu'il s'agit de la liste des sorties.\nL'onglet Table\nLe seul \u00e9l\u00e9ment dans l'onglet Table et la table de v\u00e9rit\u00e9 courante,\nrepr\u00e9sent\u00e9e dans un ordre conventionnel, avec les entr\u00e9es en colonnes\n\u00e0 gauche et les orties en colonnes \u00e0 droite.\nVous pouvez \u00e9diter les valeurs qui apparaissent dans les colonnes\nde sortie en cliquant sur la valeur choisie. Les valeur changent\nde mani\u00e8re cyclique de 0 \u00e0 1 et x (repr\u00e9sentant une valeur\nsans importance). Comme nous le verrons \u00e0 la page suivante, une valeur\nsans importance permet l'\u00e9laboration des expressions minimales avec une\ncertaine flexibilit\u00e9.\nVous pouvez \u00e9galement naviguer et \u00e9diter la table de v\u00e9rit\u00e9 avec le clavier.\nEt vous pouvez copier-coller des valeurs en utilisant le presse-papier.\nLe presse-papier peut \u00eatre transf\u00e9r\u00e9 vers n'importe quelle application qui\nsupporte du texte avec des tabulation comme s\u00e9parateurs (comme un tableur).\nSi la table de v\u00e9rit\u00e9 est bas\u00e9e sur un circuit existant, vous pourriez voir des\ncarr\u00e9s rose dans les colonnes des sorties avec des \"!!\" \u00e0 l'int\u00e9rieur.\nCeci correspond \u00e0 des erreurs durant le calcul des valeurs pour cette ligne.\nSoit le circuit semblait osciller, ou la sortie \u00e9tait une erreur elle-m\u00eame (ce qui\ndevrait \u00eatre repr\u00e9sent\u00e9 par un c\u00e2ble rouge dans le circuit Logisim).\nEn passant la souris sur l'entr\u00e9e vous verrez appara\u00eetre une astuce avec une\ndescription du type d'erreur. Si vous cliquer sur une entr\u00e9e erron\u00e9e, vous\nvous retrouverez dans le cycle 0-1-x; Il n'y a pas moyen de\nrevenir en arri\u00e8re."
  },
  {
    "id": 26,
    "title": "Cr\u00e9er des expressions",
    "url": "/fr/html/guide/analyze/expr.html",
    "text": "Cr\u00e9ation d'expressions\nCr\u00e9er des expressions\nPour chaque variable de sortie, la fen\u00eatre d'analyse combinatoire\nmaintient deux structures: la colonne concern\u00e9e dans la table de v\u00e9rit\u00e9\net une expression bool\u00e9enne. Chaque structure d\u00e9finit comment la sortie\nd\u00e9pend de ses entr\u00e9es.\nVous pouvez \u00e9diter soit la table de v\u00e9rit\u00e9 soit l'expression; l'un ou l'autre\nsera automatiquement mis \u00e0 jours pour rester consistant.\nComme nous allons le voir sur la page suivante, les expressions bool\u00e9ennes sont\nparticuli\u00e8rement utiles dans la mesure ou la fen\u00eatre d'analyse combinatoire utilisera\nses derni\u00e8re quand il sera n\u00e9cessaire d'\u00e9laborer le circuit correspondant \u00e0 la\nconfiguration courrante.\nVous pouvez voir et \u00e9diter les expressions en utilisant les deux derniers onglet\nde la fen\u00eatre: l'onglet expressions et l'onglet Karnaugh.\nL'onglet expression\nL'onglet expression vous permet de visualiser et \u00e9diter l'expression courante\npour chaque variable de sortie. Vous pouvez s\u00e9lectionner l'expression de sortie\nen utilisant le s\u00e9lecteur appel\u00e9 \"Sortie:\" en haut du panneau.\nJuste en-dessous du s\u00e9lecteur, l'expression appara\u00eet dans un format d'usage commun,\nou un OR est repr\u00e9sent\u00e9 par une addition, un AND et repr\u00e9sent\u00e9 par une multiplication,\net un NOT est repr\u00e9sent\u00e9 par une barre au-dessus de la lettre.\nSur le m\u00eame panneau en-dessous nous avons la m\u00eame information en ASCII.\nDans ce contexte, le NOT est repr\u00e9sent\u00e9 par une vague ('~').\nVous pouvez \u00e9diter l'expression dans le panneau de texte et cliquer sur\nle bouton entrer pour la rendre effective. En faisant cela vous mettez \u00e0 jours \u00e9galement\nla table de v\u00e9rit\u00e9 de mani\u00e8re correspondante.\nLe bouton effacer vide le champ texte et le bouton revenir remet le texte qui correspond\n\u00e0 l'expression courrante.\nNotez que votre expressions sera modifi\u00e9e de mani\u00e8re irr\u00e9m\u00e9diable si vous \u00e9ditez la table de v\u00e9rit\u00e9.\nEn plus des additions et multiplications repr\u00e9sentant des AND et des OR,\nune expression entr\u00e9e peut contenir des op\u00e9rateurs logiques C/JAVA ainsi que des mots.\nPriorit\u00e9 la plus haute~ ! ' NOT\n(none) & && AND\n^ XOR\nPriorit\u00e9 la plus basse+ | || OR\nLes exemples suivants sont tous des repr\u00e9sentations valides de la m\u00eame expression.\nIl est d'ailleurs aussi possible de m\u00e9langer les op\u00e9rateurs\na' (b + c)\n!a && (b || c)\nNOT a AND (b OR c)\nEn g\u00e9n\u00e9ral, des parenth\u00e8ses, dans une s\u00e9quence de AND (ou de OR ou de XOR) n'ont aucun effet.\n(En particulier, quand Logisim g\u00e9n\u00e8re un circuit, il ignore ces parenth\u00e8ses.\nL'onglet Karnaugh\nLe dernier onglet affiche l'expression minimale d'une colonne de la table de v\u00e9rit\u00e9.\nVous pouvez s\u00e9lectionner quelle sortie minimis\u00e9e d'une colonne de la table vous\nsouhaitez afficher avec le s\u00e9lecteur en haut. Vous pouvez indiquer si vous souhaitez\nproduire une somme de produits ou un produit de sommes en utilisant le s\u00e9lecteur en-bas.\nSi il y'a quatre ou moins de quatre entr\u00e9e, la table de Karnaugh correspondante appara\u00eetra\nau centre du panneau. Vous pouvez cliquer la table de Karnaugh pour changer les valeurs\ncorrespondantes dans la table de v\u00e9rit\u00e9.\nLa table de Karnaugh affichera \u00e9galement les termes s\u00e9lectionn\u00e9s pour l'expression\nminimis\u00e9e avec un rectangle arrondi superpos\u00e9 semi-transparent.\nEn dessous, vous trouverez l'expression minimis\u00e9e elle-m\u00eame, format\u00e9 de la m\u00eame mani\u00e8re que\ndans l'onglet Expression.\nSi il y'a plus de quatre entr\u00e9es, la table de Karnaugh ne vas pas appara\u00eetre; mais\nl'expression minimis\u00e9e sera tout m\u00eame affich\u00e9e. (Logisim utilise l'algorithme de\nQuine-McCluskey pour \u00e9laborer l'expression minimis\u00e9e. Ceci est \u00e9quivalent \u00e0 une table de\nKarnaugh, mais appliqu\u00e9 \u00e0 un nombre quelconque de variable en entr\u00e9e.)\nLe bouton \"D\u00e9finir comme expression\" vous permet de d\u00e9finir l'expression\nminimis\u00e9e comme l'expression correspondant \u00e0 la variable. Ceci ne sera\nhabituellement pas n\u00e9cessaire comme les modifications \u00e0 la table de v\u00e9rit\u00e9\ninduisent l'expression minimis\u00e9e pour la colonne en question; mais si vous\nentrez une expression dans l'onglet Expression, alors c'est une possibilit\u00e9\nint\u00e9ressante de basculer dans l'expression minimis\u00e9e correspondante."
  },
  {
    "id": 27,
    "title": "G\u00e9n\u00e9rer un circuit",
    "url": "/fr/html/guide/analyze/gen.html",
    "text": "G\u00e9n\u00e9rer un circuit\nG\u00e9n\u00e9rer un circuit\nLe bouton \"Construire le circuit\" va g\u00e9n\u00e9rer un circuit dont les porte logiques\ncorrespondent \u00e0 l'expression choisie pour chaque sortie.\nLes entr\u00e9es et sorties du circuits seront affich\u00e9e dans l'ordre\nd\u00e9croissant correspondant \u00e0 l'apparition dans les onglets Entr\u00e9es et\nSorties.\nEn g\u00e9n\u00e9ral, le circuit g\u00e9n\u00e9r\u00e9 sera bien con\u00e7u et en fait l'un des int\u00e9r\u00eats\nde l'analyse combinatoire de Logisim est d'am\u00e9liorer des circuits\nmal con\u00e7us. Malgr\u00e9 tout, comme avec tout formatage automatique, le syst\u00e8me\nne va pas expliciter certains d\u00e9tails comme un circuit dessin\u00e9 \u00e0 la main.\nQuand vous cliquez sur le bouton \"Construire le circuit\", une bo\u00eete de\ndialogue appara\u00eet pour vous demander de choisir dans quel projet vous voulez\nplacer le circuit et quel nom lui donner.\nSi vous donnez le m\u00eame nom qu'un circuit existant, il sera remplac\u00e9\n(apr\u00e8s que Logisim vous a demand\u00e9 de confirmer que vous voulez\nvraiment le faire).\nLe dialogue \"Contruire un circuit\" inclut deux options.\nL'option de n'utiliser que des portes logiques \u00e0 deux entr\u00e9es sp\u00e9cifie que\ntoutes les portes logiques utilis\u00e9es n'auront que deux entr\u00e9es. (Sauf\n\u00e9videmment les portes logiques NOT.) L'option de n'utiliser que des portes\nNAND sp\u00e9cifie que le circuit traduit ne comportera que des portes NAND. Vous pouvez\ns\u00e9lectionner les deux options si vous ne voulez utiliser que des portes NAND \u00e0\ndeux entr\u00e9es.\nLogisim ne peut pas g\u00e9n\u00e9rer un circuit avec uniquement des portes NAND pour une\nexpression qui contiendrait des op\u00e9rateurs XOR. Par cons\u00e9quent cette derni\u00e8re\noption sera d\u00e9sactiv\u00e9e sur une quelconque expression en sortie contient un ou\nplusieurs XOR."
  },
  {
    "id": 28,
    "title": "Manuel des menus",
    "url": "/fr/html/guide/menu/index.html",
    "text": "Menu Reference\nMenu Reference\nThis section explains the six menus that accompany\nevery major Logisim window.\nThe File menu\nThe Edit menu\nThe Project menu\nThe Simulate menu\nThe Window and Help menus\nMany menu items relate specifically to a currently opened\nproject.\nBut some Logisim windows (particularly the Combinational Analysis window and the\nApplication Preferences window) are\nnot associated with projects. For these windows, the project-specific\nmenu items will be disabled."
  },
  {
    "id": 29,
    "title": "Menu fichier",
    "url": "/fr/html/guide/menu/file.html",
    "text": "The File menu\nThe File menu\nNew\nOpens a new project in a new window. The project will\ninitially be a copy of the\ncurrently selected template.\nOpen...\nOpens an existing file as a project in a new window.\nOpen Recent\nOpens a recently opened project in a new window\nwithout prompting the user to navigate through a file selection dialog.\nClose\nCloses all windows associated with the currently viewed\nproject.\nSave\nSaves the currently viewed project, overwriting what was\npreviously in the file.\nSave As...\nSaves the currently viewed project, prompting the user to\nsave into a different file than before.\nExport Image...\nCreates image file(s) corresponding to circuits.\nThe configuration dialog box is described below.\nPrint...\nSends circuit(s) to a printer. The configuration dialog box\nis described below.\nPreferences...\nDisplays the application\npreferences window. (On Mac OS systems, this will appear\nin the Logisim menu.)\nExit\nCloses all currently open projects and terminates Logisim.\n(On Mac OS systems, this will appear\nas Quit in the Logisim menu.)\nConfiguring Export\nWhen you select Export Image..., Logisim displays a dialog box\nwith four options.\nCircuits: A list where you can select one or more circuits\nthat should be exported into image files. (Empty circuits are not\ndisplayed as options.)\nImage Format: You can create PNG, GIF, and JPEG files. I would\nrecommend PNG files: The GIF format is quite dated, and the JPEG format will\nintroduce artifacts into the image, as the JPEG format is\nreally meant for photographic images.\nScale Factor: You can scale the images as they are dumped\ninto image files using this slider.\nPrinter View: Whether to use\n\"printer view\" in exporting\nthe circuits.\nAfter clicking OK, Logisim will display a file selection dialog\nbox. If you have selected one circuit, select the file into which\nthe image should be placed. If you have selected multiple circuits,\nselect a directory where the files should be placed; Logisim will\nname the images based on the circuits' names (main.png,\nfor example).\nConfiguring Print\nWhen you choose Print..., Logisim displays a dialog box for\nconfiguring what is printed.\nCircuits: A list where you can select one or more circuits\nto be printed. (Empty circuits are not\ndisplayed as options.) Logisim will print one circuit per page. If the circuit is too\nlarge for the page, the image will be scaled down to fit.\nHeader: Text that should appear centered at the top of\neach page. The following substitutions will be made into the text.\n%nName of circuit on page\n%pPage number\n%PTotal page count\n%%A single percent sign ('%')\nRotate To Fit: If checked, then Logisim will rotate\neach circuit by 90 degrees when the circuit is too large to\nfit onto the page and it does not need to be scaled as\nsmall when rotated 90 degrees.\nPrinter View: Whether to use\n\"printer view\" in printing\nthe circuits.\nAfter clicking OK, Logisim will display the standard page setup\ndialog box before printing the circuits."
  },
  {
    "id": 30,
    "title": "Menu \u00e9diter",
    "url": "/fr/html/guide/menu/edit.html",
    "text": "The Edit menu\nThe Edit menu\nUndo XX\nUndoes the most recently completed action affecting how the\ncircuit would be saved in a file. Note that this does not\ninclude changes to the circuit state (as with manipulations\nperformed by the Poke Tool).\nCut\nRemoves the currently selected components from the circuit onto\nLogisim's clipboard.\nNote: Logisim's clipboard is maintained separately\nfrom the clipboard for the overall system; as a result, cut/copy/paste\nwill not work across different applications, even including other\nrunning copies of Logisim. If, however, you have multiple\nprojects open under the same Logisim process, then you should be\nable to cut/copy/paste between them.\nCopy\nCopies the currently selected components in the circuit onto\nLogisim's clipboard. (See the note under the Cut menu\nitem.)\nPaste\nPastes the components on Logisim's clipboard into the current\nselection.\n(See the note under the Cut menu item.)\nWhen you paste components, they will not immediately be\ndropped; instead, they will be drawn in light gray. They will\nnot actually be ``dropped'' into the circuit until you either\nmove the selection or change the selection so that the\ncomponents are no longer in it.\nThe reason for this odd behavior is this: To be consistent with\nits other behavior, Logisim must immediately merge any wires as soon\nas they are dropped into a circuit; this merging process changes\nexisting wires in the circuit.\nWhen you paste wires from the\nclipboard, however, you may want them to appear in a different location,\nand the changing inherent in the merging process would be against\nyour wishes.\nDelete\nRemoves all components in the current selection from the\ncircuit, without modifying the clipboard.\nDuplicate\nCreates a copy of all components in the current selection. This is like\nselecting Copy, then Paste, except that Duplicate doesn't modify or use\nthe clipboard.\nSelect All\nSelects all components in the current circuit.\nRaise Selection\nThis menu item is available only when editing a circuit's appearance.\nIt raises the currently selected object(s) so that it is drawn (or they are drawn)\non top of an object that currently overlaps the selection. If the selection\nis overlapped by several objects, it is raised only to be above the lowest\none; select the menu item repeatedly until it is in the order it\nshould be.\n(Determining whether two arbitrary objects overlap is difficult. Logisim uses\nan algorithm of selecting several random points in each of the two objects\nand seeing if any point is also in the other object. Sometimes it will fail to\ndetect an overlap if the overlap is small \u2014 say, less than 5% of\neither of the objects.)\nLower Selection\nThis menu item is available only when editing a circuit's appearance.\nIt lowers the currently selected object(s) so that it is drawn (or they are drawn)\nbelow an object that the selection currently overlaps.\nIf the selection overlaps several objects, it is lowered only\nto be below the highest one; select the menu item repeatedly until it is in the\norder it should be.\nRaise To Top\nAvailable only when editing a circuit's appearance, this menu item\nraises the currently selected object(s) to be drawn on top of all other objects.\n(The anchor and the ports are exceptions \u2014 they are always on top.)\nLower To Bottom\nAvailable only when editing a circuit's appearance, this menu item\nlowers the currently selected object(s) so that all other objects are drawn\non top of them.\nAdd Vertex\nAvailable only when editing a circuit's appearance and a point has been\nselected on a line, polyline, or polygon, this menu item inserts a new vertex\nonto the shape. Previous to insertion, the selected point is drawn as a\ndiamond.\nRemove Vertex\nAvailable only when editing a circuit's appearance and an existing\nvertex has been selected on a polyline or polygon, this menu item removes\nthe selected vertex. Previous to deletion, the selected vertex is drawn as a\ndiamond within the square representing the vertex. Logisim will not permit\nremoving a vertex on a polygon with only three vertices or on a polyline with\nonly two vertices."
  },
  {
    "id": 31,
    "title": "Menu projet",
    "url": "/fr/html/guide/menu/project.html",
    "text": "The Project menu\nThe Project menu\nAdd Circuit...\nAdds a new circuit into the current project. Logisim will\ninsist that you name the new circuit. The name must not match\nany existing circuits in the project.\nLoad Library\nLoads a library into the\nproject. You can load three types of libraries, as explained elsewhere in the User's\nGuide.\nUnload Libraries...\nUnloads current libraries from the project. Logisim will\nnot permit you to unload any libraries currently being used,\nincluding libraries containing components appearing in any\nproject circuits, as well as those with tools that appear in\nthe toolbar or that are mapped to the mouse.\nMove Circuit Up\nMoves the currently displayed circuit one step up the list of\ncircuits within the project, as displayed in the explorer pane.\nMove Circuit Down\nMoves the currently displayed circuit one step down the list of\ncircuits within the project, as displayed in the explorer pane.\nSet As Main Circuit\nSets the currently displayed circuit to be the project's\nmain circuit. (This menu item will be grayed out if the\ncurrent circuit is already the project's main circuit.)\nThe only significance of the main circuit is that it is the\ncircuit that first appears when a project file is opened.\nRevert To Default Appearance\nIf you've edited the circuit's appearance, this menu item reverts\nthe appearance back to the default rectangle-with-notch appearance.\nThe menu item is enabled only when editing the circuit's appearance.\nView Toolbox\nChanges the explorer pane to displaying a list of the project's\ncircuits and the libraries that have been loaded.\nView Simulation Tree\nChanges the explorer pane to displaying the hierarchy of\nsubcircuits in the current simulation.\nEdit Circuit Layout\nSwitches to allow you to edit the layout of components, which\ndetermines how the circuit works. This menu item is usually disabled since\nyou will usually be editing the layout anyway.\nEdit Circuit Appearance\nSwitches to allow you to edit how the circuit will be represented\nwhen it is used as a subcircuit within another circuit. By default, the circuit\nis represented as a rectangle with a gray notch on its north end, but\nthis menu option allows you to draw a different appearance for the\nsubcircuit.\nRemove Circuit\nRemoves the currently displayed circuit from the project.\nLogisim will prevent you from removing circuits that are used as\nsubcircuits, and it will prevent you from removing the final\ncircuit in a project.\nAnalyze Circuit\nComputes a truth table and Boolean expressions corresponding\nto the current circuit, displaying them in\nthe Combinational Analysis window.\nThe analysis process will only be valid for combinational circuits.\nA full description of the analysis process is described\nin the\nCombinational Analysis section.\nGet Circuit Statistics\nShows a dialog containing statistics about components used by the\ncurrently viewed circuit. The dialog includes a table with five columns:\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nSimple: The number of times that component appears directly within the viewed circuit.\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nThe distinction between Unique and Recursive is easiest to\nexplain by considering the 4:1 multiplexer built using three 2:1 multiplexers\nas in the Using subcircuits section.\nThe 2:1 multiplexer contains two AND gates (and the 4:1 circuit includes none),\nso the Unique count\nof AND gates would be 2; but if you were to build the 4:1 multiplexer using this\ndiagram, you would actually need 2 AND gates for each of the three 2:1 multiplexers,\nso the Recursive count is 6.\nIf you are using circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\nOptions...\nOpens the Project Options\nwindow."
  },
  {
    "id": 32,
    "title": "Menu simulation",
    "url": "/fr/html/guide/menu/simulate.html",
    "text": "The Simulate menu\nThe Simulate menu\nSimulation Enabled\nIf checked, circuits viewed will be \"live:\" That is, the\nvalues propagating through the circuit will be updated with each\npoke or change to the circuit.\nThe menu option will be automatically unchecked if\ncircuit oscillation is\ndetected.\nReset Simulation\nClears everything about the current circuit's state, so that it\nis as if you have just opened the file again. If you are viewing a\nsubcircuit's state, the entire hierarchy is cleared.\nStep Simulation\nAdvances the simulation one step forward. For example, a signal may end up\nentering a gate during one step, but the gate won't show a different signal\nuntil the next simulation step. To help identify which points in the overall\ncircuit have changed, any points whose values change are indicated with a blue\ncircle; if a subcircuit contains any points that have changed in it (or its\nsubcircuits, recursively), then it will be drawn with a blue\noutline.\nGo Out To State\nWhen you delve into a\nsubcircuit's state via its pop-up menu, the Go Out To State\nsubmenu lists the\ncircuits above the currently viewed circuit's state. Selecting\none displays the corresponding circuit.\nGo In To State\nIf you have delved into a subcircuit's state and then moved\nback out, this submenu lists the subcircuits below the current\ncircuit. Selecting one of the circuits displays the\ncorresponding circuit.\nTick Once\nSteps one tick forward into the simulation. This can be useful\nwhen you want to step the clocks manually, particularly when the clock\nis not in the same circuit that you are currently viewing.\nTicks Enabled\nStarts automatically ticking the clock. This will have an\neffect only if the circuit contains any clock devices (in the Wiring\nlibrary). The option is disabled by default.\nTick Frequency\nAllows you to select how often ticks occur.\nFor example, 8 Hz\nmeans that ticks will occur eight times a second.\nA tick is the\nbase unit of measurement for the speed of clocks.\nNote that the clock cycle speed will be slower than the tick\nspeed: The fastest possible clock will have a one-tick up cycle\nand a one-tick down cycle; such a clock would have up/down cycle\nrate of 4 Hz if the ticks occur at 8 Hz.\nLogging...\nEnters the logging module, which\nfacilitates automatically noting and saving values in a circuit as a\nsimulation progresses.\nand Help menus."
  },
  {
    "id": 33,
    "title": "Menus fen\u00eatre et aide",
    "url": "/fr/html/guide/menu/winhelp.html",
    "text": "The Window and Help menus\nThe Window menu\nMinimize\nMinimizes (iconifies) the current window.\nMaximize (Zoom on MacOS)\nResizes the current window to its preferred size.\nClose\nCloses the current window.\nCombinational Analysis\nShows the current\nCombinational Analysis\nwindow, without changing any of its contents.\nPreferences\nShows the\nApplication Preferences\nwindow.\nindividual window titles\nBrings the respective window to the front.\nThe Help menu\nTutorial\nOpens the help system to the\n\"Beginner's Tutorial\" section of the\nGuide to Being a Logisim User.\nUser's Guide\nOpens the help system to the\nGuide to Being a Logisim User.\nLibrary Reference\nOpens the help system to the\nLibrary Reference.\nAbout...\nDisplays a window containing the version number, mixed among the splash\nscreen graphics. (On MacOS, this menu item is under the Logisim menu.)"
  },
  {
    "id": 34,
    "title": "Composant m\u00e9moire",
    "url": "/fr/html/guide/mem/index.html",
    "text": "Memory components\nMemory components\nThe RAM and ROM components are two of the more useful\ncomponents in Logisim's built-in libraries. However, because\nof the volume of information they can store, they are also two\nof the most complex components.\nDocumentation about how they work within a circuit can\nbe found on the RAM and\nROM pages of the\nLibrary Reference. This section of the User's\nGuide explains the interface allowing the user to view\nand edit memory contents.\nPoking memory\nPop-up menus and files\nLogisim's integrated hex editor"
  },
  {
    "id": 35,
    "title": "Pousser la m\u00e9moire",
    "url": "/fr/html/guide/mem/poke.html",
    "text": "Poking memory\nPoking memory\nYou can manipulate the contents of memory using the Poke Tool,\nbut the interface for this is severely limited by space constraints:\nFor more than the simplest editing, you will probably\nfind the integrated hex editor far more\nconvenient.\nNonetheless, to view and edit values within the circuit, the\nPoke Tool has two modes of operation:\nYou can edit the address displayed, and you can edit an individual\nvalue.\nTo edit the address displayed, click outside the display rectangle.\nLogisim will draw a red rectangle around the top address.\nTyping hexadecimal digits will change the top address\naccordingly.\nTyping the Enter key will scroll down one line.\nTyping the Backspace key will scroll up one line.\nTyping the space bar will scroll down one page (four lines).\nTo edit a particular value, click the value within the display\nrectangle. Logisim will draw a red rectangle around that address.\nTyping hexadecimal digits will change the value at the address\ncurrently being edited.\nTyping the Enter key will move to editing the value just below it in\nthe display (down one line).\nTyping the Backspace key will move to editing the value at the\nprevious address.\nTyping the space bar will move to editing the value at the following\naddress."
  },
  {
    "id": 36,
    "title": "Menus Pop-up et fichiers",
    "url": "/fr/html/guide/mem/menu.html",
    "text": "Pop-up menus and files\nPop-up menus and files\nThe pop-up menu for memory includes four options in addition\nto the options common to all components:\nEdit Contents: Bring up a hex editor for editing the contents\nof memory.\nClear Contents: Resets all values in memory to 0.\nLoad Image...: Resets all values in memory based on the values\nfound in a file using the format described below.\nSave Image...: Stores all values in memory into a file using\nthe format described below.\nThe file format used for image files is intentionally simple;\nthis permits you to write a program, such as an assembler, that\ngenerates memory images that can then be loaded into memory.\nAs an example of this file format, if we had a 256-byte memory whose\nfirst five bytes were 2, 3, 0, 20, and -1, and all subsequent values\nwere 0, then the image would be the following text file.\nv2.0 raw\n02\n03\n00\n14\nff\nThe first line identifies the file format used (currently, there is only\none file format recognized). Subsequent values list the values in\nhexadecimal, starting from address 0; you can place several such\nvalues on the same line. If there are more memory locations than are identified\nin the file, Logisim will load 0 into the other memory locations.\nThe image file can use run-length encoding; for example, rather than\nlist the value 00 sixteen times in a row, the file can include\n16*00. Notice\nthan the number of repetitions is written in base 10.\nFiles produced by Logisim will use run-length encoding for runs of\nat least four values.\nYou can place comments into the file by using the '#' symbol: All characters\nin the line starting from the '#' symbol will be ignored by Logisim."
  },
  {
    "id": 37,
    "title": "Editeur Hex",
    "url": "/fr/html/guide/mem/hex.html",
    "text": "Hex editor\nHex editor\nLogisim includes an integrated hex editor for viewing and editing\nthe contents of memory. To access it, bring up a pop-up menu for\nthe memory component and select Edit Contents....\nFor ROM components, which have the memory contents as part of the\nattribute value, you can alternatively access the hex editor by\nclicking the corresponding attribute value.\nThe numbers in italics at left display memory addresses,\nwritten in hexadecimal. The other numbers display values\nstarting from that memory address; the hex editor may display\nfour, eight, or sixteen values per line, depending on what fits\nin the window. To help with counting, each group of four values\nhas a larger space between.\nYou can navigate through memory using the scroll bar or\nusing the keyboard (the arrow keys, home, end, page up, and\npage down). Typing hexadecimal characters will alter the\ncurrently selected value.\nYou can select a range of values by dragging the mouse,\nshift-clicking the mouse, or navigating through memory with\nthe keyboard while depressing the shift key. Values may be\ncopied and pasted using the Edit menu; the clipboard can also be\ntransferred into other applications."
  },
  {
    "id": 38,
    "title": "Journalisation",
    "url": "/fr/html/guide/log/index.html",
    "text": "Logging\nLogging\nIn testing a large circuit, and for documenting a circuit's\nbehavior, a log of past circuit behavior can be useful. This is the purpose for\nLogisim's logging module, which allows you to select components whose\nvalues should be logged; optionally, you can specify a file into which\nthe log should be placed.\nYou can enter the logging module via the Logging...\noption from the Simulate menu. It brings up a window with three tabs.\nWe will discuss each of these tabs separately.\nThe Selection tab\nThe Table tab\nThe File tab\nEach project has only one logging window; when you switch to viewing\nanother circuit within the project, the logging window switches\nautomatically to logging the other circuit instead. That is, it does\nthis unless you are moving up or down\nwithin the same simulation, in which case the logging module does\nnot change.\nNote that when the logging module switches to logging another\nsimulation, it will cease any logging into a file. Should you switch\nback to the simulation again, it will remember the configuration for\nthat simulation, but you will need to re-enable the file logging\nmanually."
  },
  {
    "id": 39,
    "title": "Onglet de s\u00e9lection",
    "url": "/fr/html/guide/log/selection.html",
    "text": "The Selection tab\nThe Selection tab\nThe Selection tab allows you to select which values\nshould be included in the log. The window below corresponds to the\nfollowing circuit.\nThe tab is divided into three vertical areas. The first (leftmost) is\na list of all components in the circuit whose values can be logged.\nAmong the built-in libraries, the following types of components support\nlogging.\nWiring library: Pin, Probe, and Clock components\nI/O library: Button and LED components\nMemory library: All components except ROM\nFor components which have labels associated with them, their names correspond\nto the labels; other components' names specify their type and their\nlocation within the circuit.\nAny subcircuits will also appear in the list; they cannot be selected\nfor logging, but eligible components within them can be.\nNote that the RAM component requires you to choose which memory\naddress(es) should be logged; it allows logging only for the first 256\naddresses.\nThe last (rightmost) vertical area lists those components that have\nbeen selected. Also, it indicates the radix (base) in which the\ncomponent's multi-bit values\nwill be logged; the radix does not have a significant effect on one-bit\nvalues.\nThe middle column of buttons allows the manipulation of the items\nwithin the selection.\nAdd adds the currently selected item(s) on the left\nside into the selection.\nChange Radix cycles the radix for the currently\nselected component in the selection between 2 (binary), 10 (decimal),\nand 16 (hexadecimal).\nMove Up moves the currently selected component in\nthe selection forward one spot.\nMove Down moves the currently selected component in\nthe selection back one spot.\nRemove removes the currently selected component in\nthe selection."
  },
  {
    "id": 40,
    "title": "Onglet table",
    "url": "/fr/html/guide/log/table.html",
    "text": "The Table tab\nThe Table tab\nThe Table tab displays the current log graphically.\nThe table contains a column for each component in the selection. Each\nrow in the table displays a snapshot of the simulation after a\npropagation of values has completed. Any duplicate rows are not added\ninto the log. Note that only the most recent 400 rows are displayed.\nSome rows may have empty entries if the corresponding component was not\nin the selection at the time that the row was computed.\nThe displayed table is for review only; it is not interactive."
  },
  {
    "id": 41,
    "title": "Onglet fichier",
    "url": "/fr/html/guide/log/file.html",
    "text": "The File tab\nThe File tab\nThe File tab allows you to specify a file into which the log should\nbe placed.\nAt the top is an indicator of whether file logging is in progress and\na button for enabling or disabling it. (Note that you cannot enable it\nuntil a file is selected below.) The button allows you to pause and\nrestart file entry. When you switch in the project window to viewing\nanother simulation, the file logging is automatically halted; if you\nreturn to the original one and want logging to continue, you will need\nto re-enable the file logging manually using the button at top.\nIn the middle is an indicator of what file is being logged to. To\nchange it, use the Select... button. On selecting a file, file logging\nwill automatically start. If you select a pre-existing file, Logisim\nwill ask whether you want to overwrite the file or append the new\nentries onto the end.\nAt bottom you can control whether a header line should be placed into\nthe file indicating which items are in the selection. If header lines\nare added, then a new header line will be placed into the file whenever\nthe selection changes.\nFile format\nEntries are placed into the file in tab-delimited format\ncorresponding closely to what appears under the Table tab. (One\ndifference is that any header lines will give the full path to\ncomponents lying in subcircuits.) The format is intentionally simple so\nthat you can feed it into another program for processing, such as a\nPython/Perl script or a spreadsheet program.\nSo that a script can process the file at the same time as Logisim\nis running, Logisim will flush the new records onto the disk every\n500 ms. Note that Logisim may also intermittently close and later\nre-open the file during the simulation, particularly if several seconds\nhave elapsed without any new records being added."
  },
  {
    "id": 42,
    "title": "V\u00e9rifications en ligne de commande/a>",
    "url": "/fr/html/guide/verify/index.html",
    "text": "Command-line verification\nCommand-line verification\nSubsections:\nSubstituting libraries\nOther verification options\nTesting multiple files\nLogisim includes basic support for executing circuits from the command-line.\nThis is intended both to help with scripted verification of circuit designs\nand to help instructors perform automated testing of students' solutions.\nWe'll start by seeing how to execute a circuit from the command line.\nFor our example, we'll suppose we've built the below circuit in a file named adder-test.circ.\nIt uses a two-bit adder as a subcircuit\nand iterates using a counter through all 16 possible inputs to it.\nAfter this circuit has been built, we then execute Logisim from the command line,\nproviding the filename of the project\nand the -tty option with the table parameter.\njava -jar logisim-filename.jar adder-test.circ -tty table\nWithout bringing up any windows, Logisim loads the circuit and begins to execute it,\nticking any clocks as fast as it can while completing the propagation between each tick.\nAfter each propagation is completed, Logisim loads the current values of the output pins;\nif any have changed from the previous propagation,\nthen all values are displayed in tab-delimited format.\nIf there is an output pin labeled with the special word halt,\nits output is not displayed \u2014 but once the pin's value reaches 1 after\na propagation is completed, Logisim ends the simulation.\nFor our example, Logisim displays the table below. Because we have two output\npins corresponding to the two inputs a and b into the\ntwo-bit adder, these outputs are included as the first two columns of the output.\nAnd there is another output pin corresponding to the two-bit adder's output,\nso it is the third column.\nThe columns are ordered left-to-right according to the top-down ordering within\nthe circuit.\n00\n00\n000\n01\n00\n001\n10\n00\n010\n11\n00\n011\n00\n01\n001\n01\n01\n010\n10\n01\n011\n11\n01\n100\n00\n10\n010\n01\n10\n011\n10\n10\n100\n11\n10\n101\n00\n11\n011\n01\n11\n100\n10\n11\n101\n11\n11\n110"
  },
  {
    "id": 43,
    "title": "Echanges de librairies",
    "url": "/fr/html/guide/verify/sub.html",
    "text": "Substituting libraries\nSubstituting libraries\nNow suppose we have two Logisim circuits that are supposed to do the same thing.\nAs an instructor, you might have had students complete an assignment:\nYou have one file containing your solution, but you have several student files\ncontaining their work. Maybe the assignment was to build a two-bit adder.\nI'll imagine that we have two files, named adder-master.circ\nand adder-query.circ. Each file contains a circuit named\n2-bit adder (it's important that the circuit to test be named exactly the same),\nwhose appearance is the following.\nadder-master.circ\nadder-query.circ\nAs you can see, the master circuit uses Logisim's built-in adder,\nwhile the query circuit uses two subcircuits representing a half adder and\na full adder (which themselves are built up of simple gates).\nFor the purpose of our example, the query circuit has a stupid error:\nThe carry from the half adder is not connected into the full adder.\nWe build our testing circuit into a different file. There, we load\nadder-master.circ as a Logisim Library\n(Project > Load Library > Logisim Library\u2026), and we insert its\n2-bit adder as a subcircuit. We could execute this circuit directly to get\nthe desired output for a perfect solution.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\nBut we want to execute the circuit using adder-query.circ\nrather than adder-master.circ as the loaded library.\nThe naive approach would be to open Logisim and load that library instead;\nor you might simply remove the adder-master.circ file and rename\nadder-query.circ to be named adder-master.circ instead.\nBut Logisim includes a handy -sub option that temporarily replace\none file by another during that session \u2014 without making any changes on disk.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\nThe output you would see from this is shown below; it is of course different\nfrom what we saw in the previous section since now it is\nexecuting using the erroneous adder-query.circ.\n00\n00\n0E0\n01\n00\n0E1\n10\n00\nEE0\n11\n00\nEE1\n00\n01\n0E1\n01\n01\n0E0\n10\n01\nEE1\n11\n01\nEE0\n00\n10\nEE0\n01\n10\nEE1\n10\n10\n1E0\n11\n10\n1E1\n00\n11\nEE1\n01\n11\nEE0\n10\n11\n1E1\n11\n11\n1E0"
  },
  {
    "id": 44,
    "title": "Autres options de v\u00e9rification",
    "url": "/fr/html/guide/verify/other.html",
    "text": "Other verification options\nOther verification options\nThere are a some additional options related to command-line execution.\nThe -load command-line parameter\nA more complex circuit might include a RAM component that needs to\nbe loaded with a program in order for the circuit to have anything to do.\nYou can specify a memory image file at the command line, which will be loaded\ninto any RAM component in the circuit before simulation begins.\n(This does not work when loading the GUI - it is only for command-line execution.)\njava -jar logisim-filename.jar cpu.circ -tty table -load mem-image.txt\nThe order of the parameters is not important (except the table\nparameter must be immediately after -tty, and the memory image's filename\nmust be immediately after -load).\nThe memory image file should be in\nLogisim's memory image format.\nLogisim searches for RAM recursively, so this will still work if RAM is\nnested within a subcircuit.\nThere is no way, though, to distinguish different RAM components:\nLogisim will attempt to load the same file into every RAM that it can find.\nOptions for the -tty parameter\nIn our examples thus far, we've always used -tty\u00a0table\nto indicate that a table of output values should be displayed. You can\ncustomize the behavior in other ways by listing one or more options,\nseparated by commas. For instance, you might write\n-tty\u00a0table,halt,speed,\nand the program will perform all three behaviors listed below.\n(The order in which they are listed does not matter.)\nhalt\nAfter the simulation ends, a one-line message is displayed explaining\nwhy the simulation ended. Error conditions - such as a detected oscillation -\nare displayed in any case.\nspeed\nIf you use speed in conjunction with -tty,\nthen after completing the simulation Logisim will display a summary of\nhow quickly the circuit was simulated, such as:\n714 Hz (509 ticks in 712 milliseconds)\nNote that displaying information during the simulation\nmakes the simulation go much slower. As just one comparison, the same circuit and image\nran at 714\u00a0Hz above with just the speed option\nbut 490\u00a0Hz with the table option as well.\nstats\nShows a tab-delimited table containing statistics about components\nused by the top-level main circuit in the project. The table includes\nfour columns:\nUnique: The number of times that component appears in the circuit's hierarchy,\nwhere each subcircuit within the hierarchy is counted only once.\nRecursive: The number of times that component appears in the circuit's hierarchy,\nwhere we count each subcircuit as many times as it appears in the hierarchy.\nComponent: The name of the component.\nLibrary: The name of the library from which the component came.\nThe distinction between Unique and Recursive is explained\nfurther under Project menu section.\nIf the file uses circuits from a loaded Logisim library, those components are\nconsidered to be black boxes: The contents of the library's circuits are\nnot included in the unique and recursive counts.\n(This feature can be useful for instructors who assign students to build\nprojects using a subset of Logisim's libraries.)\ntable\n(as already discussed)\ntty\nAny TTY components send their output to the display (standard output),\nand any information typed at the keyboard is sent to all Keyboard components\nin the circuit.\nThese components are included even if they are nested deeply\nin the subcircuit hierarchy."
  },
  {
    "id": 45,
    "title": "Tester plusieurs fichiers",
    "url": "/fr/html/guide/verify/multi.html",
    "text": "Testing multiple files\nTesting multiple files\nIn the classroom example, you will have many files that you wish to test\nfor their equivalence, and you won't want to read the output for each\nof the student's solutions.\nBuilding comparison into the circuit\nOne approach is to build a test circuit that does the comparison directly.\nHere, we create an additional circuit within the testing file that contains\nour solution circuit. In our overall testing circuit, we include both the\nsubcircuit from adder-master.circ and the subcircuit from the solution\ncircuit located directly into the nested circuit. We wire it so that there is\njust one output, which is 1 as long as the two subcircuits agree.\nNow we can simply run Logisim substituting each query file. For any correct\nsolution, the only output will be 1.\nUsing redirection and shell scripts\nIf you're quite comfortable with the command line,\nyou can build your own shell script to accomplish this.\nHere, we'll use redirection (the > operator) to save the output of each\ncircuit into a file.\nFor instance, we might issue the following two commands to collect the output\nof the master circuit and the query circuit.\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0>\u00a0output-master.txt\njava\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\u00a0-sub\u00a0adder-master.circ\u00a0adder-query.circ\u00a0>\u00a0output-query.txt\nNow we've created two different files.\nWe can then compare the two output files using a program built for that purpose.\nUnder Linux or MacOS X, you might want to use the cmp or diff\ncommand-line utilities. Under Windows, you might want to use WinMerge.\nTo process several query files, you would like want to build a simple program\nsuch as a shell script to iterate through each and comparing the output.\nHere is how I would do it under Linux's bash:\nRUN_TEST=\"java\u00a0-jar\u00a0logisim-filename.jar\u00a0adder-test.circ\u00a0-tty\u00a0table\"\n${RUN_TEST}\u00a0>\u00a0output-master.txt\nfor\u00a0QUERY_FILE\u00a0in\u00a0adder-query*.circ\ndo\nif\u00a0${RUN_TEST}\u00a0-sub\u00a0adder-master.circ\u00a0${QUERY_FILE}\u00a0|\u00a0cmp\u00a0-s\u00a0output-master.txt\nthen\necho\u00a0\"${QUERY_FILE}\u00a0OK\"\nelse\necho\u00a0\"${QUERY_FILE}\u00a0different\"\nfi\ndone"
  },
  {
    "id": 46,
    "title": "Pr\u00e9f\u00e9rences de l'application",
    "url": "/fr/html/guide/prefs/index.html",
    "text": "Application Preferences\nApplication Preferences\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses application preferences;\nproject options are described in another\nsection.\nYou can view and edit application preferences via the Preferences...\noption from the File menu (or, under Mac OS, the Logisim menu),\na window will appear with several tabs.\nWe will discuss these tabs\nseparately, and then we will see how preferences can be configured\nfrom the command line.\nThe Template tab\nThe International tab\nThe Window tab\nThe Layout tab\nThe Experimental tab\nThe command line"
  },
  {
    "id": 47,
    "title": "L'onglet mod\u00e8le",
    "url": "/fr/html/guide/prefs/template.html",
    "text": "The Template tab\nThe Template tab\nA template is a Logisim file that is used as a starting\npoint whenever Logisim creates a new project. Also, if you have an\nexisting Logisim file with a strangely configured environment, you\ncan \"reset\" the environment using the Revert All To Template\nbutton in the window for editing Project Options.\nAlthough templates are useful in other situations also, they are\nparticularly suited for classroom use, where an instructor might\nwant to distribute a template for students to start from. This is\nparticularly likely if the class uses Logisim heavily, including\nmany of the more advanced features, in which case the simple default\nconfiguration may prove too simple. Templates can also be useful in\nthe classroom setting when the instructor opens a file submitted by\na student who has configured the environment significantly.\nBy default, the \"Plain template\" option will be selected,\nusing the default template shipped with Logisim. If you want a\nbare-bones configuration, you might choose \"Empty template.\"\nBut if you want to designate another file to use as the template,\nselect a template via the Select...\nbutton, and then choose the\n\"Custom template\" option."
  },
  {
    "id": 48,
    "title": "L'onglet international",
    "url": "/fr/html/guide/prefs/intl.html",
    "text": "The International tab\nThe International tab\nThis tab allows configuration of Logisim according to\nregional preferences.\nGate shape: Logisim supports three standards for drawing gates:\nshaped gates, rectangular gates, and DIN 40700\ngates. The following table illustrates the\ndistinction.\nShaped\nRectangular\nDIN 40700\nAND\nOR\nBecause the shaped style tends to be more popular in the U.S., while the\nrectangular style tends to be more popular in Europe, some people refer to\nthese styles according to these regions; but the region-neutral terms\nshaped and rectangular are preferred.\nThe DIN 40700 standard was a standard for drafting digital and analog\nelectronic components adopted by DIN, a German standards organization. DIN\nadopted the rectangular standard for digital components in 1976, but some\nengineers continue to use the older style; they appear to be increasingly\nrare.\nLogisim does not follow any standard exactly; it steers a middle\nground to allow switching between them. In particular, the shaped gates\nare more square than the dimensions defined by the relevant IEEE\nstandard. And, although XOR and XNOR gates really ought to be the same\nwidth as OR and NOR gates with the rectangular style, they are not\nbecause of difficulties compressing the shaped-XOR gate.\nLanguage:\nChange between languages. The current version is supplied with\nEnglish, Spanish, Russian, and German translations.\nThe German translation was introduced with Logisim 2.6.1 and remains current.\nIt is by Uwe Zimmermann, a faculty member at Uppsala University in Sweden.\nThe Greek translation was introduced with Logisim 2.7.0 and remains current.\nIt is by Thanos Kakarountas, a faculty member at Technological Educational Institute of Ionian Islands in Greece.\nThe Portuguese translation was introduced with Logisim 2.6.2 and remains current.\nIt is by Theldo Cruz Franqueira, a faculty member at Pontif\u00edcia Universidade Cat\u00f3lica de Minas Gerais in Brazil.\nThe Russian translation was introduced with Logisim 2.4.0 and remains current.\nIt is by Ilia Lilov, from Russia.\nThe Spanish translation was complete as of Logisim 2.1.0,\nbut subsequent Logisim versions have added new options that remain untranslated.\nIt was contributed by Pablo Leal Ramos, from Spain.\nTranslations of Logisim into other languages are welcome! If you\nare interested, contact me, Carl Burch. This will not be a commitment:\nI will be happy to hear of your interest, and I will tell\nyou whether I know of somebody who is working on it already,\nprepare a version for you to work with, and send you instructions.\nThe translation process does not require an understanding of Java.\nReplace accented characters:\nSome platforms have poor support for characters (such as\n\u00f1 or \u00f6) that do not appear in the 7-bit ASCII character\nset. When this is checked, Logisim will replace all instances of the\ncharacters with the appropriate equivalent 7-bit ASCII characters.\nThe checkbox is disabled when the current language does not have\nany equivalents available (as with English)."
  },
  {
    "id": 49,
    "title": "L'onglet fen\u00eatre",
    "url": "/fr/html/guide/prefs/window.html",
    "text": "The Window tab\nThe Window tab\nThis tab includes preferences affecting the appearance of the main window used\nfor Logisim.\nShow tick rate: If checked, then when ticks are enabled, Logisim\ndisplays a measurement of the rate at which it has been able to complete ticks.\nThe tick rate is measured by averaging over the previous 1,000 ticks.\n(Disabling ticks or changing the maximum tick rate will clear its history.)\nThis actual tick rate may be much less than the selected tick rate, because\nLogisim cannot simulate larger circuits at a very fast rate. For example,\nLogisim's maximum speed for a\nreasonably large circuit might be 16 Hz; you can select a faster tick rate,\nbut the actual speed will not exceed 16 Hz.\nToolbar location: This drop-down menu configures the location of\nthe toolbar within the overall window. The toolbar may be placed\non any of the window's four borders, described as north, south,\neast, and west. It may also be hidden, or it can be placed \"down the\nmiddle\" - that is, to the left of the canvas but to the right of\nthe explorer pane and attribute table."
  },
  {
    "id": 50,
    "title": "L'onglet de pr\u00e9sentation",
    "url": "/fr/html/guide/prefs/layout.html",
    "text": "The Layout tab\nThe Layout tab\nThis tab includes preferences affecting\nthe behavior of the circuit layout editor.\nPrinter view: Specifies whether\nto display the circuit on the screen in the same way it is displayed\nthrough the printer. Normally this is off, and Logisim displays the on-screen\ncircuit with indications of the current circuit state, and it displays some\nhints about component interface (most notably, it draws legs on OR\ngates to indicate where they would connect). The printer view, though,\nomits indications of state, and it omits such interface hints.\nShow attribute halo: Specifies whether to draw the pale teal oval\naround the component or tool whose attributes are currently displayed in\nthe attribute table.\nShow component tips: Specifies\nwhether to display the \"tool tips\" that will temporarily appear when\nthe mouse hovers over components supporting them. For example, if you hover\nover a subcircuit component's pin, it will display the label of the\ncorresponding pin within the subcircuit. Hovering over one of the\nends of a splitter will tell you the bits to which that end corresponds.\nIn addition, all components in the Plexers, Arithmetic, and Memory libraries will\nprovide information about their inputs and outputs via tips.\nKeep connections while moving: Indicates whether\nLogisim should add new wires when components are moved\nto preserve their connections. By default this is on \u2014 though it can\nbe turned off temporarily by pressing the shift key while moving the components.\nIf this box is unchecked, then the default will be not to add wires during a move\n\u2014 though you can turn it on temporarily by pressing the shift key during the move.\nShow Ghosts while adding: When checked, and when a tool for adding\na new component is selected, a light-gray outline of a component to be added\nis drawn as the mouse moves across the canvas. For example, if you select\nthe AND gate tool and move the mouse into the window (without\npressing the mouse's button), a gray outline of an AND gate will display\nwhere the AND gate will appear when the mouse is clicked.\nAfter adding component: By default, after adding each individual\ncomponent, Logisim switches back to the Edit Tool to allow you to move\ncomponents around and to add wires. The drop-down box allows you to change this\nbehavior so that Logisim stays at the same tool for adding more of the same\ncomponent, until you yourself opt to choose the Edit Tool. (This was Logisim's\ndefault behavior prior to Logisim 2.3.0. While more intuitive, this behavior\nrequires more mouse movement to switch between tools.)\nFirst radix when wire poked:\nConfigures how values are displayed when a wire is clicked using the Poke Tool.\nClicking a wire displays temporarily the value, staying until the user clicks\nelsewhere in the circuit.\nSecond radix when wire poked:\nConfigures the second part of how wire values are displayed."
  },
  {
    "id": 51,
    "title": "L'onglet exp\u00e9rimental",
    "url": "/fr/html/guide/prefs/exp.html",
    "text": "The Experimental tab\nThe Experimental tab\nThese preferences enable features that are considered experimental,\ninserted to garner user feedback.\nGraphics acceleration: One Logisim user observed\nthat adding -Dsun.java2d.d3d=True to the command line seemed\nto improve Logisim's graphics performance by telling it to use hardware graphics\nacceleration. This drop-down box attempts to\nconfigure Logisim to set this up; reports about whether this drop-down box has\nany effect on performance would be welcome. It won't have\nany effect until Logisim is restarted."
  },
  {
    "id": 52,
    "title": "La ligne de commande",
    "url": "/fr/html/guide/prefs/cmdline.html",
    "text": "Command-line options\nCommand-line options\nYou can configure many of Logisim's application preferences via command\nline options.\nThis can be particularly useful in a laboratory of\nsingle-student computers where you want Logisim to start up the same\nfor students every time, regardless of how previous students may have\nconfigured the program.\nThe overall command-line syntax is as follows.\njava -jar jarFileName [options] [filenames]\nThe optional additional files named on the command line will be\nopened as separate windows within Logisim.\nThe following example starts Logisim in its basic configuration.\njava -jar jarFileName -plain -gates shaped -locale en\nSupported options include the following.\n-plain\n-empty\n-template templateFile\nConfigures the template for Logisim to use.\n-gates [shaped|rectangular]\nConfigures which type of gate to use.\n-locale localeIdentifier\nConfigures which translation to use. As of this writing, the\nsupported locales include:\ndeGerman\nenEnglish\nesSpanish\nruRussian\nelGreek\n-accents [yes|no]\nThis is only relevant for languages that use characters\noutside the 7-bit ASCII character set; this would include\nlanguages using accented characters, and it would not\ninclude English.\nIf no, characters outside the 7-bit ASCII character\nset are replaced with equivalents appropriate to the language;\nthis would be useful for Java/OS combinations where such characters\nare not supported well.\n-clearprops\nClear all application preferences at startup, so Logisim will act as\nif it were being executed on the host system for the first time.\n-nosplash\nHides the initial Logisim splash screen.\n-help\nDisplays a summary of the command line options.\n-version\nDisplays the Logisim version number."
  },
  {
    "id": 53,
    "title": "Options de projet",
    "url": "/fr/html/guide/opts/index.html",
    "text": "Project Options\nProject Options\nLogisim supports two categories of configuration options:\napplication preferences and project options.\nThe application preferences address preferences that span all open\nprojects, whereas project options are specific to that one project.\nThis section discusses project options;\napplication preferences are described in another\nsection.\nYou can view and edit project options via the Options...\noption from the Project menu. It brings up the Options window\nwith several tabs.\nWe will discuss each of these tabs separately.\nThe Simulation tab\nThe Toolbar tab\nThe Mouse tab\nAt the bottom of the window is the Revert All To Template\nbutton. When clicked, all the options and tool attributes change\nto the settings in the current template (as selected under the\napplication preferences)."
  },
  {
    "id": 54,
    "title": "Onglet simulation",
    "url": "/fr/html/guide/opts/simulate.html",
    "text": "The Simulation tab\nThe Simulation tab\nThe Simulation tab allows configuration of the algorithm used for\nsimulating circuits. These parameters apply to all circuits being\nsimulated in the same window, even for circuits that exist in other\nlibraries loaded within the project.\nThe Iterations Until Oscillation drop-down menu\nspecifies how long to simulate a circuit before deciding that it is\noscillating. The number represents the number of clicks of the internal\nhidden clock (a simple gate takes just one click). The default of 1,000\nis good enough for almost all purposes, even for large circuits. But you\nmay want to increase the number of iterations if you are working with a\ncircuit where Logisim reports false oscillations. This is unlikely to be a\nproblem in practice, but one such a circumstance is a circuit that incorporates\nmany of the below latch circuits with random noise enabled. You may want to\ndecrease the number of iterations if you are working with a circuit that is\nprone to oscillating and you are using an unusually slow processor.\nThe Gate Output When Undefined drop-down menu configures\nhow the built-in logic gates behave when some inputs are unconnected or are\nfloating. By default, Logisim ignores such inputs, allowing a gate to work over\nfewer inputs than it was designed for. However, in real life, a gate will behave\nunpredictably in such a situation, and so this drop-down menu allows one to\nchange the gates so that they treat such disconnected inputs as errors.\nThe Add Noise To Component Delays checkbox\nallows you to enable or disable the random noise that is added to the\ndelays of components. The internal simulation uses a hidden clock for\nits simulation, and to provide a somewhat realistic simulation, each\ncomponent (excluding wires and splitters) has a delay between when it\nreceives an input and when it emits an output. If this option is\nenabled, Logisim will occassionally (about once every 16\ncomponent reactions) make a component take one click longer than\nnormal.\nI recommend keeping this option off, as this technique does introduce rare\nerrors with normal circuits."
  },
  {
    "id": 55,
    "title": "Onglet de la bo\u00eete \u00e0 outils",
    "url": "/fr/html/guide/opts/toolbar.html",
    "text": "The Toolbar tab\nThe Toolbar tab\nThe Toolbar tab allows you to configure what tools appear in\nthe toolbar.\nThe left side is an explorer listing all the tools available,\nand the list on the right side displays the current contents of the\ntoolbar.\n(Three dashes \"---\" indicate a\nseparator, which is drawn as a gray line.)\nBetween the explorer and the list are five buttons and a combo box:\nAdd Tool adds the currently selected\ntool in the explorer at left to the end of the toolbar.\nAdd Separator adds a separator\nto the end of the toolbar.\nMove Up moves the currently selected\nitem of the toolbar up/left one spot.\nMove Down moves the currently selected\nitem of the toolbar down/right one spot.\nRemove removes the currently selected\nitem from the toolbar.\nThe attributes associated with the tools are not displayed in\nthis window; instead, you can view and edit them within the main\ndrawing window."
  },
  {
    "id": 56,
    "title": "Onglet du pointeur",
    "url": "/fr/html/guide/opts/mouse.html",
    "text": "The Mouse tab\nThe Mouse tab\nBy default, when you click the mouse in Logisim's drawing area,\nthe currently selected tool will be used. If you right-click or\ncontrol-click, it will display a pop-up menu for the current component\nbelow the mouse.\nLogisim allows you to modify this behavior, relieving you of the\nneed to go to the toolbar and/or the explorer all the time.\n(This may\nalso be handy if you are left-handed.) Each combination of a mouse\nbutton and a modifier key (any subset of shift, control, and alt) can be mapped to a\ndifferent tool.\nThe Mouse tab allows you to configure these mappings.\nOn the left side is an explorer where you can choose the tool\nyou want to map.\nOn the right top side is a rectangle in which you can click\nusing the mouse combination you want to click. For example, if you\nwant to create new wires by shift-dragging, then you would first\nselect the Wiring Tool in the Explorer (under the Base library); and\nthen you would shift-click where it says \"Click Using Combination\nTo Map Wiring Tool.\" If that combination is already being used,\nthen the mapping would be replaced with the new tool.\nBelow this area is a list of current mappings.\nNote that\nany combinations that aren't listed simply use the currently selected\ntool.\nBelow is the Remove button, where you can delete the mapping\nthat is currently selected in the table above the button.\nIn the\nfuture, then, that mouse combination would map to whatever tool\nis currently selected in the toolbar or the explorer pane.\nBelow this is a list of attributes for the tool currently selected\nin the list of mappings. Each mouse-mapped tool has its own set of\nattributes, different from the attributes used in the explorer pane\nand in the toolbar. You can edit those attribute values here."
  },
  {
    "id": 57,
    "title": "Propagation des valeurs",
    "url": "/fr/html/guide/prop/index.html",
    "text": "Value propagation\nValue propagation\nLogisim's algorithm for simulating the propagation of values through\ncircuits is not something that you normally need to worry about. Suffice\nit to say that the algorithm is sophisticated enough to account for gate\ndelays, but not realistic enough to account for more difficult\nphenomena like varying voltages or race conditions.\nDo you still want to know more?\nGate delays\nOscillation errors\nShortcomings"
  },
  {
    "id": 58,
    "title": "D\u00e9lais sur les portes logiques",
    "url": "/fr/html/guide/prop/delays.html",
    "text": "Gate delays\nGate delays\nAs an example of the level of sophistication of Logisim's algorithm,\nconsider the following circuit.\nThis \"obviously\" always outputs 0. But NOT gates don't react\ninstantaneously to their inputs in reality, and neither do they in\nLogisim. As a result, when this circuit's input changes from 0 to 1, the\nAND gate will briefly see two 1 inputs, and it will emit a 1 briefly.\nYou won't see it on the screen. But the effect is observable when we\nuse the AND gate's output as an input into the clock of a D flip-flop.\nPoking the 0 input to become 1 leads to an instantaneous 1 going\ninto the D flip-flop, and thus the flip-flop's value will toggle\nevery time the circuit input goes from 0 to 1.\nEvery component has a delay associated with it. More sophisticated\ncomponents built into Logisim tend to have larger delays, but\nthese delays are somewhat arbitrary and may not reflect reality.\nFrom a technical point of view, it is relatively easy to deal with\nthis level of sophistication in a single circuit.\nDealing with gate\ndelays well across subcircuits, though, is a bit more complex;\nLogisim does attempt to address this correctly by placing all primitive\ncomponent's propagation values into a single schedule regardless of the\nsubcircuit in which the component lies.\n(Via the Project Options window's\nSimulation tab, you can configure Logisim\nto add a random, occasional delay to a component's propagation. This is intended\nto simulate the unevenness of real circuits. In particular, an R-S latch built\nusing two NOR gates will oscillate without this randomness, as both gates will\nprocess their inputs in lockstep. This randomness is disabled by default.)\nNote that I'm stopping short of saying that Logisim\nalways addresses gate delays well.\nBut at least it tries."
  },
  {
    "id": 59,
    "title": "Erreurs oscillatoire",
    "url": "/fr/html/guide/prop/oscillate.html",
    "text": "Oscillation errors\nOscillation errors\nThe propagation algorithm, which normally works silently without any\nproblems, will become very visible\nwhen you create a circuit that oscillates.\nThis circuit is currently in a stable condition. But if you change the\ninput to 1, the circuit will effectively enter an infinite loop. After\na while, Logisim will simply give up and show an \"Oscillation apparent\" message\ntelling you that it believes that the circuit is oscillating.\nIt will display the values it has at the time it gives up. These values\nwill look wrong - in this screen shot, the AND gate is emitting 1\nalthough one of its inputs is 0, but it could be that the NOT gate\nhas a 1 input and a 1 output.\nLogisim helpfully circles in red each location that seems to be\ninvolved in the oscillation. If an involved point lies within a\nsubcircuit, Logisim will draw that subcircuit's outline in red.\nWhen Logisim detects oscillation, it shuts down all\nfurther simulation. You can re-enable simulation using the\nSimulate menu's Simulation Enabled option.\nLogisim detects oscillation using a fairly simple technique: If the\ncircuit simulation seems to many iterations, then it will simply give up\nand report oscillation. (The points it identifies as being involved are\nthose that were touched in the last 25% of the iterations.)\nThus, it could erroneously report oscillation,\nparticularly if you are working with an exceptionally large circuit; but\nit would be one that is larger than any I have built using Logisim.\nIn any case, if you are confident that the reporting is in error, you\ncan configure the number of iterations\ncompleted before oscillation occurs via the\nProject Options window's\nSimulation tab."
  },
  {
    "id": 60,
    "title": "Limitations",
    "url": "/fr/html/guide/prop/shortcome.html",
    "text": "Shortcomings\nShortcomings\nLogisim's propagation algorithm is more than sophisticated enough\nfor almost all educational purposes; but it is not sophisticated\nenough for industrial circuit design. In order from most damning to\nleast damning, the shortcomings of Logisim's propagation technique\ninclude:\nExcept for the issue of gate delays, Logisim does not particularly\nconcern itself with timing issues. It is very idealized, so that a pair of NOR\ngates in an S-R latch configuration will toggle in lockstep infinitely, rather\nthan the circuit eventually settle into a stable state.\nLogisim cannot simulate subcircuits whose pins sometimes behave\nas inputs and sometimes behave as outputs. Components built using\nJava can have such pins, though: Within the built-in libraries,\nthe Memory library's RAM circuit contains a D pin that can act both\nas an input and as an output.\nLogisim cuts off its simulation after a fixed number of iterations\nassuming that there is an oscillation error.\nConceivably, a large circuit that does not oscillate could lead to\ntrouble.\nLogisim does nothing with respect to discriminating between\nvoltage levels: A bit can be only on, off, unspecified, or error.\nThere are additional shortcomings, too, that I have omitted because\nthey are so obscure that if you were aware of them, it would be obvious\nthat Logisim comes nowhere close to that level. As an extreme example,\nI have a friend who works for a major chip manufacturer, and his\njob is to worry about \"bubbles\" in chips' nanometer-wide wires growing\nand leading to random disconnection.\nEven beyond this, I am not a circuit design specialist; thus,\nthere may well be errors in the propagation technique of which I am\nnot aware. I welcome corrections from experts."
  },
  {
    "id": 61,
    "title": "Librairies JAR",
    "url": "/fr/html/guide/jar/index.html",
    "text": "Librairies JAR\nLibrairies JARJAR\nUtiliser des librairies JAR\nLogisim a deux types de composants de circuit: ceux qui sont con\u00e7us dans Logisim comme une\ncombinaison de composants et ceux qui sont des composants primitifs \u00e9crits en Java.\nLes circuit Logisim sont bien plus simple \u00e0 concevoir, mais ils ne supportent pas\ndes interactions sophistiqu\u00e9es avec l'utilisateur et ils sont relativement inefficace.\nLogisim contient une bonne collection de librairies incluses avec des composants Java,\nmais il peut \u00e9galement charger des librairies suppl\u00e9mentaires de composants \u00e9crites par vous\nou d'autres. Une fois que vous avez t\u00e9l\u00e9charger une librairie, vous pouvez l'importer dans votre\nprojet en faisant un clic droit sur le projet dans le panneau de navigation (la ligne du haut) et\nen choisissant Charger Librairie > Librairie JAR .... Ensuite, Logisim vous demandera\nde s\u00e9lectionner le fichier JAR. (Dans certaines circonstances, vous pourriez avoir \u00e0 sp\u00e9cifier\nle nom de la classe \u00e0 la demande, celui-ci devrait vous \u00eatre fourni par le d\u00e9veloppeur\nde la librairie. Cependant, le d\u00e9veloppeur devrait normalement configurer la librairie JAR\npour \u00e9viter cela (en incluant un fichier manifest dans le JAR avec l'attribut\nLibrary-Class pr\u00e9cisant le nom de la classe principale).)\nCr\u00e9er une librairie JAR\nLe reste de cette section est consacr\u00e9 \u00e0 une s\u00e9rie d'exemples comment\u00e9s\nqui illustrent comment d\u00e9velopper des librairies Logisim par vous m\u00eame.\nVous ne devriez essayer ceci que si vous \u00eatre un programmeur Java exp\u00e9riment\u00e9.\nVous trouverez une documentation assez maigre au-del\u00e0 des exemples donn\u00e9s.\nLa documentation qui suit, pour experts, n'a pas \u00e9t\u00e9 traduite\nYou can download a JAR file that allows these examples to be\nimported into Logisim via the Logisim Web site's Links section.\nThat JAR file also contains the source code\ncontained in these examples.\nGray Code Incrementer\nIllustrates the essential components of any component type\nusing a simple example of a component that takes a multibit input\nand computes the next Gray code value following it.\nLibrary Class\nIllustrates how to define a library. This is the entry point\nfor any JAR file - the class whose name the user enters when\nloading the JAR library.\nSimple Gray Code Counter\nIllustrates how to make a component that has internal state,\nin particular an 8-bit counter that iterates through Gray codes.\nGray Code Counter\nDemonstrates a complete, fairly sophisticated component with\nwhich the user can interact. It implements a Gray code counter where the\nnumber of bits remembered is customizable, and where the user can\nedit the current value by clicking on it with the Poke Tool and\ntyping a value.\nGuidelines\nGeneral information for those developing third-party libraries.\nLicense\nThe code in this example JAR library is released under the MIT license,\na more permissive license than the GPL, under which the rest of Logisim is\nreleased.\nCopyright (c) 2009, Carl Burch.\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "id": 62,
    "title": "Ajout en codage de Gray",
    "url": "/fr/html/guide/jar/incr.html",
    "text": "Gray Code Incrementer\nGray Code Incrementer\nEach component included in a library is defined by creating a subclass of\nInstanceFactory found in the\ncom.cburch.logisim.instance package. This subclass has all\nthe code involved\n(Here we're describing the API for the current version of Logisim.\nYou may find some libraries developed for older versions of Logisim, in\nwhich components were developed by defining two classes, one extending\nComponent and another extending ComponentFactory.\nVersion 2.3.0 introduced the much simpler InstanceFactory API; the\nolder technique is deprecated.)\nThree Logisim packages define most of the classes relevant to defining\ncomponent libraries.\ncom.cburch.logisim.instance\nContains classes specifically related to defining components,\nincluding the InstanceFactory, InstanceState,\nInstancePainter, and Instance classes.\ncom.cburch.logisim.data\nContains classes related to data elements associated with components,\nsuch as the Bounds class for representing bounding rectangles\nor the Value class for representing values that can\nexist on a wire.\ncom.cburch.logisim.tools\nContains classes related to the library definition.\nAbout Gray codes\nBefore we go on, let me briefly describe the Gray code on which these\nexamples are based. It's not really important to understanding how these\nexamples work, so you can safely skip to the code below if you wish -\nparticularly if you already know Gray codes.\nGray code is a technique (named after Frank Gray) for iterating through\nn-bit sequences with only one bit changed for each step. As an\nexample, consider the 4-bit Gray code listed below.\n0000\n0001\n0011\n0010\n0110\n0111\n0101\n0100\n1100\n1101\n1111\n1110\n1010\n1011\n1001\n1000\nEach value has the bit underlined that will change for the next value in\nthe sequence. For example, after 0000 comes 0001, in which the final bit has\nbeen toggled, so the final bit is underlined.\nLogisim's built-in components don't include anything working with Gray codes.\nBut electronics designers find Gray codes useful sometimes. One\nparticularly notable instance of Gray codes is along the axes in Karnaugh\nmaps.\nGrayIncrementer\nThis is a minimal example illustrating the essential elements\nto defining a component. This particular component is an incrementer,\nwhich takes an multibit input and produces the next Gray code following it\nin sequence.\npackage com.cburch.gray;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\n/** This component takes a multibit input and outputs the value that follows it\n* in Gray Code. For instance, given input 0100 the output is 1100. */\nclass GrayIncrementer extends InstanceFactory {\n/* Note that there are no instance variables. There is only one instance of\n* this class created, which manages all instances of the component. Any\n* information associated with individual instances should be handled\n* through attributes. For GrayIncrementer, each instance has a \"bit width\"\n* that it works with, and so we'll have an attribute. */\n/** The constructor configures the factory. */\nGrayIncrementer() {\nsuper(\"Gray Code Incrementer\");\n/* This is how we can set up the attributes for GrayIncrementers. In\n* this case, there is just one attribute - the width - whose default\n* is 4. The StdAttr class defines several commonly occurring\n* attributes, including one for \"bit width.\" It's best to use those\n* StdAttr attributes when appropriate: A user can then select several\n* components (even from differing factories) with the same attribute\n* and modify them all at once. */\nsetAttributes(new Attribute[] { StdAttr.WIDTH },\nnew Object[] { BitWidth.create(4) });\n/* The \"offset bounds\" is the location of the bounding rectangle\n* relative to the mouse location. Here, we're choosing the component to\n* be 30x30, and we're anchoring it relative to its primary output\n* (as is typical for Logisim), which happens to be in the center of the\n* east edge. Thus, the top left corner of the bounding box is 30 pixels\n* west and 15 pixels north of the mouse location. */\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\n/* The ports are locations where wires can be connected to this\n* component. Each port object says where to find the port relative to\n* the component's anchor location, then whether the port is an\n* input/output/both, and finally the expected bit width for the port.\n* The bit width can be a constant (like 1) or an attribute (as here).\n*/\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, StdAttr.WIDTH),\nnew Port(0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n}\n/** Computes the current output for this component. This method is invoked\n* any time any of the inputs change their values; it may also be invoked in\n* other circumstances, even if there is no reason to expect it to change\n* anything. */\npublic void propagate(InstanceState state) {\n// First we retrieve the value being fed into the input. Note that in\n// the setPorts invocation above, the component's input was included at\n// index 0 in the parameter array, so we use 0 as the parameter below.\nValue in = state.getPort(0);\n// Now compute the output. We've farmed this out to a helper method,\n// since the same logic is needed for the library's other components.\nValue out = nextGray(in);\n// Finally we propagate the output into the circuit. The first parameter\n// is 1 because in our list of ports (configured by invocation of\n// setPorts above) the output is at index 1. The second parameter is the\n// value we want to send on that port. And the last parameter is its\n// \"delay\" - the number of steps it will take for the output to update\n// after its input.\nstate.setPort(1, out, out.getWidth() + 1);\n}\n/** Says how an individual instance should appear on the canvas. */\npublic void paintInstance(InstancePainter painter) {\n// As it happens, InstancePainter contains several convenience methods\n// for drawing, and we'll use those here. Frequently, you'd want to\n// retrieve its Graphics object (painter.getGraphics) so you can draw\n// directly onto the canvas.\npainter.drawRectangle(painter.getBounds(), \"G+1\");\npainter.drawPorts();\n}\n/** Computes the next gray value in the sequence after prev. This static\n* method just does some bit twiddling; it doesn't have much to do with\n* Logisim except that it manipulates Value and BitWidth objects. */\nstatic Value nextGray(Value prev) {\nBitWidth bits = prev.getBitWidth();\nif(!prev.isFullyDefined()) return Value.createError(bits);\nint x = prev.toIntValue();\nint ct = (x >> 16) ^ x; // compute parity of x\nct = (ct >> 8) ^ ct;\nct = (ct >> 4) ^ ct;\nct = (ct >> 2) ^ ct;\nct = (ct >> 1) ^ ct;\nif((ct & 1) == 0) { // if parity is even, flip 1's bit\nx = x ^ 1;\n} else { // else flip bit just above last 1\nint y = x ^ (x & (x - 1)); // first compute the last 1\ny = (y << 1) & bits.getMask();\nx = (y == 0 ? 0 : x ^ y);\n}\nreturn Value.createKnown(bits, x);\n}\n}\nThis example by itself is not enough to create a working JAR file;\nyou must also provide a Library class, as illustrated on the next page."
  },
  {
    "id": 63,
    "title": "Classe librairie",
    "url": "/fr/html/guide/jar/library.html",
    "text": "Library Class\nLibrary Class\nThe access point for the JAR library is a class that extends the\nLibrary class. The library's main job is to list the tools that are\navailable through the library; most often, the tools are all tools\nto add the various components defined - that is, instances of the\nAddTool class working with different component factories.\nComponents\npackage com.cburch.gray;\nimport java.util.Arrays;\nimport java.util.List;\nimport com.cburch.logisim.tools.AddTool;\nimport com.cburch.logisim.tools.Library;\n/** The library of components that the user can access. */\npublic class Components extends Library {\n/** The list of all tools contained in this library. Technically,\n* libraries contain tools, which is a slightly more general concept\n* than components; practically speaking, though, you'll most often want\n* to create AddTools for new components that can be added into the circuit.\n*/\nprivate List<AddTool> tools;\n/** Constructs an instance of this library. This constructor is how\n* Logisim accesses first when it opens the JAR file: It looks for\n* a no-arguments constructor method of the user-designated class.\n*/\npublic Components() {\ntools = Arrays.asList(new AddTool[] {\nnew AddTool(new GrayIncrementer()),\nnew AddTool(new SimpleGrayCounter()),\nnew AddTool(new GrayCounter()),\n});\n}\n/** Returns the name of the library that the user will see. */\npublic String getDisplayName() {\nreturn \"Gray Tools\";\n}\n/** Returns a list of all the tools available in this library. */\npublic List<AddTool> getTools() {\nreturn tools;\n}\n}"
  },
  {
    "id": 64,
    "title": "Conteur simple en codage de Gray",
    "url": "/fr/html/guide/jar/simpctr.html",
    "text": "Simple Gray Code Counter\nSimple Gray Code Counter\nOften we want components that aren't exclusively combinational\nin nature - that is, we want the component to have some memory.\nThere is an important subtlety in defining such components: You\ncan't have the component itself store the state, because an\nindividual component can appear many times in the same circuit.\nIt can't appear directly within a circuit multiple times, but\nit can appear multiple times if it appears in a subcircuit that\nis used several times.\nThe solution is to create a new class for representing the\nobject's current state, and to associate instances of this with\nthe component through the parent circuit's state. In this example,\nwhich implements an edge-triggered 4-bit Gray code counter, we define a\nCounterData class to represent the counter's state, in addition\nto the InstanceFactory subclass as illustrated previously.\nThe CounterData object remembers both the counter's\ncurrent value, as well as the last clock input seen (to detect\nrising edges).\nCounterData\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstanceData;\nimport com.cburch.logisim.instance.InstanceState;\n/** Represents the state of a counter. */\nclass CounterData implements InstanceData, Cloneable {\n/** Retrieves the state associated with this counter in the circuit state,\n* generating the state if necessary.\n*/\npublic static CounterData get(InstanceState state, BitWidth width) {\nCounterData ret = (CounterData) state.getData();\nif(ret == null) {\n// If it doesn't yet exist, then we'll set it up with our default\n// values and put it into the circuit state so it can be retrieved\n// in future propagations.\nret = new CounterData(null, Value.createKnown(width, 0));\nstate.setData(ret);\n} else if(!ret.value.getBitWidth().equals(width)) {\nret.value = ret.value.extendWidth(width.getWidth(), Value.FALSE);\n}\nreturn ret;\n}\n/** The last clock input value observed. */\nprivate Value lastClock;\n/** The current value emitted by the counter. */\nprivate Value value;\n/** Constructs a state with the given values. */\npublic CounterData(Value lastClock, Value value) {\nthis.lastClock = lastClock;\nthis.value = value;\n}\n/** Returns a copy of this object. */\npublic Object clone() {\n// We can just use what super.clone() returns: The only instance variables are\n// Value objects, which are immutable, so we don't care that both the copy\n// and the copied refer to the same Value objects. If we had mutable instance\n// variables, then of course we would need to clone them.\ntry { return super.clone(); }\ncatch(CloneNotSupportedException e) { return null; }\n}\n/** Updates the last clock observed, returning true if triggered. */\npublic boolean updateClock(Value value) {\nValue old = lastClock;\nlastClock = value;\nreturn old == Value.FALSE && value == Value.TRUE;\n}\n/** Returns the current value emitted by the counter. */\npublic Value getValue() {\nreturn value;\n}\n/** Updates the current value emitted by the counter. */\npublic void setValue(Value value) {\nthis.value = value;\n}\n}\nSimpleCounter\npackage com.cburch.gray;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Manufactures a simple counter that iterates over the 4-bit Gray Code. This\n* example illustrates how a component can maintain its own internal state. All\n* of the code relevant to state, though, appears in CounterData class. */\nclass SimpleGrayCounter extends InstanceFactory {\nprivate static final BitWidth BIT_WIDTH = BitWidth.create(4);\n// Again, notice how we don't have any instance variables related to an\n// individual instance's state. We can't put that here, because only one\n// SimpleGrayCounter object is ever created, and its job is to manage all\n// instances that appear in any circuits.\npublic SimpleGrayCounter() {\nsuper(\"Gray Counter (Simple)\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, BIT_WIDTH.getWidth()),\n});\n}\npublic void propagate(InstanceState state) {\n// Here I retrieve the state associated with this component via a helper\n// method. In this case, the state is in a CounterData object, which is\n// also where the helper method is defined. This helper method will end\n// up creating a CounterData object if one doesn't already exist.\nCounterData cur = CounterData.get(state, BIT_WIDTH);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n// (You might be tempted to determine the counter's current value\n// via state.getPort(1). This is erroneous, though, because another\n// component may be pushing a value onto the same point, which would\n// \"corrupt\" the value found there. We really do need to store the\n// current value in the instance.)\n}\npublic void paintInstance(InstancePainter painter) {\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST); // draw a triangle on port 0\npainter.drawPort(1); // draw port 1 as just a dot\n// Display the current counter value centered within the rectangle.\n// However, if the context says not to show state (as when generating\n// printer output), then skip this.\nif(painter.getShowState()) {\nCounterData state = CounterData.get(painter, BIT_WIDTH);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(BIT_WIDTH.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}"
  },
  {
    "id": 65,
    "title": "Conteur en codage de Gray",
    "url": "/fr/html/guide/jar/counter.html",
    "text": "Gray Code Counter\nGray Code Counter\nThis orientation to the Logisim libraries concludes with a\nfairly sophisticated Gray code counter that allows the user to alter its\ncurrent value using the Poke Tool and to place a label on the component using\nthe Text Tool. It also customizes the icon that appears in the explorer,\nassociated with the tool.\nGrayCounter\npackage com.cburch.gray;\nimport java.net.URL;\nimport javax.swing.ImageIcon;\nimport com.cburch.logisim.data.Attribute;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Direction;\nimport com.cburch.logisim.instance.Instance;\nimport com.cburch.logisim.instance.InstanceFactory;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.Port;\nimport com.cburch.logisim.instance.StdAttr;\nimport com.cburch.logisim.util.GraphicsUtil;\nimport com.cburch.logisim.util.StringUtil;\n/** Manufactures a counter that iterates over Gray codes. This demonstrates\n* several additional features beyond the SimpleGrayCounter class. */\nclass GrayCounter extends InstanceFactory {\npublic GrayCounter() {\nsuper(\"Gray Counter\");\nsetOffsetBounds(Bounds.create(-30, -15, 30, 30));\nsetPorts(new Port[] {\nnew Port(-30, 0, Port.INPUT, 1),\nnew Port(\n0, 0, Port.OUTPUT, StdAttr.WIDTH),\n});\n// We'll have width, label, and label font attributes. The latter two\n// attributes allow us to associate a label with the component (though\n// we'll also need configureNewInstance to configure the label's\n// location).\nsetAttributes(\nnew Attribute[] { StdAttr.WIDTH, StdAttr.LABEL, StdAttr.LABEL_FONT },\nnew Object[] { BitWidth.create(4), \"\", StdAttr.DEFAULT_LABEL_FONT });\n// The following method invocation sets things up so that the instance's\n// state can be manipulated using the Poke Tool.\nsetInstancePoker(CounterPoker.class);\n// These next two lines set it up so that the explorer window shows a\n// customized icon representing the component type. This should be a\n// 16x16 image.\nURL url = getClass().getClassLoader().getResource(\"com/cburch/gray/counter.gif\");\nif(url != null) setIcon(new ImageIcon(url));\n}\n/** The configureNewInstance method is invoked every time a new instance\n* is created. In the superclass, the method doesn't do anything, since\n* the new instance is pretty thoroughly configured already by default. But\n* sometimes you need to do something particular to each instance, so you\n* would override the method. In this case, we need to set up the location\n* for its label. */\nprotected void configureNewInstance(Instance instance) {\nBounds bds = instance.getBounds();\ninstance.setTextField(StdAttr.LABEL, StdAttr.LABEL_FONT,\nbds.getX() + bds.getWidth() / 2, bds.getY() - 3,\nGraphicsUtil.H_CENTER, GraphicsUtil.V_BASELINE);\n}\npublic void propagate(InstanceState state) {\n// This is the same as with SimpleGrayCounter, except that we use the\n// StdAttr.WIDTH attribute to determine the bit width to work with.\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nCounterData cur = CounterData.get(state, width);\nboolean trigger = cur.updateClock(state.getPort(0));\nif(trigger) cur.setValue(GrayIncrementer.nextGray(cur.getValue()));\nstate.setPort(1, cur.getValue(), 9);\n}\npublic void paintInstance(InstancePainter painter) {\n// This is essentially the same as with SimpleGrayCounter, except for\n// the invocation of painter.drawLabel to make the label be drawn.\npainter.drawBounds();\npainter.drawClock(0, Direction.EAST);\npainter.drawPort(1);\npainter.drawLabel();\nif(painter.getShowState()) {\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nCounterData state = CounterData.get(painter, width);\nBounds bds = painter.getBounds();\nGraphicsUtil.drawCenteredText(painter.getGraphics(),\nStringUtil.toHexString(width.getWidth(), state.getValue().toIntValue()),\nbds.getX() + bds.getWidth() / 2,\nbds.getY() + bds.getHeight() / 2);\n}\n}\n}\nCounterPoker\npackage com.cburch.gray;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport com.cburch.logisim.data.BitWidth;\nimport com.cburch.logisim.data.Bounds;\nimport com.cburch.logisim.data.Value;\nimport com.cburch.logisim.instance.InstancePainter;\nimport com.cburch.logisim.instance.InstancePoker;\nimport com.cburch.logisim.instance.InstanceState;\nimport com.cburch.logisim.instance.StdAttr;\n/** When the user clicks a counter using the Poke Tool, a CounterPoker object\n* is created, and that object will handle all user events. Note that\n* CounterPoker is a class specific to GrayCounter, and that it must be a\n* subclass of InstancePoker in the com.cburch.logisim.instance package. */\npublic class CounterPoker extends InstancePoker {\npublic CounterPoker() { }\n/** Determines whether the location the mouse was pressed should result\n* in initiating a poke.\n*/\npublic boolean init(InstanceState state, MouseEvent e) {\nreturn state.getInstance().getBounds().contains(e.getX(), e.getY());\n// Anywhere in the main rectangle initiates the poke. The user might\n// have clicked within a label, but that will be outside the bounds.\n}\n/** Draws an indicator that the caret is being selected. Here, we'll draw\n* a red rectangle around the value. */\npublic void paint(InstancePainter painter) {\nBounds bds = painter.getBounds();\nBitWidth width = painter.getAttributeValue(StdAttr.WIDTH);\nint len = (width.getWidth() + 3) / 4;\nGraphics g = painter.getGraphics();\ng.setColor(Color.RED);\nint wid = 7 * len + 2; // width of caret rectangle\nint ht = 16; // height of caret rectangle\ng.drawRect(bds.getX() + (bds.getWidth() - wid) / 2,\nbds.getY() + (bds.getHeight() - ht) / 2, wid, ht);\ng.setColor(Color.BLACK);\n}\n/** Processes a key by just adding it onto the end of the current value. */\npublic void keyTyped(InstanceState state, KeyEvent e) {\n// convert it to a hex digit; if it isn't a hex digit, abort.\nint val = Character.digit(e.getKeyChar(), 16);\nBitWidth width = state.getAttributeValue(StdAttr.WIDTH);\nif(val < 0 || (val & width.getMask()) != val) return;\n// compute the next value\nCounterData cur = CounterData.get(state, width);\nint newVal = (cur.getValue().toIntValue() * 16 + val) & width.getMask();\nValue newValue = Value.createKnown(width, newVal);\ncur.setValue(newValue);\nstate.fireInvalidated();\n// You might be tempted to propagate the value immediately here, using\n// state.setPort. However, the circuit may currently be propagating in\n// another thread, and invoking setPort directly could interfere with\n// that. Using fireInvalidated notifies the propagation thread to\n// invoke propagate on the counter at its next opportunity.\n}\n}"
  },
  {
    "id": 66,
    "title": "Recommandations",
    "url": "/fr/html/guide/jar/guide.html",
    "text": "Guidelines\nGuidelines\nLearning more\nBeyond the sequence of examples provided here, the Logisim source code\nprovides copious additional examples, though they do not always illustrate\nthe same attention to readability and good design.\nFor maximum portability to future versions, you should stick as much\nas possible to the classes in the ...instance, ...data,\nand ...tools packages. Of course, you may use other packages'\nAPIs, but they are more vulnerable to changes in future versions of Logisim.\nI am generally willing to answer occasional requests for help. And bug\nreports and suggestions for improvements, of course, are always welcome.\nDistribution\nYou are free to distribute any JARs you develop without restriction.\nThe GPL restrictions do apply, however, if portions of your work are\nderived from portions of Logisim source code (released under the GPL).\nDeriving from the example code in this section of the User's Guide\ndoes not incur such restrictions; these examples are released under the\nMIT license.\nIf you would like to share your library with other Logisim users,\nI will be happy to provide a link to a hosting Web page or the\nJAR file itself through the Logisim Web site. If you think your library\nshould be built into the basic Logisim release, then I welcome your\nsuggestion, and I'll be happy to acknowledge your contribution in\nLogisim releases including the work."
  },
  {
    "id": 67,
    "title": "A propos du programme",
    "url": "/fr/html/guide/about/index.html",
    "text": "About the program\nAbout the program\nLogisim is open-source software. The source code is included\nin the src subdirectory of the distributed JAR file.\nIf you find Logisim useful, please let me know. Especially\ndo this if you are an educational institution; the information will\nhelp me in gaining support for the work.\nI welcome e-mails about Logisim, including bug reports, suggestions,\nand fixes. When you e-mail me, please remember that I have worked hard\nto produce Logisim without receiving any payment from you.\nIf you want\na right to complain about the software, then I would suggest shelling\nout the money for a competing program to Logisim. (I know of no\nopen-source competitors that approach Logisim's feature set.)\nNonetheless, I remain interested in continuing to improve Logisim, and\nyour suggestions will be most welcome.\nCopyright notice\nCopyright (c) 2005, Carl Burch.\nLogisim is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2 of\nthe License, or (at your option) any later version.\nLogisim is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\nGeneral Public License for more details.\nAcknowledgements\nThe source code to Logisim is primarily my own work; I must\nacknowledge my employers who fund my work as a professor, including\nthis program: I started the program at Saint John's\nUniversity (Collegeville, Minnesota, USA) in 2000-2004, and I have\ncontinued it at Hendrix College (Conway, Arkansas, USA) from 2004\nto present. I am very grateful to these colleges for\ngiving me the time and resources to work on this project. If only\nall colleges and universities had their act as together and cared as\nmuch about excellent teaching as these colleges do!\nSome other people who have been particularly helpful:\nTheldo Cruz Franqueira, Thanos Kakarountas, Ilia Lilov, Pablo Leal Ramos,\nand Uwe Zimmermann, who have contributed\nto translations packaged with Logisim. More information about the translations\ncan be found on International Preferences\npage.\nThe Spring 2005 CS61C class at the University of California, Berkeley,\nwhich endured the beta versions of Logisim 2.0. These students put up with\nmany bugs, and I am very appreciative for their\npatience and for their suggestions!\nThe Spring 2001 CSCI 150 classes at the College of Saint Benedict and\nSaint John's University, which used the most rudimentary versions of Logisim\nas it was being developed.\nSeveral pieces of Logisim come from others' packages that Logisim\nuses; several of these pieces are distributed as part of Logisim.\nSun's Java API (obviously)\nSun's JavaHelp project\nProvides the integrated help system from the Help menu.\nMRJAdapter, from Steve Roy\nIntegration with the Macintosh OS X platform.\nlaunch4j, from Grzegorz Kowalt\nAllows distribution of Logisim as a Windows executable.\nColorPicker, from Jeremy Wood\nProvides the color dialog box that pops up when configuring colors (as with\nthe LED component).\nJFontChooser, from Christos Bohoris\nProvides the font selection dialog box that pops up when selecting font\nattributes (such as with the Label Font attribute of many components).\nTableSorter, ascribed to Philip Milne, Brendon McLean, Dan van Enckevort,\nParwinder Sekhon, and ouroborus@ouroborus.org\nProvides the ability to sort the table in the\nGet Circuit Statistics dialog through clicking column headers.\nFarm-Fresh Web Icons, http://www.fatcow.com/free-icons\nProvides the icons for controlling simulation that appear under the simulation tree.\nThese icons are released under the Creative Commons Attribution 3.0 License,\nand they cannot be redistributed under the terms of the GPL.\nAnd finally, I want to thank all the users who have contacted me -\nwhether with bug reports, with suggestions, or just to let me know\nthat they're using Logisim in their classes. I have to leave these\nsuggesters anonymous, because I don't have their permission to mention\nthem here, but:\nThank you!"
  },
  {
    "id": 68,
    "title": "GNU General Public License",
    "url": "/fr/html/guide/about/gpl.html",
    "text": "About This Program\nGNU GENERAL PUBLIC LICENSE\nVersion 2, June 1991\nCopyright (C) 1989, 1991 Free Software Foundation, Inc.\n51 Franklin St, Fifth Floor, Boston, MA\n02110-1301\nUSA\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\nPreamble\nThe licenses for most software are designed to take away your\nfreedom to share and change it.\nBy contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.\nThis\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.\n(Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)\nYou can apply it to\nyour programs, too.\nWhen we speak of free software, we are referring to freedom, not\nprice.\nOur General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\nTo protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.\nYou must make sure that they, too, receive or can get the\nsource code.\nAnd you must show them these terms so they know their\nrights.\nWe protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\nAlso, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.\nIf the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\nFinally, any free program is threatened constantly by software\npatents.\nWe wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.\nTo prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\nThe precise terms and conditions for copying, distribution and\nmodification follow.\nGNU GENERAL PUBLIC LICENSE\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.\nThe \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.\n(Hereinafter, translation is included without limitation in\nthe term \"modification\".)\nEach licensee is addressed as \"you\".\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.\nThe act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\na) You must cause the modified files to carry prominent notices\nstating that you changed the files and the date of any change.\nb) You must cause any work that you distribute or publish, that in\nwhole or in part contains or is derived from the Program or any\npart thereof, to be licensed as a whole at no charge to all third\nparties under the terms of this License.\nc) If the modified program normally reads commands interactively\nwhen run, you must cause it, when started running for such\ninteractive use in the most ordinary way, to print or display an\nannouncement including an appropriate copyright notice and a\nnotice that there is no warranty (or else, saying that you provide\na warranty) and that users may redistribute the program under\nthese conditions, and telling the user how to view a copy of this\nLicense.\n(Exception: if the Program itself is interactive but\ndoes not normally print such an announcement, your work based on\nthe Program is not required to print an announcement.)\nThese requirements apply to the modified work as a whole.\nIf\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.\nBut when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\na) Accompany it with the complete corresponding machine-readable\nsource code, which must be distributed under the terms of Sections\n1 and 2 above on a medium customarily used for software interchange; or,\nb) Accompany it with a written offer, valid for at least three\nyears, to give any third party, for a charge no more than your\ncost of physically performing source distribution, a complete\nmachine-readable copy of the corresponding source code, to be\ndistributed under the terms of Sections 1 and 2 above on a medium\ncustomarily used for software interchange; or,\nc) Accompany it with the information you received as to the offer\nto distribute corresponding source code.\n(This alternative is\nallowed only for noncommercial distribution and only if you\nreceived the program in object code or executable form with such\nan offer, in accord with Subsection b above.)\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.\nFor an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.\nHowever, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.\nAny attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n5. You are not required to accept this License, since you have not\nsigned it.\nHowever, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.\nThese actions are\nprohibited by law if you do not accept this License.\nTherefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.\nYou may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.\nIf you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.\nFor example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.\nMany people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.\nIn such case, this License incorporates\nthe limitation as if written in the body of this License.\n9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.\nSuch new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\nEach version is given a distinguishing version number.\nIf the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.\nIf the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.\nFor software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.\nOur decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\nNO WARRANTY\n11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\nTHE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.\nSHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\nEND OF TERMS AND CONDITIONS"
  },
  {
    "id": 69,
    "title": "Library Reference",
    "url": "/fr/html/libs/index.html",
    "text": "Library Reference\nLibrary Reference\nA Logisim library holds a set of tools that allow you to\ninteract with a circuit via clicking and dragging the mouse in the\ncanvas area. Most often, a tool is intended for adding components of a\nparticular type into a circuit; but some of the most important tools,\nsuch as the Poke Tool and the Select Tool, allow you to interact with\ncomponents in other ways.\nAll of the tools included in Logisim's built-in libraries are\ndocumented in this reference material.\nWiring library\nSplitter\nPin\nProbe\nTunnel\nPull Resistor\nClock\nConstant\nPower/Ground\nTransistor\nTransmission Gate\nBit Extender\nGates library\nNOT Gate\nBuffer\nAND/OR/NAND/NOR Gate\nXOR/XNOR/Odd Parity/Even Parity Gate\nControlled Buffer/Inverter\nPlexers library\nMultiplexer\nDemultiplexer\nDecoder\nPriority Encoder\nBit Selector\nArithmetic library\nAdder\nSubtractor\nMultiplier\nDivider\nNegator\nComparator\nShifter\nBit Adder\nBit Finder\nMemory library\nD/T/J-K/S-R Flip-Flop\nRegister\nCounter\nShift Register\nRandom\nRAM\nROM\nInput/Output library\nButton\nJoystick\nKeyboard\nLED\n7-Segment Display\nHex Digit Display\nLED Matrix\nTTY\nBase library\nPoke Tool\nEdit Tool\nSelect Tool\nWiring Tool\nText Tool\nMenu Tool\nLabel"
  },
  {
    "id": 70,
    "title": "Wiring library",
    "url": "/fr/html/libs/wiring/index.html",
    "text": "Biblioteca Conectar\nBiblioteca Conectar (Wiring)\nA biblioteca Conecar inclui componentes principalmente relacionados\n\u00e0s conex\u00f5es (fios) e aos conceitos el\u00e9tricos b\u00e1sicos.\nDistribuidor\nPino\nPonta de Prova\nT\u00fanel\nResistor Pull\nClock\nConstante\nFonte/Terra\nTransistor\nPorta de transmiss\u00e3o\nExtensor de Bits\nBiblioteca de Refer\u00eancias"
  },
  {
    "id": 71,
    "title": "Splitter",
    "url": "/fr/html/libs/wiring/splitter.html",
    "text": "Distribuidor\nDistribuidor\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.0 Beta 1\nApar\u00eancia:\nComportamento\nO distribuidor cria uma correspond\u00eancia entre um valor multibit e v\u00e1rios\nsubconjuntos separados de bits equivalentes. A despeito do seu nome, ele pode\nseparar tanto um valor multibit em partes, quanto combin\u00e1-las em um valor multibit\n- de fato ele poder\u00e1 fazer ambos de uma vez. Uma descri\u00e7\u00e3o mais completa dos\ndistribuidores poder\u00e1 ser encontrada na se\u00e7\u00e3o\n'Distribuidores' do\nGuia do Usu\u00e1rio.\nO Logisim trata os distribuidores de forma especial ao propagar sinais\ndentro de um circuito: enquanto todos os outros componentes precisam de um\natraso calculado para fins do seu comportamento na simula\u00e7\u00e3o, os sinais\npropagados pelos distribuidores (assim como tamb\u00e9m pelas conex\u00f5es) ser\u00e3o\ntransmitidos instantaneamente.\nNota: O termo distribuidor n\u00e3o \u00e9 um termo\npadronizado, \u00e9 \u00fanico do Logisim at\u00e9 onde eu saiba. Desconhe\u00e7o qualquer\ntermo padr\u00e3o para tal conceito; o \u00fanico termo que j\u00e1 v\u00ed foi \"bus ripper\",\nmas esse termo \u00e9 desnecessariamente violento para o meu gosto.\nPinos\nPara distinguir entre os diversos pontos de conex\u00e3o em um distribuidor,\nirei referir-me \u00e0 termina\u00e7\u00e3o com um ponto de conex\u00e3o como sua\nextremidade combinada, e aos m\u00faltiplos pontos de conex\u00e3o do outro\nlado como sua extremidade dividida.\nA extremidade combinada (entrada/sa\u00edda, com largura em bits de acordo com o\natributo Bits de Dados)\nRepresentar\u00e1 um valor combinado por todos os bits que forem transmitidos pelo\ndistribuidor.\nA extremidade dividida (entrada/sa\u00edda, com largura em bits calculada com base\nnos atributos Bit x)\nO n\u00famero de extremidades divididas ser\u00e1 especificado pelo atributo Distribui\u00e7\u00e3o,\ne cada uma ter\u00e1 um \u00edndice que ser\u00e1 no m\u00ednimo igual a zero e menor que o valor desse\natributo. Para cada termina\u00e7\u00e3o, todos os bits para os quais o Bit\nx\nreferir-se por seu \u00edndice, ser\u00e3o transmitidos atrav\u00e9s da extremidade, e a ordem\ndesses bits ser\u00e1 a mesma na extremidade combinada.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nos d\u00edgitos de '0 'a '9' poder\u00e3o alterar o atributo\nDistribui\u00e7\u00e3o,\nAlt-0 at\u00e9 ALT-9 ir\u00e3o alterar ambos os atributos\nDistribui\u00e7\u00e3o e\nLargura de Bits \u00e0 Entrada, e as teclas com setas poder\u00e3o\nalterar o seu atributo\nDire\u00e7\u00e3o.\nDire\u00e7\u00e3o\nA posi\u00e7\u00e3o da extremidade dividida em rela\u00e7\u00e3o \u00e0 combinada.\nDistribui\u00e7\u00e3o\nO n\u00famero de termina\u00e7\u00f5es em uma extremidade.\nLargura em Bits \u00e0 Entrada\nA largura em bits da extremidade combinada.\nBit x\nO \u00edndice de uma termina\u00e7\u00e3o ao qual o bit x corresponder\nna extremidade combinada. As termina\u00e7\u00f5es s\u00e3o indexadas a partir de 0 no\ntopo (para um distribuidor voltado para leste ou oeste) e a partir de 0\nda esquerda/oeste (para um distribuidor voltado para norte ou sul). Um\nbit pode ser especificado para n\u00e3o corresponder a qualquer uma das termina\u00e7\u00f5es.\nN\u00e3o h\u00e1 qualquer maneira pela qual um bit possa corresponder a m\u00faltiplas\ntermina\u00e7\u00f5es.\nComportamento da ferramenta Testar\nNenhum.\nComportamento da ferramenta Texto\nNenhum."
  },
  {
    "id": 72,
    "title": "Pin",
    "url": "/fr/html/libs/wiring/pin.html",
    "text": "Pino\nPino\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.0 Beta 1\nApar\u00eancia:\nComportamento\nUm pino pode ser uma sa\u00edda ou uma entrada para um circuito,\ndependendo do valor de seu atributo Sa\u00edda?. Ao desenhar um pino, o Logisim\nrepresentar\u00e1 as sa\u00eddas por c\u00edrculos ou ret\u00e2ngulos com bordas arredondadas,\ne as entradas ser\u00e3o representadas por quadrados ou ret\u00e2ngulos.\nEm ambos os casos, os bits individuais do valor que for recebido ou\nenviado ser\u00e1 mostrada pelo componente (exceto quando for pr\u00e9via de uma\nimpress\u00e3o, quando o componente apenas informar\u00e1 quantos bits poder\u00e1\ncomportar).\nUm pino \u00e9 conveniente para se interagir com um circuito, e os usu\u00e1rios\niniciantes do Logisim n\u00e3o precisar\u00e3o us\u00e1-los necessariamente. Mas um usu\u00e1rio\nque estiver construindo um circuito que use v\u00e1rios subcircuitos (como descrito\nna se\u00e7\u00e3o 'Subcircuitos' do\nGuia do Usu\u00e1rio) poder\u00e1 usar pinos para especificar a interface entre\num circuito e um subcircuito. Em particular, o pino de um layout de circuito\ndefine como ele aparecer\u00e1 quando for tomado por subcircuito e seu layout\nestiver sendo usado por outro. Em tal circuito, os valores enviados ou recebidos\npor essas posi\u00e7\u00f5es no subcircuito ser\u00e3o vinculados aos pinos internos de seu\nlayout.\nPinos\nO componente tem apenas um ponto de conex\u00e3o, que poder\u00e1 ser uma entrada\npara o componente se for um pino de sa\u00edda, ou uma sa\u00edda para o componente\ncaso seja um pino de entrada. Em ambos os casos, sua largura em bits\nir\u00e1 corresponder ao atributo Bits de Dados, e sua posi\u00e7\u00e3o ser\u00e1 especificada\npelo atributo Dire\u00e7\u00e3o.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nos d\u00edgitos de '0 'a '9' poder\u00e3o alterar o atributo\nBits de Dados ,\nAlt-0 at\u00e9 ALT-9 ir\u00e1 alterar o atributo\nDire\u00e7\u00e3o\ne\ne Alt mais as teclas com setas poder\u00e3o alterar o seu atributo\nPosi\u00e7\u00e3o do R\u00f3tulo.\nDire\u00e7\u00e3o\nA face do componente onde sua entrada/sa\u00edda dever\u00e1 estar.\nSa\u00edda?\nServe para especificar se o componente ir\u00e1 funcionar com entrada ou sa\u00edda.\n(Observar que se for um pino de entrada, ent\u00e3o o pino ir\u00e1 funcionar como se sua\ninterface dentro do circuito fosse uma sa\u00edda, e vice-versa.)\nBits de Dados\nO n\u00famero de bits para o valor que o pino pode tratar.\nTri-state?\nPara um pino de entrada, serve para configurar se o usu\u00e1rio poder\u00e1\nindicar que o pino poder\u00e1 emitir valores indefinidos (ou seja, flutuantes).\nEsse atributo lida apenas com a interface com o usu\u00e1rio; ele n\u00e3o ter\u00e1\nqualquer efeito sobre como o pino se comportar\u00e1 quanto o layout\ndo circuito for usado como um subcircuito.\nPara um pino de sa\u00edda, o atributo n\u00e3o ter\u00e1 efeito algum.\nComportamento para Ajuste\nPara um pino de entrada, o atributo especificar\u00e1 como um valor flutuante\ndever\u00e1 ser tratado quando recebido por uma entrada, talvez de um circuito que\nesteja usando o layout, como no caso de um subcircuito. Se \"imut\u00e1vel\",\nos valores flutuantes ser\u00e3o enviados como tal; se \"pull-up\", eles ser\u00e3o\nconvertidos para 1 antes de serem submetidos; e se \"pull-down\",\neles ser\u00e3o convertidos para 0 antes de serem entregues.\nR\u00f3tulo\nO texto para o r\u00f3tulo associado ao componente.\nPosi\u00e7\u00e3o do R\u00f3tulo\nA posi\u00e7\u00e3o do r\u00f3tulo em rela\u00e7\u00e3o ao componente.\nFonte do R\u00f3tulo\nA fonte com a qual o r\u00f3tulo ser\u00e1 mostrado.\nComportamento da ferramenta Testar\nAo clicar em um pino de sa\u00edda n\u00e3o ter\u00e1 efeito algum, embora os atributos do\npino sejam apresentados.\nAo clicar em um pino de entrada ir\u00e1 alternar bit que for clicado. Se for um\npino tri-state, em seguida, o bit correspondente ir\u00e1 alternar entre eles.\nSe, no entanto, o usu\u00e1rio estiver consultando o estado de um subcircuito\nconforme descrito em\n'Depura\u00e7\u00e3o\nde Subcircuitos'\ndo Guia do Usu\u00e1rio, ent\u00e3o o valor do pino\nficar\u00e1 fixo em qualquer valor que o subcircuito que estiver recebendo do\ncircuito que o contiver. O usu\u00e1rio n\u00e3o poder\u00e1 alterar o valor sem quebrar\no v\u00ednculo entre os estados do subcircuito e o do circuito, e o Logisim pedir\u00e1\nao usu\u00e1rio para verificar se a quebra desse v\u00ednculo \u00e9 realmente desejada.\nComportamento da ferramenta Texto\nPermite que o r\u00f3tulo associado ao componente seja editado."
  },
  {
    "id": 73,
    "title": "Probe",
    "url": "/fr/html/libs/wiring/probe.html",
    "text": "Ponta de Prova\nProbe\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.0.3\nApar\u00eancia:\nComportamento\nUma ponta de prova \u00e9 um elemento que simplesmente exibir\u00e1 o valor em um dado\nponto de um circuito. Ela mesma n\u00e3o interage com os outros componentes.\nNa maioria dos aspectos, o componente ponta de prova \u00e9 similar em funcionalidade\nao componente Pino configurado para sa\u00edda.\nA principal diferen\u00e7a \u00e9 que se o circuito for usado como um subcircuito, ent\u00e3o\num pino de sa\u00edda far\u00e1 parte dessa interface, enquanto a ponta de prova n\u00e3o.\nOutra diferen\u00e7a \u00e9 que a ponta de prova n\u00e3o possui um atributo Bits de Dados\npara ser configurado: a largura em bits ser\u00e1 inferida a partir de qualquer\nvalor que seja amostrado por sua entrada. Graficamente, elas s\u00e3o similares, mas\npossuem bordas ligeiramente diferentes: um pino possui a borda em preto, mais\nlarga, enquanto a da ponta de prova ser\u00e1 mais estreita, em cinza.\nPinos\nO componente ponta de prova tem apenas um pino, o qual servir\u00e1 como entrada.\nA largura em bits desse pino \u00e9 adaptativa: a ponta de prova se ajustar\u00e1 a\nentradas de qualquer largura.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nas teclas com setas poder\u00e3o alterar o seu atributo\nDire\u00e7\u00e3o.\nDire\u00e7\u00e3o\nA face do componente onde o seu pino de entrada dever\u00e1 estar.\nR\u00f3tulo\nO texto para o r\u00f3tulo associado ao componente.\nPosi\u00e7\u00e3o do R\u00f3tulo\nA posi\u00e7\u00e3o do r\u00f3tulo em rela\u00e7\u00e3o ao componente.\nFonte do R\u00f3tulo\nA fonte com a qual o r\u00f3tulo ser\u00e1 mostrado.\nBase\nA base do sistema de numera\u00e7\u00e3o (por exemplo, bin\u00e1rio, decimal, ou hexadecimal)\nno qual o valor ser\u00e1 exibido.\nComportamento da ferramenta Testar\nNenhum.\nComportamento da ferramenta Texto\nPermite que o r\u00f3tulo associado ao componente seja editado."
  },
  {
    "id": 74,
    "title": "Tunnel",
    "url": "/fr/html/libs/wiring/tunnel.html",
    "text": "T\u00fanel\nT\u00fanel\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.5.0\nApar\u00eancia:\nComportamento\nUm t\u00fanel funciona como um fio na medida em que vincula pontos,\nmas ao contr\u00e1rio de um fio, a uma conex\u00e3o n\u00e3o ser\u00e1 tra\u00e7ada explicitamente.\nIsso ser\u00e1 \u00fatil quando voc\u00ea precisar conectar pontos distantes no circuito\ne uma rede de fios possa tornar o circuito menos leg\u00edvel.\nA ilustra\u00e7\u00e3o abaixo mostra como isso funciona.\nAqui, todos os tr\u00eas t\u00faneis tem o mesmo r\u00f3tulo,\na,\ne assim todos os tr\u00eas pontos estar\u00e3o conectados ao mesmo ponto.\n(Se um dos t\u00faneis tiver sido rotulado diferentemente, como\nb,\nent\u00e3o ser\u00e1 parte de outro conjunto de t\u00faneis).\nO buffer controlado na parte superior emitir\u00e1 uma sa\u00edda flutuante\numa vez que a sua entrada de mais baixa ordem \u00e9 0.\nIsso normalmente levar\u00e1 a conex\u00e3o que venha do buffer controlado a ser azul;\nmas aqui ela est\u00e1 verde-escura, porque a sa\u00edda flutuante combina-se\natrav\u00e9s do t\u00fanel com o 0 origin\u00e1rio do pino na parte inferior.\nSe a entrada de controle para as altera\u00e7\u00f5es do buffer for igual a 1,\nent\u00e3o, esse buffer controlado ir\u00e1 alimentar o t\u00fanel com 1,\nque combinado com 0 do pino ao fundo ir\u00e1 resultar em um valor de erro;\nportanto, fios vermelhos ser\u00e3o vistos alimentando todos os tr\u00eas t\u00faneis.\nPinos\nUm t\u00fanel tem apenas um pino, cuja largura em bits ser\u00e1 de acordo\ncom o seu atributo Bits de Dados. Esse pino n\u00e3o \u00e9 uma entrada nem uma sa\u00edda\n\u2014 t\u00faneis correspondentes estar\u00e3o conectados de forma transparente.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nAlt-0 at\u00e9 ALT-9 ir\u00e3o alterar o seu atributo\nBits de Dados,\ne as teclas com setas poder\u00e3o alterar o seu atributo\nDire\u00e7\u00e3o.\nDire\u00e7\u00e3o\nA dire\u00e7\u00e3o na qual o t\u00fanel aponta.\nBits de Dados\nO n\u00famero de bits para o t\u00fanel.\nR\u00f3tulo\nO texto do r\u00f3tulo associado ao t\u00fanel.\nEsse t\u00fanel estar\u00e1 conectado a todos os outros com o mesmo r\u00f3tulo.\nFonte do R\u00f3tulo\nA fonte com a qual o r\u00f3tulo ser\u00e1 mostrado.\nComportamento da ferramenta Testar\nNenhum.\nComportamento da ferramenta Texto\nPermite que o r\u00f3tulo associado ao t\u00fanel seja editado."
  },
  {
    "id": 75,
    "title": "Pull Resistor",
    "url": "/fr/html/libs/wiring/pull.html",
    "text": "Resistor para Ajuste\nResistor para Ajuste\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.5.0\nApar\u00eancia:\nPortas convencionais:\nPortas retangulares:\nComportamento\nQuando conectado a um ponto, esse componente ter\u00e1 efeito apenas quando o valor\nnesse ponto for flutuante (Z). Nesse caso, o resistor de ajuste far\u00e1 com que a\nconex\u00e3o concorde com valor especificado pelo atributo Dire\u00e7\u00e3o de Ajuste.\nSe estiver conectado a um valor multibit, ent\u00e3o cada bit que estiver flutuando\nser\u00e1 ajustado para a dire\u00e7\u00e3o especificada, enquanto os bits, que n\u00e3o estiverem\nflutuando, n\u00e3o ser\u00e3o alterados.\nPinos\nO resitor possui apenas um pino, que ser\u00e1 uma sa\u00edda e ter\u00e1 largura em bits\ninferida a partir do componente ao qual estiver conectado.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nas teclas com setas poder\u00e3o alterar o seu atributo\nDire\u00e7\u00e3o.\nDire\u00e7\u00e3o\nA dire\u00e7\u00e3o do pino do componente em rela\u00e7\u00e3o ao seu centro.\nDire\u00e7\u00e3o para Ajuste\nServe para especificar para qual valor um sinal flutuante dever\u00e1 ser ajustado.\nIsso poder\u00e1 ser para 0, 1, ou valor de erro.\nComportamento da ferramenta Testar\nNenhum.\nComportamento da ferramenta Texto\nNenhum."
  },
  {
    "id": 76,
    "title": "Clock",
    "url": "/fr/html/libs/wiring/clock.html",
    "text": "Clock\nClock\nBiblioteca:\nConectar\nIntrodu\u00e7\u00e3o:\n2.0 Beta 13 (na biblioteca Base, transferida para Conectar na vers\u00e3o 2.7.0)\nApar\u00eancia:\nComportamento\nO \"clock\" alternar\u00e1 seu valor \u00e0 sa\u00edda em padr\u00f5es regulares enquantos as\naltern\u00e2ncias (\"ticks\") estiverem habilitadas via\nmenu Simular.\n(As altern\u00e2ncias (\"ticks\") estar\u00e3o desabilitadas por padr\u00e3o.)\nUma altern\u00e2ncia (\"tick\") \u00e9 a unidade de tempo do Logisim; a velocidade com\na qual ocorrer\u00e1 pode ser selecionada pelo submenu Frequ\u00eancia do menu Simular.\nO ciclo de \"clock\" pode ser configurado pelos seus atributos de\nDura\u00e7\u00e3o em N\u00edvel Alto e Dura\u00e7\u00e3o em N\u00edvel Baixo.\nObservar que a simula\u00e7\u00e3o de \"clocks\" no Logisim \u00e9 bem pouco realista:\nem circuitos reais, m\u00faltiplos \"clocks\" poder\u00e3o derivar-se uns dos outros\ne poder\u00e3o nunca estar em sincronia. Entretanto no Logisim, todos os\n\"clocks\" sofrer\u00e3o altern\u00e2ncias com a mesma taxa de varia\u00e7\u00e3o.\nPinos\nUm \"clock\" tem apenas um pino, uma sa\u00edda cuja largura em bits \u00e9 1,\ne cujo valor representar\u00e1 o valor atual do componente. A posi\u00e7\u00e3o desse\npino ser\u00e1 especificada pelo seu atributo Posi\u00e7\u00e3o. O valor do \"clock\"\nir\u00e1 alternar segundo um padr\u00e3o definido quando as altern\u00e2ncias estiverem\nhabilitadas, e isso ocorrer\u00e1 tamb\u00e9m quando for clicado pela\nFerramenta Testar.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nas setas alterar\u00e3o seu atributo de posi\u00e7\u00e3o (Facing).\nPosi\u00e7\u00e3o (Facing)\nO lado do componente onde ficar\u00e1 o pino de sa\u00edda.\nDura\u00e7\u00e3o em N\u00edvel Alto\nO per\u00edodo de tempo em cada ciclo onde o valor da sa\u00edda do \"clock\"\ndever\u00e1 ser igual a 1.\nDura\u00e7\u00e3o em N\u00edvel Baixo\nO per\u00edodo de tempo em cada ciclo onde o valor da sa\u00edda do \"clock\"\ndever\u00e1 ser igual a 0.\nR\u00f3tulo\nO texto a ser associado ao componente.\nPosi\u00e7\u00e3o do R\u00f3tulo\nA posi\u00e7\u00e3o do r\u00f3tulo relativa ao componente.\nFonte do R\u00f3tulo\nA fonte com a qual o r\u00f3tulo dever\u00e1 ser apresentado.\nComportamento da Ferramenta Testar\nAo clicar no componente \"clock\" haver\u00e1 altern\u00e2ncia do seu valor atual\nimediatamente.\nComportamento da Ferramenta Texto\nPermitir\u00e1 que o r\u00f3tulo associado ao componente possa ser editado."
  },
  {
    "id": 77,
    "title": "Constant",
    "url": "/fr/html/libs/wiring/constant.html",
    "text": "Constante\nConstante\nBiblioteca:\nConectar\nIntrodu\u00e7\u00e3o:\n2.0 Beta 1 (na Biblioteca Portas (Gates), transferida para a Conectar na vers\u00e3o in 2.7.0)\nApar\u00eancia:\nComportamento\nEmitir\u00e1 o valor especificado no seu atributo de valor (Value).\nPinos\nH\u00e1 apenas um pino, uma sa\u00edda cuja largura de bits ser\u00e1 especificada\npelo atributo Bits de Dados. A posi\u00e7\u00e3o desse pino ser\u00e1 especificada pelo\natributo Posi\u00e7\u00e3o. O componente far\u00e1 por esse pino a sa\u00edda cont\u00ednua\nde qualquer valor especificado em seu atributo correspondente.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nos d\u00edgitos hexadecimais de '0' a '9' e\nde 'a' at\u00e9 'f' alterar\u00e3o seu atributo de valor (Value),\nAlt-0 at\u00e9 Alt-9 alterar\u00e3o seu atributo Bits de Dados (Data Bits), e\nas setas alterar\u00e3o seu atributo de posi\u00e7\u00e3o (Facing).\nPosi\u00e7\u00e3o (Facing)\nA dire\u00e7\u00e3o preferencial do pino relativa \u00e0 sua localiza\u00e7\u00e3o onde\no valor for desenhado.\nBits de Dados (Data Bits)\nA largura em bits do valor a ser colocado na conex\u00e3o.\nValor\nO valor, em hexadecimal, que ser\u00e1 emitido pelo componente.\nO n\u00famero de bits usados para especificar o valor n\u00e3o poder\u00e1 exceder\na largura em bits do componente.\nComportamento da Ferramentar Testar\nNenhum.\nComportamento da Ferramenta Texto\nNenhum.\nBiblioteca de Refer\u00eancias"
  },
  {
    "id": 78,
    "title": "Power/Ground",
    "url": "/fr/html/libs/wiring/const01.html",
    "text": "Fonte/Terra\nFonte (\"Power\")/Terra(\"Ground\")\nBiblioteca:\nConectar (Wiring)\nIntrodu\u00e7\u00e3o:\n2.7.0\nApar\u00eancia:\nComportamento\nEmitir\u00e1 um \u00fanico valor pela conex\u00e3o.\nPara um elemento do tipo Fonte, indicado por um tri\u00e2ngulo, esse valor\nser\u00e1 igual a 1 (ou, se o atributo de Bits de Dados for maior do que 1,\ntodos os valores iguais a 1).\nPara um elemento do tipo Terra, indicado por uma seta com tr\u00eas linhas\nparalelas de tamanho decrescente, esse valor ser\u00e1 0 (ou, se o atributo\nde Bits de Dados for maior do que 1, todos os valores iguais a zero).\nEssa mesma funcionalidade pode ser alcan\u00e7ada usando o componente\nConstante que \u00e9 mais vers\u00e1til. A \u00fanica raz\u00e3o\nem preferir esses itens \u00e9 que eles se referem a s\u00edmbolos eletr\u00f4nicos\npadronizados.\nPinos\nH\u00e1 apenas um pino, uma sa\u00edda cuja largura de bits ser\u00e1 especificada\npor seu atributo Bits de Dados (Data Bits). O componente emitir\u00e1 sempre o\nmesmo valor por esse pino: para um elemento do tipo Terra, a sa\u00edda ter\u00e1\ntodos os bits iguais a 0; e para um elemento do tipo Fonte, a sa\u00edda ter\u00e1\ntodos os bits iguais a 1.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nAlt-0 at\u00e9 Alt-9 alterar\u00e3o seu atributo Bits de Dados (Data Bits),\ne as setas alterar\u00e3o seu atributo de posi\u00e7\u00e3o (Facing).\nPosi\u00e7\u00e3o (Facing)\nA dire\u00e7\u00e3o preferencial da seta relativa \u00e0 localiza\u00e7\u00e3o do pino.\nBits de Dados (Data Bits)\nA largura de bits do valor a ser colocado na conex\u00e3o.\nValor\nO valor, em hexadecimal, que ser\u00e1 emitido pelo componente.\nO n\u00famero de bits usados para especificar o valor n\u00e3o poder\u00e1 exceder\na largura em bits do componente.\nComportamento da Ferramentar Testar\nNenhum.\nComportamento da Ferramenta Texto\nNenhum.\nBiblioteca de Refer\u00eancias"
  },
  {
    "id": 79,
    "title": "Transistor",
    "url": "/fr/html/libs/wiring/transist.html",
    "text": "Transistor\nTransistor\nBiblioteca:\nConectar (Wiring)\nIntrodu\u00e7\u00e3o:\n2.7.0\nApar\u00eancia:\nComportamento\nUm transistor possui duas entradas, chamadas porta (\"gate\") e\nfonte (\"source\"), e uma sa\u00edda, chamada dreno (\"drain\").\nQuando diagramadas, a entrada fonte e a sa\u00edda dreno ser\u00e3o\nconectadas por uma placa; o Logisim desenhar\u00e1 uma seta para indicar a dire\u00e7\u00e3o\ndo fluxo da entrada para a sa\u00edda. A entrada porta \u00e9 desenhada conectada\n\u00e0 placa paralela para conex\u00e3o entre a fonte e o dreno. O Logisim\noferece suporte a dois tipos de transistores, com comportamentos ligeiramente\ndiferentes como se descrever\u00e1 abaixo: o do tipo-P, marcado por um c\u00edrculo\nconectando a porta \u00e0 placa; e do tipo-N, onde n\u00e3o h\u00e1 esse c\u00edrculo.\nConforme o valor presente na porta, o valor na fonte\npoder\u00e1 ser transmitido para o dreno; ou pode n\u00e3o haver conex\u00e3o entre\neles se o sinal for flutuante. A determina\u00e7\u00e3o se haver\u00e1 transmiss\u00e3o ou desconex\u00e3o\ndepender\u00e1 do tipo de transistor: o do tipo-P (indicado pelo c\u00edrculo) transmitir\u00e1\nse o sinal na porta for 0, enquanto o do tipo-N (sem o c\u00edrculo)\ntransmitir\u00e1 quando o sinal na porta for 1. Esse comportamento encontra-se\nresumido nas seguintes tabelas.\nTipo-P\nporta\n01X/Z\n0\n0ZX\nsource1\n1ZX\nZ\nZZZ\nX\nXZX\nTipo-N\nporta\n01X/Z\n0\nZ0X\nfonte1\nZ1X\nZ\nZZZ\nX\nZXX\nOu de forma resumida:\nTipo-P\nportadreno\n0fonte\n1Z\nX/ZX*\nTipo-N\nportadreno\n0Z\n1fonte\nX/ZX*\n*Se a fonte estiver em Z, o dreno ser\u00e1 Z;\ndo contr\u00e1rio o dreno ser\u00e1 X.\nSe o atributo Bits de Dados for maior do que 1, a porta ainda\nassim ser\u00e1 de um bit apenas, mas esse valor ser\u00e1 aplicado simultaneamente\na cada um dos bits da fonte.\nUm transistor do tipo-N se comportar\u00e1 de forma semelhante a de um\nBuffer Controlado. A principal\ndiferen\u00e7a \u00e9 que um transistor \u00e9 melhor empregado em projetos de circuitos\nmais b\u00e1sicos.\nPinos (supondo o componente voltado para leste, e porta Em cima/\u00c0 esquerda)\nFace oeste (entrada, largura em bits de acordo com o atributo Bits de Dados)\nA entrada fonte do componente ir\u00e1 transmitir para a sa\u00edda, conforme\no sinal na entrada porta.\nFace Norte (entrada, largura em bits igual a 1)\nA entrada porta do componente. Para transistores do tipo-P,\nhaver\u00e1 transmiss\u00e3o se o valor na porta for igual a 0; para transistores\ndo tipo-N, haver\u00e1 transmiss\u00e3o se o valor na porta for igual a 1.\nFace Leste (sa\u00edda, largura em bits de acordo com o atributo Bits de Dados)\nA sa\u00edda do componente, cujo valor depender\u00e1 da entrada fonte\nde acordo com o indicado pela porta, ou ficar\u00e1 flutuante, se o sinal\nfor o contr\u00e1rio do especificado. Se o valor da porta for um valor\nflutuante ou de erro, a sa\u00edda tamb\u00e9m ser\u00e1 um valor de erro.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nAlt-0 at\u00e9 Alt-9 alterar\u00e3o seu atributo Bits de Dados (Data Bits), e\nas setas alterar\u00e3o seu atributo de posi\u00e7\u00e3o (Facing).\nTipo\nDeterminar\u00e1 se o transistor ser\u00e1 do tipo-P ou do tipo-N.\nPosi\u00e7\u00e3o\nA dire\u00e7\u00e3o do componente (sua sa\u00edda em rela\u00e7\u00e3o \u00e0 entrada).\nPosi\u00e7\u00e3o da Porta\nA posi\u00e7\u00e3o da entrada porta.\nBits de Dados\nA largura em bits das entradas e sa\u00edda do componente.\nComportamento da Ferramentar Testar\nNenhum.\nComportamento da Ferramenta Texto\nNenhum.\nBiblioteca de Refer\u00eancias"
  },
  {
    "id": 80,
    "title": "Transmission Gate",
    "url": "/fr/html/libs/wiring/transmis.html",
    "text": "Porta de Transmiss\u00e3o\nPorta de Transmiss\u00e3o\nBiblioteca:\nConectar (Wiring)\nIntrodu\u00e7\u00e3o:\n2.7.0\nApar\u00eancia:\nComportamento\nUma porta de transmiss\u00e3o possui tr\u00eas entradas, chamadas de\nfonte (\"source\"), porta-N (\"n-gate\"),\ne porta-P (\"p-gate\"); e uma sa\u00edda, chamada dreno (\"drain\").\nQuando diagramadas, a entrada fonte e a sa\u00edda dreno ser\u00e3o\nconectadas por duas placas; o Logisim desenhar\u00e1 uma seta para indicar a dire\u00e7\u00e3o\ndo fluxo da entrada para a sa\u00edda. As duas entradas do tipo porta\nser\u00e3o desenhadas conectadas \u00e0s placas paralelas para conex\u00e3o entre\na fonte e o dreno.\nA linha da entrada porta-P ter\u00e1 um c\u00edrculo; enquanto a\nlinha da entrada porta-N, n\u00e3o.\nporta-P\nfonte\ndreno\nporta-N\nA porta de transmiss\u00e3o \u00e9 simplesmente a combina\u00e7\u00e3o de dois transistores\ncomplementares. De fato, o mesmo comportamento poder\u00e1 ser obtido no Logisim\nmediante o uso de apenas um transitor. Contudo, os projetistas certas vezes\npreferem usar esse par de transistores devido \u00e0s quest\u00f5es de natureza el\u00e9trica\ncom rela\u00e7\u00e3o ao consumo de tens\u00e3o, o que \u00e9 mais complexo do que aquilo que o\nLogisim tenta simular.\n\u00c9 esperado que os valores na porta-N e na porta-P sejam\nopostos. Se a porta-P estiver em 0, enquanto a porta-N estiver em 1,\nent\u00e3o valor encontrado \u00e0 fonte ser\u00e1 transmitido ao dreno.\nSe a porta-P estiver em 1, enquanto a porta-N is 0,\nent\u00e3o a conex\u00e3o estar\u00e1 interrompida, e o valor no dreno ser\u00e1 flutuante.\nEm todos os outros casos, o dreno receber\u00e1 o valor de erro na sa\u00edda \u2014\na menos que a fonte seja flutuante, caso em que o dreno\ntamb\u00e9m ser\u00e1 flutuante. Esse comportamento est\u00e1 resumido na tabela abaixo.\nporta-Pporta-Ndreno\n00X*\n01fonte\n10Z\n11X*\nX/ZqualquerX*\nqualquerX/ZX*\n*Se a fonte estiver em Z, o dreno estar\u00e1 em Z;\ndo contr\u00e1rio o dreno ser\u00e1 X.\nSe o atributo Bits de Dados for maior do que 1, a porta ainda\nassim ser\u00e1 de um bit apenas, mas esse valor ser\u00e1 aplicado simultaneamente\na cada um dos bits da fonte.\nPinos (supondo o componente voltado para leste, e porta Em cima/\u00c0 esquerda)\nFace oeste (entrada, largura em bits de acordo com o atributo Bits de Dados)\nA entrada fonte do componente ir\u00e1 transmitir para a sa\u00edda, conforme\nos sinais nas entradas porta-P e porta-N.\nFace Norte (entrada, largura em bits igual a 1)\nA entrada porta-P do componente.\nFace Sul (entrada, largura em bits igual a 1)\nA entrada porta-N do componente.\nFace Leste (sa\u00edda, largura em bits de acordo com o atributo Bits de Dados)\nA sa\u00edda do componente, cujo valor depender\u00e1 da entrada fonte\nse a porta-P estiver em 0, e se a porta-N estiver em 1,\nou ficar\u00e1 flutuante, se os sinais forem 1 na porta-P e 0 na porta-N.\nPara todos os outros valores na porta-P, a sa\u00edda ser\u00e1 um valor de erro.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nAlt-0 at\u00e9 Alt-9 alterar\u00e3o o seu atributo Bits de Dados (Data Bits), e\nas setas alterar\u00e3o o seu atributo de posi\u00e7\u00e3o (Facing).\nPosi\u00e7\u00e3o\nA dire\u00e7\u00e3o do componente (sua sa\u00edda em rela\u00e7\u00e3o \u00e0 entrada).\nPosi\u00e7\u00e3o da Porta\nA posi\u00e7\u00e3o da entrada da porta.\nBits de Dados\nA largura em bits das entradas e sa\u00edda do componente.\nComportamento da Ferramentar Testar\nNenhum.\nComportamento da Ferramenta Texto\nNenhum.\nBiblioteca de Refer\u00eancias"
  },
  {
    "id": 81,
    "title": "Bit Extender",
    "url": "/fr/html/libs/wiring/extender.html",
    "text": "Extensor de Bits\nExtensor de Bits\nBiblioteca:\nBase\nIntrodu\u00e7\u00e3o:\n2.5.0\nApar\u00eancia:\nComportamento\nO extensor de bits transformar\u00e1 um valor em outro de largura diferente.\nSe for para transformar para uma largura menor, os bits de mais baixa ordem\nser\u00e3o simplesmente truncados. Se for para transformar para uma largura maior,\nos bits menos significativos ser\u00e3o os mesmos, e voc\u00ea ter\u00e1 uma escolha para os\nbits de mais alta ordem: eles poder\u00e3o ser todos iguais a 0, ou todos iguais a 1,\no concordarem com a entrada do bit de sinal (o mais significativo), ou\nainda ter esse valor determinado por uma entrada adicional.\nPinos\nNa face oeste (entrada, com largura em bits de acordo com o\natributo Largura da Entrada)\nA entrada multibit cujo valor ser\u00e1 transformado.\nNa face leste (sa\u00edda, com largura em bits de acordo com o\natributo Largura da Sa\u00edda)\nA sa\u00edda calculada.\nNa face norte (entrada, com largura de 1 bit)\nEspecificar\u00e1 como dever\u00e3o ser os bits adicionais \u00e0 sa\u00edda.\nEsse pino estar\u00e1 dispon\u00edvel apenas se o atributo Tipo da Extens\u00e3o for\nEntrada.\nAtributos\nQuando o componente for selecionado ou estiver sendo acrescentado,\nos d\u00edgitos de '0 'a '9' poder\u00e3o alterar o atributo\nLargura da Entrada ,\nAlt-0 at\u00e9 ALT-9 ir\u00e3o alterar o seu atributo\nLargura da Sa\u00edda.\nLargura da Entrada\nA largura em bits da entrada.\nLargura da Sa\u00edda\nA largura em bits da sa\u00edda.\nTipo da Extens\u00e3o\nSe a largura dos bits \u00e0 sa\u00edda puderem exceder aquela \u00e0 entrada,\nesse atributo ir\u00e1 configurar como dever\u00e3o ser os bits adicionais da sa\u00edda.\nSe Zero ou Um, os bits adicionais ser\u00e3o 0 ou 1 respectivamente.\nSe Sinal, os bits adicionais ser\u00e3o tomados de acordo com o bit\nde mais alta ordem da entrada. E se Entrada, o componente usar\u00e1\no valor de uma segunda entrada adicional na face norte.\nComportamento da ferramenta Testar\nNenhum.\nComportamento da ferramenta Texto\nNenhum."
  },
  {
    "id": 82,
    "title": "Gates library",
    "url": "/fr/html/libs/gates/index.html",
    "text": "Gates Library\nGates library\nThe Gates library includes a variety of simple\ncomponents, all of which have a single output whose value is\ndictated entirely by the current inputs.\nNOT Gate\nBuffer\nAND/OR/NAND/NOR Gate\nXOR/XNOR/Odd Parity/Even Parity Gate\nControlled Buffer/Inverter"
  },
  {
    "id": 83,
    "title": "NOT Gate",
    "url": "/fr/html/libs/gates/not.html",
    "text": "NOT Gate\nNOT Gate\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nShaped:\nRectangular:\nBehavior\nThe NOT Gate emits the complement of whatever input\nit receives.\nThe truth table for a NOT gate is the following.\nxout\n01\n10\nIf the input is unspecified (i.e., floating), then the output will also be\nunspecified - unless the \"Gate Output When Undefined\" option is \"Error for\nundefined inputs,\" in which case the output is an error. If the input is an\nerror value, then the output will also be.\nA multi-bit NOT gate will perform the above transformation bitwise on\nits input.\nPins (assuming component faces east)\nWest edge (input, bit width according to Data Bits attribute)\nThe component's input.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, whose value is the complement of the input value.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's input and output.\nGate Size\nDetermines whether to draw a larger or a smaller version of the\ncomponent.\nOutput Value\nIndicates how false and true results should be translated into output values.\nBy default, false is indicated by a low voltage (0) and true by a high voltage (1),\nbut one or the other can be replaced by a high-impedance (floating) value\ninstead. This allows wired-or and wired-and connections, as illustrated in\nthe AND/OR/NAND/NOR Gate documentation.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 84,
    "title": "Buffer",
    "url": "/fr/html/libs/gates/buffer.html",
    "text": "Buffer\nBuffer\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThe buffer simply passes through to its right output whatever input\nit receives on the left side.\nThe truth table for a one-bit buffer is the following.\nxout\n00\n11\nIf the input is unspecified (i.e., floating), then the output will also be\nunspecified - unless the \"Gate Output When Undefined\" option is \"Error for\nundefined inputs,\" in which case the output is an error. If the input is an\nerror value, then the output will also be.\nBuffers are the most useless of the gate components\nprovided in Logisim; its presence in the Gates library is just as much a\nmatter of completeness (a component for each possible\none-input truth table) as it is a matter of providing useful\nfunctionality. Still, it can be occasionally useful to ensure that\nvalues propagate in only one direction along a wire.\nPins (assuming component faces east)\nWest edge (input, bit width according to Data Bits attribute)\nThe input into the component.\nEast edge (output, bit width according to Data Bits attribute)\nThe output, which always matches the input into the left side.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's inputs and outputs.\nOutput Value\nIndicates how false and true results should be translated into output values.\nBy default, false is indicated by a low voltage (0) and true by a high voltage (1),\nbut one or the other can be replaced by a high-impedance (floating) value\ninstead. This allows wired-or and wired-and connections, as illustrated in\nthe AND/OR/NAND/NOR Gate documentation.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 85,
    "title": "AND/OR/NAND/NOR Gate",
    "url": "/fr/html/libs/gates/basic.html",
    "text": "AND/OR/NAND/NOR Gate\nAND/OR/NAND/NOR Gate\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nAND\nOR\nNAND\nNOR\nShaped:\nRectangular:\nDIN 40700:\nBehavior\nThe AND, OR, NAND, and NOT gates each compute the respective\nfunction of the inputs, and emit the result on the output.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value X.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates is the following.\n(The letter X represents the error value,\nand the letter Z represents the floating value.)\nAND\n01X/Z\n0000\n101X\nX/Z0XX\nOR\n01X/Z\n001X\n1111\nX/ZX1X\nNAND\n01X/Z\n0111\n110X\nX/Z1XX\nNOR\n01X/Z\n010X\n1000\nX/ZX0X\nIn short, these components work as expected as long as all inputs\nare either 0 or 1.\nIf an input is neither 0 nor 1 (it is floating or it is the error value)\nthen the component treats it as both 0 and 1:\nIf the output would be the same both ways\n(as when an AND gate has one input that is definitely 0\nand a questionable second input), that will be the output value;\nbut if the output changes depending on whether it is 0 or 1,\nthe output is the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nPins (assuming component faces east)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of OR and NOR\ngates will be curved. Nonetheless, the input pins are in a line. Logisim\nwill draw short stubs illustrating this; and if you overshoot a stub, it\nwill silently assume that you did not mean to overshoot it. In \"printer\nview\", these stubs will not be drawn unless they are connected to\nwires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute. However, if shaped gates are selected,\nthen the gate will be drawn with wings to accommodate additional inputs\nbeyond what the shape naturally accommodates.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nOutput Value\nIndicates how false and true results should be translated into output values.\nBy default, false is indicated by a low voltage (0) and true by a high voltage (1),\nbut one or the other can be replaced by a high-impedance (floating) value\ninstead. This allows wired-or and wired-and connections, as illustrated below:\nAt left, the buffers' Output Value attribute is floating/1 and the resistor pulls to 0,\ngiving wired-or behavior;\nat right, the buffers' Output Value attribute is 0/floating and the resistor pulls to 1,\ngiving wired-and behavior.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nNegate x\nIf yes, the input is negated before it is fed into the gate.\nThe inputs are counted top-down if the facing is east or west,\nand they are counted left-to-right if the facing is north or south.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 86,
    "title": "XOR/XNOR/Even/Odd Gate",
    "url": "/fr/html/libs/gates/xor.html",
    "text": "XOR/XNOR/Odd Parity/Even Parity Gate\nXOR/XNOR/Odd Parity/Even Parity Gate\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1 for XOR/Odd/Even; 2.0 Beta 6 for XNOR\nAppearance:\nXOR\nXNOR\nOddParity\nEvenParity\nShaped:\nRectangular:\nBehavior\nThe XOR, XNOR, Even Parity, and Odd Parity gates each compute\nthe respective function of the inputs, and emit the result on the\noutput.\nBy default, any inputs that are left unconnected are ignored\n\u2014 that's if the input truly has nothing attached to it,\nnot even a wire.\nIn this way, you can insert a 5-input gate but only attach two inputs,\nand it will work as a 2-input gate;\nthis relieves you from having to worry about configuring\nthe number of inputs every time you create a gate.\n(If all inputs are unconnected, the output is the error value X.)\nSome users, though, prefer that Logisim insist that all inputs be connected,\nsince this is what corresponds to real-world gates.\nYou can enable this behavior by going to the Project > Options\u2026 menu item,\nselecting the Simulation tab, and\nselecting Error for undefined inputs for\nGate Output When Undefined.\nThe two-input truth table for the gates is the following.\nxyXOR\nXNOROddEven\n00\n01\n01\n01\n10\n10\n10\n10\n10\n11\n01\n01\nAs you can see, the Odd Parity gate and the XOR gate behave identically\nwith two inputs; similarly, the even parity gate and the XNOR gate\nbehave identically.\nBut if there are more than two specified inputs, the XOR gate will emit\n1 only when there is exactly one 1 input, whereas the Odd Parity gate\nwill emit 1 if there are an odd number of 1 inputs.\nThe XNOR gate will emit 1 only when there is not exactly one 1\ninput, while the Even Parity gate will emit 1 if there are an even\nnumber of 1 inputs. The XOR and XNOR gates include an attribute titled\nMultiple-Input Behavior that allow them to be configured to use the\nOdd Parity and Even Parity behavior.\nIf any of the\ninputs are the error value (e.g., if conflicting values are coming into\nthe same wire) or floating, then the output will be the error value.\nThe multi-bit versions of each gate will perform its one-bit\ntransformation bitwise on its inputs.\nNote: Many authorities contend that the shaped XOR\ngate's behavior should correspond to the odd parity gate, but there is\nnot agreement on this point.\nLogisim's default behavior for XOR gates is based\non the IEEE 91 standard. It is also consistent with the intuitive\nmeaning underlying the term exclusive or: A waiter asking\nwhether you want a side dish of mashed potatoes, carrots, peas, or cole\nslaw will only accept one choice, not three, whatever some authorities\nmay tell you. (I must admit, though, that I have not subjected this\nstatement to a rigorous test.) You can configure the XOR and XNOR gates\nto use parity by changing its Multiple-Input Behavior attribute.\nPins (assuming component faces east)\nWest edge (inputs, bit width according to Data Bits attribute)\nThe inputs into the component. There will be as many of these as\nspecified in the Number of Inputs attribute.\nNote that if you are using shaped gates, the west side of XOR and\nXNOR gates will be curved. Nonetheless, the input pins are in a line.\nLogisim will draw short stubs illustrating this; and if you overshoot a\nstub, it will silently assume that you did not mean to overshoot it. In\n\"printer view\", these stubs will not be drawn unless they are connected\nto wires.\nEast edge (output, bit width according to Data Bits attribute)\nThe gate's output, whose value is computed based on the current\ninputs as described above.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its inputs).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\nDetermines whether to draw a wider or narrower version of the\ncomponent. This does not affect the number of inputs, which is specified\nby the Number of Inputs attribute; however, if the number of inputs exceeds 3 (for a\nnarrow component) or 5 (for a wide component), then the gate will\nbe drawn with \"wings\" to be able to accommodate the number of inputs\nrequested.\nNumber of Inputs\nDetermines how many pins to have for the component on its west\nside.\nOutput Value\nIndicates how false and true results should be translated into output values.\nBy default, false is indicated by a low voltage (0) and true by a high voltage (1),\nbut one or the other can be replaced by a high-impedance (floating) value\ninstead. This allows wired-or and wired-and connections, as illustrated in\nthe AND/OR/NAND/NOR Gate documentation.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nMultiple-Input Behavior (XOR and XNOR only)\nWhen three or more inputs are provided, the XOR/XNOR gate's output will\neither be based on whether exactly one input is 1 (the default) or an odd number\nof inputs are 1.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 87,
    "title": "Controlled Buffer/Inverter",
    "url": "/fr/html/libs/gates/controlled.html",
    "text": "Controlled Buffer/Inverter\nControlled Buffer/Inverter\nLibrary:\nGates\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThe controlled buffer and inverter, often called three-state\nbuffers/inverters, each have a one-bit \"control\"\ninput pin on the south side. The value at this control pin affects how\nthe component behaves:\nWhen the value on this pin is 1,\nthen the component behaves just like the respective component (a buffer or a inverter (NOT\ngate)).\nWhen the value is 0 or unknown (i.e., floating), then the\ncomponent's output is also floating.\nWhen the value is an error value (such as would occur when two\nconflicting values are being fed into the input), then the output is an\nerror value.\nControlled buffers can be useful when you have a wire (often called a\nbus) whose value should match the output of one of several\ncomponents.\nBy placing a controlled buffer between each component\noutput and the bus, you can control whether that component's output is\nfed onto the bus or not.\nPins (assuming component faces east, control line right-handed)\nWest edge (input, bit width matches Data Bits attribute)\nThe component input that will be used to compute the output if the\ncontrol input is 1.\nSouth edge (input, bit width 1)\nThe component's control input.\nEast edge (output, bit width matches Data Bits attribute)\nThe component's output, which will be floating if the control input\nis 0 or floating, the error value if the control input is the error\nvalue, and will be computed based on the west-side input if the control\ninput is 1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's inputs and outputs.\nGate Size\n(Controlled inverter only) Determines whether to draw a larger or a smaller\nversion of the component.\nControl Line Location\nThe location of the control line, imagining we are facing the output\nfrom the input: If the component faces east and is right-handed,\nthe control line is to the south; but if it is left-handed,\nthe control line is to the north.\nLabel\nThe text within the label associated with the gate.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the gate to be edited."
  },
  {
    "id": 88,
    "title": "Plexers library",
    "url": "/fr/html/libs/plexers/index.html",
    "text": "Plexers Library\nPlexers library\nThe Plexers library includes control components.\nLike the components of the Gates library, all are combinational,\nbut their purpose is generally for routing values.\nMultiplexer\nDemultiplexer\nDecoder\nPriority Encoder\nBit Selector"
  },
  {
    "id": 89,
    "title": "Multiplexer",
    "url": "/fr/html/libs/plexers/mux.html",
    "text": "Multiplexer\nMultiplexer\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nCopies an input on the west edge onto the output on\nthe east edge; which of the inputs to copy is specified via the\ncurrent value received through the input on the south edge.\nI find it useful to think of a multiplexer as analogous to a railroad\nswitch, controlled by the select input.\n(Incidentally, some authorities spell this\nmultiplexor,\nbut multiplexer is the predominant\nspelling.)\nPins (assuming component faces east, select is bottom/left)\nWest edge, variable number (inputs, bit width matches Data Bits attribute)\nData values, one of which is to be routed to the output.\nEach input data value is numbered, starting with 0 on the north.\nEast edge (output, bit width matches Data Bits attribute)\nThe output value will match the input values on the west\nedge whose number is the same as the value currently received\nthrough the select input on the south.\nIf the select input contains any unspecified (i.e., floating) bits,\nthen the output is completely floating.\nSouth edge, left side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which input\non the west edge to route to the output on the east edge.\nSouth edge, right side (input, bit width 1)\nEnable: When 0, the multiplexer's output consists of all floating bits,\nregardless of the data and select inputs.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of inputs to the multiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the multiplexer.\nDisabled Output\nSpecifies what each bit of the output should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, the output is effectively disconnected from any other ports.\nInclude Enable?\nThe component has an enable input when this attribute is yes.\nThe attribute is primarily for supporting circuits built using older versions of\nLogisim that did not provide an enable input.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 90,
    "title": "Demultiplexer",
    "url": "/fr/html/libs/plexers/demux.html",
    "text": "Demultiplexer\nDemultiplexer\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nCopies the input on the west edge onto exactly one of the outputs on\nthe east edge; which of these outputs is specified via the\ncurrent value received through the input on the south edge.\nI find it useful to think of a demultiplexer as analogous to a railroad\nswitch, controlled by the select input.\n(Incidentally, some authorities spell this\ndemultiplexor,\nbut demultiplexer is the predominant\nspelling.)\nPins (assuming component faces east, select is bottom/left)\nWest edge (input, bit width matches Data Bits attribute)\nThe value to be routed to one of the outputs on the east edge.\nEast edge, variable number (outputs, bit width matches Data Bits\nattribute)\nThe outputs are numbered starting with 0 on the north. An output\nwill match the west input if its number matches the value currently\nreceived through the select input on the south; otherwise, its value\nwill be either all-zeroes or all-floating, depending on the value of\nthe Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge, left side (input, bit width 1)\nEnable: When 0, all outputs consist of all floating bits,\nregardless of the data and select inputs.\nSouth edge, right side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines to which output on\nthe east edge to route the value received on the west edge.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (specifying which side has the outputs).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the demultiplexer will be\n2selectBits.\nData Bits\nThe bit width of the data being routed through the demultiplexer.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nDisabled Output\nSpecifies what each bit of the outputs should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, the outputs are effectively disconnected from any other ports.\nInclude Enable?\nThe component has an enable input when this attribute is yes.\nThe attribute is primarily for supporting circuits built using older versions of\nLogisim that did not provide an enable input.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 91,
    "title": "Decoder",
    "url": "/fr/html/libs/plexers/decoder.html",
    "text": "Decoder\nDecoder\nLibrary:\nPlexers\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nEmits 1 on exactly one output; which output is 1 depends on the\ncurrent value received through the input on the south edge.\nPins (assuming component faces east, select is bottom/left)\nEast edge, variable number (outputs, bit width 1)\nThe outputs are numbered starting with 0 on the north. Each output\nwill be 1 if its number matches the value currently received through the\nselect input on the south; otherwise, its value will be either zero or\nfloating, depending on the value of the Three-State? attribute.\nIf the select input contains any unspecified bits, then all outputs are\nfloating.\nSouth edge, left side (input, bit width 1)\nEnable: When 0, all outputs consist of all floating bits (or zeros),\nregardless of the select input.\nSouth edge, right side indicated by gray circle (input, bit width matches Select Bits attribute)\nSelect input: The value of this input determines which of the\noutputs is 1.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (specifying which side has the outputs).\nSelect Location\nThe location of the select and enable lines relative to the component.\nSelect Bits\nThe bit width of the component's select input on its south edge.\nThe number of outputs for the decoder will be\n2selectBits.\nThree-state?\nSpecifies whether the unselected outputs should be floating (Yes) or\nzero (No).\nDisabled Output\nSpecifies what each bit of the outputs should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, the outputs are effectively disconnected from any other ports.\nInclude Enable?\nThe component has an enable input when this attribute is yes.\nThe attribute is primarily for supporting circuits built using older versions of\nLogisim that did not provide an enable input.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 92,
    "title": "Priority Encoder",
    "url": "/fr/html/libs/plexers/priencod.html",
    "text": "Priority Encoder\nPriority Encoder\nLibrary:\nPlexers\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThe component has a number of inputs on its west edge, with the first\nlabeled 0 and the other numbered from there. The component determines\nthe indices of the inputs whose values are 1, and it emits the highest index.\nFor example, if inputs 0, 2, 5, and 6 are all 1, then the priority encoder\nemits a value of 110. If no inputs are 1, or if the component is\ndisabled, then the output of the priority encoder is floating.\nThe priority encoder is designed so that a number of encoders can be\ndaisy-chained to accommodate additional inputs. In particular, the component\nincludes an enable input and an enable output. Whenever the enable input is 0,\nthe component is disabled, and the output will be all floating bits. The enable\noutput is 1 whenever the component is enabled and none of the indexed inputs are\n1. Thus, you can take two priority encoders and connect the enable output\nof the first to the enable input of the second: If any of the indexed inputs\nto the first are 1, then the second will be disabled and so its output will be\nall floating. But if none of the first's indexed inputs are 1, then its output\nwill be all-floating bits, and the second\npriority encoder will be enabled and it will identify the highest-priority\ninput with a 1.\nAn additional output of the priority encoder is 1 whenever the priority\nencoder is enabled and finds a 1 on one of the indexed inputs. When\nchaining priority encoders together, this output can be used to identify\nwhich of the encoders was triggered.\nPins (assuming component faces east)\nWest edge, variable number (inputs, bit width 1)\nInput values, indexed from 0 at the top/west end of the edge.\nEast edge, upper pin (output, bit width matches Select Bits attribute)\nOutput: the highest index among those inputs whose value is 1 - or all\nfloating bits if no inputs are 1 or if the component is disabled via the\nEnable In input.\nEast edge, lower pin (output, bit width 1)\nGroup Signal: 1 if the component is enabled and at least one indexed input\nhas a value of 1; otherwise this output is 0.\nSouth edge (input, bit width 1)\nEnable In: if 0, the component is disabled; otherwise the component is\nenabled.\nNorth edge (output, bit width 1)\nEnable Out: 1 if this component is enabled and none of the indexed inputs\nare 1; otherwise the output is 0.\nAttributes\nWhen the component is selected or being added,\nthe digits '1' through '4' alter its Select Bits attribute\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nSelect Bits\nThe bit width of the component's primary output.\nThe number of indexed inputs to the priority encoder will be\n2selectBits.\nDisabled Output\nSpecifies what each bit of the output should be when the component is\ndisabled (i.e., when the enable pin is 0). Options include zero and floating;\nin the latter case, the output is effectively disconnected from any other ports.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone.\n-"
  },
  {
    "id": 93,
    "title": "Bit Selector",
    "url": "/fr/html/libs/plexers/selector.html",
    "text": "Bit Selector\nBit Selector\nLibrary:\nPlexers\nIntroduced:\n2.0.5\nAppearance:\nBehavior\nGiven an input of several bits, this will divide it into several\nequal-sized groups (starting from the lowest-order bit) and output\nthe group selected by the select input.\nFor example, if we have an eight-bit input 01010101, and we are to have\na three-bit output, then group 0 will be the lowest-order three bits 101,\ngroup 1 will be the next three bits, 010, and group 2 will be the next three\nbits 001. (Any bits beyond the top are filled in with 0.) The select\ninput will be a two-bit number that selects which of these three groups\nto output; if the select input is 3, then 000 will be the output.\nPins (assuming component faces east)\nWest edge (input, bit width matches Data Bits attribute)\nData value from which bits should be selected for the output.\nEast edge (output, bit width matches Output Bits attribute)\nA group of bits from the data value, as selected by the select\ninput.\nSouth edge (input, bit width is quotient of Data Bits and Output Bits, rounded up)\nSelect input: Determines which of the bit groups should be routed\nto the output.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Output Bits attribute,\nAlt-0 through Alt-9 alter its Data Bits attribute,\nand the arrow keys alter its Facing attribute.\nFacing\nThe direction of the component (its output relative to its input).\nData Bits\nThe bit width of the component's data input.\nOutput Bits\nThe bit width of the component's output.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 94,
    "title": "Arithmetic library",
    "url": "/fr/html/libs/arith/index.html",
    "text": "Arithmetic Library\nArithmetic library\nThe Arithmetic library includes combinational\ncomponents that perform arithmetic operations on unsigned and\ntwo's-complement values.\nAdder\nSubtractor\nMultiplier\nDivider\nNegator\nComparator\nShifter\nBit Adder\nBit Finder"
  },
  {
    "id": 95,
    "title": "Adder",
    "url": "/fr/html/libs/arith/adder.html",
    "text": "Adder\nAdder\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nThis component adds two values coming in via the west inputs and\noutputs the sum on the east output. The component is designed so that it\ncan be cascaded with other adders to provide add more bits than is\npossible with a single adder: The carry-in input provides a\none-bit value to be added into the sum also (if it is specified), and a\ncarry-out output provides a one-bit overflow value that can be fed to\nanother adder.\nIf either of the addends contains some floating bits or some error\nbits, then the component will perform a partial addition. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nOne of the two values to add.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe other of the two values to add.\nNorth edge, labeled c in (input, bit width 1)\nA carry value to add into the sum. If the value is unknown (i.e.,\nfloating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the sum of the two values\ncoming in the west edge, plus the cin\nbit.\nSouth edge, labeled c out (output, bit width 1)\nThe carry bit computed for the sum. If the values added together as\nunsigned values yield a result that fits into dataBits\nbits, then this bit will be 0; otherwise, it will be 1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be added and of the result.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 96,
    "title": "Subtractor",
    "url": "/fr/html/libs/arith/subtractor.html",
    "text": "Subtractor\nSubtractor\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 11\nAppearance:\nBehavior\nThis component subtracts values coming in via the west inputs\n(the upper minus the lower) and outputs the difference on the east\noutput. The component is designed so that it can be cascaded with other\nsubtractors to provide subtract more bits than is possible with a single\nsubtractor: The borrow-in input provides a one-bit value to be borrowed\nout of the difference (if the borrow-in input is specified), and a\nborrow-out output indicates whether the component needs to borrow an\nupper-order bit to complete the subtraction without underflow (assuming\nunsigned subtraction).\nInternally, the subtractor simply performs a bitwise NOT on the\nsubtrahend, and add this to the minuend along with the NOT of the\nborrow-in input. (The minuend is the first operand (upper\ninput) to the subtraction, and the subtrahend is the second\n(lower input). I happen to like the antiquated terms.)\nIf either of the operands contains some floating bits or some error\nbits, then the component will perform a partial subtraction. That is, it\nwill compute as many low-order bits as possible. But above the floating\nor error bit, the result will have floating or error bits.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe minuend of the subtraction; that is, the number from which to\nsubtract.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe subtrahend of the subtraction; that is, the number to subtract\nfrom the minuend.\nNorth edge, labeled b in (input, bit width 1)\nIf 1, then 1 is borrowed out of the difference. If the value is\nunknown (i.e., floating), then it is assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the difference of the two\nvalues coming in the west edge, minus the\nbin bit.\nSouth edge, labeled b out (output, bit width 1)\nThe borrow bit computed for the difference. If the values subtracted\nas unsigned values yield a negative value, then this bit will be 1;\notherwise, it will be 0.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be subtracted and of the result.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 97,
    "title": "Multiplier",
    "url": "/fr/html/libs/arith/multiplier.html",
    "text": "Multiplier\nMultiplier\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 20\nAppearance:\nBehavior\nThis component multiplies two values coming in via the west inputs\nand outputs the product on the east output. The component is designed so\nthat it can be cascaded with other multipliers to multiply a\nmultiplicand with more bits than is possible with a single multiplier:\nThe carry-in input provides a multi-bit value to be added into the\nproduct (if it is specified), and a carry-out output provides the upper\nhalf of the product result, which can be fed into another\nmultiplier.\nIf the multiplicand, the multiplier, or the carry-in input contain\nsome floating bits or some error bits, then the component will perform a\npartial multiplication. That is, it will compute as many low-order bits\nas possible. But above the floating or error bit, the result will have\nfloating or error bits. Note that if the carry-in input is completely\nfloating, then it will be assumed to be all-zeroes.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe multiplicand (that is, the first of the two numbers to\nmultiply).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe multiplier (that is, the second of the two numbers to multiply).\nNorth edge, labeled c in (input, bit width matches Data Bits attribute)\nA carry value to add into the product. If all bits of the value are\nunknown (i.e., floating), then they are assumed to be 0.\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the product of the two values\ncoming in the west edge, plus the cin\nvalue.\nSouth edge, labeled c out (output, bit width matches Data Bits attribute)\nThe upper dataBits bits of the product.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be multiplied and of the result.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 98,
    "title": "Divider",
    "url": "/fr/html/libs/arith/divider.html",
    "text": "Divider\nDivider\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nThis component divides two values coming in via the west inputs and\noutputs the quotient on the east output. The component is designed so\nthat it can be cascaded with other dividers to provide support a\ndividend with more bits than\nis possible with a single divider: The upper input provides the\nupper dataBits bits of the dividend (if it is specified at\nall), and the rem bits provide the remainder, which can be\nfed as the upper input into another divider.\nIf the divisor is 0, then no division is performed (i.e., the divisor\nis assumed to be 1).\nThe divider essentially performs unsigned division. That is, the\nremainder will always be between 0 and divisor-1. The\nquotient will always be an integer so that\nquotient * divisor + remainder\n= dividend .\nIf, however, the quotient does not fit into\ndataBits bits, then only the lower dataBits bits\nwill be reported. The component does not provide any method for\naccessing the upper dataBits bits.\nIf either of the operands contains some floating bits or some error\nbits, then the component's outputs will be either entirely floating or\nentirely error values.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe lower dataBits bits of the dividend (that is, the\nfirst operand for the division).\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe divisor (that is, the second operand for the division)\nNorth edge, labeled upper (input, bit width matches Data Bits attribute)\nThe upper dataBits bits of the dividend (that is, the\nfirst operand for the division).\nEast edge (output, bit width matches Data Bits attribute)\nThe lower dataBits bits of the quotient, as specified\nabove.\nSouth edge, labeled rem (output, bit width matches Data Bits attribute)\nThe remainder of the division. This value will always be between 0\nand divisor-1.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the values to be divided and of the result.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 99,
    "title": "Negator",
    "url": "/fr/html/libs/arith/negator.html",
    "text": "Negator\nNegator\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nComputes the two's-complement negation of the input.\nThis negation\nis performed by maintaining all the lower-order bits up to the\nlowest-order 1, and complementing all bits above that.\nIf the value to be negated happens to be the least negative value,\nthen its negation (which cannot be represented in two's-complement\nform), is still the least negative value.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe value to negate.\nEast edge, labeled -x (output, bit width matches Data Bits attribute)\nThe negation of the input. If the input happens to be the least\nnegative value representable in dataBits bits, however, then\nthe output matches the input.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's input and output.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 100,
    "title": "Comparator",
    "url": "/fr/html/libs/arith/comparator.html",
    "text": "Comparator\nComparator\nLibrary:\nArithmetic\nIntroduced:\n2.0 Beta 22\nAppearance:\nBehavior\nCompares two values, either as unsigned values or as two's-complement\nvalues, depending on the Numeric Type attribute. Normally, one of the\noutputs will be 1, and the other two outputs will be 0.\nThe comparison is performed starting at the most significant bits in\neach number and descending downward in parallel until a location is\nfound where the two values disagree. If, however, an error value or\na floating value is encountered during this descent, then all outputs\nwill match that error or floating value.\nPins\nWest edge, north end (input, bit width matches Data Bits attribute)\nThe first of the two values to be compared.\nWest edge, south end (input, bit width matches Data Bits attribute)\nThe second of the two values to be compared.\nEast edge, labeled > (output, bit width 1)\n1 if the first input is greater than the second input, 0 if\nthe first input is less than or equal the second input.\nEast edge, labeled = (output, bit width 1)\n1 if the first input equals the second input, 0 if\nthe first input is not equal the second input.\nEast edge, labeled < (output, bit width 1)\n1 if the first input is less than the second input, 0 if\nthe first input is greater than or equal the second input.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the component's inputs.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 101,
    "title": "Shifter",
    "url": "/fr/html/libs/arith/shifter.html",
    "text": "Shifter\nShifter\nLibrary:\nArithmetic\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThis component includes two inputs, data and dist, and\nit has one output, which is the result of shifting data by\ndist places. Both data and output have the same number of\nbits in them. The component supports the following shift types:\nLogical Left: All bits in data are shifted up dist places,\nwith the bottom dist places filled with 0's. For example,\n11001011 logically shifted left twice is 00101100. (The top two ones are lost.)\nLogical Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with 0's. For example,\n11001011 logically shifted right twice is 00110010. (The bottom two ones are\nlost.)\nArithmetic Right: All bits in data are shifted down dist\nplaces, with the upper dist places filled with repetitions of\nwhatever the uppermost bit in data. For example, 11001011\narithmetically shifted right twice is 11110010.\nRotate Left: All bits in data are shifted up dist\nplaces, with the top dist places wrapped around into the bottom.\nFor example, 11001011 rotated left twice is 00101111.\nRotate Right: All bits in data are shifted down dist\nplaces, with the bottom dist places wrapped around into the top.\nFor example, 11001011 rotated right twice is 11110010.\nNote that if dist contains any floating or error inputs, then\nthe output is composed entirely of error values, since there is no way to\nguess how far to shift the input.\nPins\nWest edge, north end (input, bit width matches the Data Bits attribute)\nThe value to be shifted.\nWest edge, south end (input, bit width is computed as below)\nThe number of bits by which to shift the data input.\nThis input should have as many bits as is the minimum number to indicate\nany shift distance from 0 up to one less than Data Bits; that is, it should\nbe the ceiling of the base-2 logarithm of Data Bits. For example, if Data Bits\nwere 8, this input would require 3 bits; but if it were 9, it would require\n4 bits.\nEast edge (output, bit width matches the Data Bits attribute)\nThe result of shifting the input value by the input distance.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the data input and of the output.\nShift Type\nOne of the five possible shift types as outlined above (Logical Left,\nLogical Right, Arithmetic Right, Rotate Left, Rotate Right).\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 102,
    "title": "Bit Adder",
    "url": "/fr/html/libs/arith/bitadder.html",
    "text": "Bit Adder\nBit Adder\nLibrary:\nArithmetic\nIntroduced:\n2.6.0\nAppearance:\nBehavior\nThe component determines how many 1 bits are in its input(s) and emits the\ntotal number of 1 bits on its output. For example, given the 8-bit input 10011101,\nthe output would be 5, since there are five 1-bits in the input\n(the first, the last, and a string of three bits in the middle).\nIf any of the input bits are floating or error values, then the output will\ncontain error bits in the output corresponding to the range of possible outputs\ndepending on whether those floating/error values are counted as zeroes or ones.\nFor instance, if the 14-bit input is 111x10110x1101, then the output must be\nat least 9 (if the x's are interpreted as zeroes)\nand at most 11 (if they are interpreted as ones).\nThus, the output will be 10EE: The upper two bits will be 1 and 0 since all integers\nbetween 9 and 11 have 1 and 0 as their top two bits, but the lower two bits are EE\nsince integers between 9 and 11 vary within these bits.\nPins\nWest edge (inputs, bit width matches Data Bits attribute)\nThe inputs whose 1 bits are to be counted. The number of inputs is based\non the Number of Inputs attribute.\nEast edge (output, bit width computed as described below)\nThe number of input bits which are 1. The bit width of the output is the\nminimum number of bits to store the maximum possible value (which would be\nthe product of the Data Bits attribute and the Number of Inputs attribute).\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Inputs attribute and\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input(s).\nNumber of Inputs\nThe number of input values.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 103,
    "title": "Bit Finder",
    "url": "/fr/html/libs/arith/bitfinder.html",
    "text": "Bit Finder\nBit Finder\nLibrary:\nArithmetic\nIntroduced:\n2.6.1\nAppearance:\nBehavior\nThe component takes a multi-bit input and determines the the index of a bit,\nwhere the index is computed by counting from 0 as the lowest-order bit.\nExactly which index it computes depends on the Type attribute, as illustrated\nby the examples in the below table for the 8-bit sample input 11010100.\nTypeOutput for 11010100\nLowest-order 12\nHighest-order 17\nLowest-order 00\nHighest-order 05\nFor the lowest-order 1, the output is 2 because if you index the bits\nstarting from 0 for the lowest-order bit, the first 1 you will find is\nat index 2. (The bits at indices 0 and 1 are both 0.)\nFor the highest-order 1, the output is 7 because the topmost 1 bit is at index 7\n(again counting from the lowest-order bit as 0).\nThe component's output on the south edge indicates whether the desired bit\nwas found at all. In the above examples involving the input 11010100,\nthe south output is 1 in all cases.\nBut if the input were 00000000 and the component is to find the\nlowest-order 1, then the south output would be 0 \u2014 and the output on the\neast edge would be 0 as well.\nIf while searching for the desired value, a value that is neither 0 or 1 is\nfound (the bit could be floating or an error value),\nthen both outputs will consist entirely of error bits.\nNote that this occurs only if the problematic bit is encountered before finding\nthe desired bit: For the input x1010100, the output would still be 2 if\nthe lowest-order 1 is desired; but we would get error values if the component's\ntype indicates to search for the highest-order 1 or the highest-order 0, since\nthere is an erroneous bit in a higher-order bit than either the highest-order 0\nor the highest-order 1.\nPins\nWest edge (input, bit width matches Data Bits attribute)\nThe multibit input that is to be searched for the desired bit.\nEast edge (output, bit width computed as described below)\nThe index of the desired bit, counting from 0 for the lowest-order bit.\nThe bit width is the\nminimum number of bits to store the maximum possible index, which is one\nless than the value of the Data Bits attribute.\nSouth edge (output, bit width 1)\n1 if the desired bit is found, 0 if all input bits are the inverse of the\ndesired bit, and the error value if a non-0, non-1 value is found before the\ndesired bit.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the input.\nType\nIndicates which bit to search for \u2014 the lowest-order 0,\nthe highest-order 0, the lowest-order 1, or the highest-order 1.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 104,
    "title": "Memory library",
    "url": "/fr/html/libs/mem/index.html",
    "text": "Memory Library\nMemory library\nThe Memory library includes components that remember information.\nD/T/J-K/S-R Flip-Flop\nRegister\nCounter\nShift Register\nRandom\nRAM\nROM"
  },
  {
    "id": 105,
    "title": "D/T/J-K/S-R Flip-Flop",
    "url": "/fr/html/libs/mem/flipflops.html",
    "text": "D/T/J-K/S-R Flip-Flop\nD/T/J-K/S-R Flip-Flop\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nEach flip-flop stores a single bit of data, which is emitted through\nthe Q output on the east side. Normally, the value can be\ncontrolled via the inputs to the west side. In particular, the value\nchanges when the clock input, marked by a triangle on\neach flip-flop, rises from 0 to 1 (or otherwise as configured); on this rising\nedge, the value changes according to the table below.\nD Flip-Flop\nT Flip-Flop\nJ-K Flip-Flop\nS-R Flip-Flop\nDQ\n00\n11\nTQ\n0Q\n1Q'\nJKQ\n00\nQ\n01\n0\n10\n1\n11\nQ'\nSRQ\n00\nQ\n01\n0\n10\n1\n11\n??\nAnother way of describing the different behavior of the flip-flops\nis in English text.\nD Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop becomes the value of the D\ninput (Data) at that instant.\nT Flip-Flop: When the clock triggers, the\nvalue remembered by the flip-flop either toggles or remains the same\ndepending on whether the T\ninput (Toggle) is 1 or 0.\nJ-K Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\ntoggles if the J and K inputs are both 1\nand the value remains the same if both are 0;\nif they are different, then the value becomes 1 if the J\n(Jump) input is 1 and 0 if the K (Kill)\ninput is 1.\nS-R Flip-Flop: When the clock triggers,\nthe value remembered by the flip-flop\nremains unchanged if R and S are both 0,\nbecomes 0 if the R input (Reset) is 1, and\nbecomes 1 if the S input (Set) is 1.\nThe behavior in unspecified if both inputs are 1.\n(In Logisim, the value in the flip-flop remains unchanged.)\nBy default, the clock triggers on a rising edge \u2014 that is, when the\nclock input changes from 0 to 1. However, the\nTrigger attribute allows this to change to a falling edge (when the clock\ninput changes from 1 to 0), a high level (for the duration that the clock input\nis 1), or a low level (for the duration that the clock input is 0). The\nlevel-trigger options are unavailable for the T and J-K flip-flops, because\na flip-flop behaves unpredictably when told to toggle for an indeterminate\namount of time.\nPins\nWest edge, marked by triangle (input, bit width 1)\nClock input: At the instant that this input value switches from 0 to\n1 (the rising edge), the value will be updated according to the other\ninputs on the west edge.\nAs long as this remains 0 or 1, the other\ninputs on the west edge have no effect.\nWest edge, other labeled pin(s) (input(s), bit width 1)\nThese inputs control how the flip-flop's value changes during the\nrising edge of the clock. Their exact behavior depends on the\nflip-flop; the above tables summarize their behavior.\nEast edge, labeled Q, north end (output, bit width 1)\nOutputs the value currently stored by the flip-flop.\nEast edge, south end (output, bit width 1)\nOutputs the complement of the value currently stored by the\nflip-flop.\nSouth edge, east end (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the flip-flop's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nSouth edge, center end (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current bit\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, west end (input, bit width 1)\nAsynchronous set: When 1 or undefined, this input has no effect.\nWhen 1, the flip-flop's value is pinned to 1. This occurs asynchronously\n- that is, without regard to the current clock input value. As long as\nthis input is 1, the other inputs have no effect, except for the\nasynchronous reset input, which has priority.\nAttributes\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the flip-flop should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the flip-flop should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0. Note that the latter two options\nare unavailable for T and J-K flip-flops.\nLabel\nThe text within the label associated with the flip-flop.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nClicking a flip-flop using the Poke Tool toggles the bit stored in\nthe flip-flop, unless the asynchronous set/reset inputs currently\npin the flip-flop's value.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 106,
    "title": "Register",
    "url": "/fr/html/libs/mem/register.html",
    "text": "Register\nRegister\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nA register stores a single multi-bit value, which is displayed in\nhexadecimal within its rectangle, and is emitted on its\nQ output. When the clock input\n(indicated by a triangle on the south edge) indicates so,\nthe value stored in the register changes to the value of the\nD input at that instant. Exactly when the clock input indicates\nfor this to happen is configured via the Trigger attribute.\nThe reset input resets the register's value to 0 (all\nzeroes) asynchronously; that is, as long as reset\nis 1, the value is pinned to 0, regardless of the clock input.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the register.\nWest edge, labeled D (input, bit width matches Data Bits attribute)\nData input: At the instant that the clock value rises from 0 to 1,\nthe register's value changes to the value of the D input at\nthat instant.\nWest edge, labeled en (input, bit width 1)\nEnable: When this is 0, clock triggers are ignored. The current value\ncontinues to appear on the output. The clock triggers are enabled when this\ninput is 1 or undefined.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock input: At the instant that this input value rises from 0 to\n1 (the rising edge), the register's value will be updated to the value\nof the D input.\nSouth edge, labeled 0 (input, bit width 1)\nAsynchronous reset: When 0 or undefined, this input has no effect.\nAs long as it is 1, the register's value is pinned to 0. This occurs\nasynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in the register.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0. The high level value\nindicates that the register should update continuously whenever the clock\ninput is 1. And the low level value indicates that it should update\ncontinuously when the clock input is 0.\nLabel\nThe text within the label associated with the register.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nClicking the register brings keyboard focus to the register\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the register.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 107,
    "title": "Counter",
    "url": "/fr/html/libs/mem/counter.html",
    "text": "Counter\nCounter\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThe counter holds a single value, whose value is emitted on the output\nQ. Each time the clock input (diagrammed with a triangle on the\ncomponent's south edge) triggers according to its Trigger attribute,\nthe value in the counter may update based on\nthe two inputs on the component's west edge: The upper input is called\nload and the lower is called count, and they are\ninterpreted as follows.\nloadcounttrigger action\n0 or z0\nThe counter remains unchanged.\n0 or z1 or z\nThe counter increments.\n10\nThe counter loads the value found at the\nD input.\n11 or z\nThe counter decrements.\nThe range of counting can be configured using the Maximum\nValue attribute. When the counter reaches this value, the next\nincrement wraps the counter back to 0; and if it is at 0,\nthen a decrement will wrap the counter around back to its maximum value.\nIn addition to the output Q, the component also includes a\nsingle-bit output carry. This is 1 whenever the counter is at its\nmaximum and the load and count inputs indicate that the\ncomponent should increment on the next step - or when the counter is at 0\nand the load and count inputs indicate to decrement at\nthe next step.\nThe clear input resets the counter's value to 0 (all\nzeroes) asynchronously; that is, as long as the clr input\nis 1, the value is pinned to 0, regardless of the clock input.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the counter.\nEast edge, lower pin (output, bit width 1)\nCarry: When load and count indicate to increment,\nthis output is 1 whenever the counter is at its maximum. When load\nand count indicate to decrement, this output is 1 whenever the\ncounter is at 0. At all other times, this output is 0.\nWest edge, top pin (input, bit width 1)\nLoad: When this is 1 while the count input is 0, the counter\nwill load the value found at the data input at the next clock\ntrigger - or, if the count input happens to be 1, the counter's\nvalue will decrement.\nWest edge, middle pin labeled D\n(input, bit with matches Data Bits attribute)\nData: When the clock triggers while load is 1\nand count is 0, the counter's value changes to the value found at\nthis input.\nWest edge, lower pin labeled ct (input, bit width 1)\nCount: When this is 1 or unconnected, the value in the counter increments\nwhenever the clock input is triggered - or it decrements if the load\ninput happens to also be 1.\nSouth edge, indicated with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the counter updates as indicated by the load and\ncount inputs.\nSouth edge, labeled 0 (input, bit width 1)\nClear: When 0 or undefined, this input has no effect.\nAs long as it is 1, the counter's value is asynchronously pinned to 0. This\noccurs asynchronously - that is, without regard to the current clock input\nvalue. As long as this is 1, the other inputs have no effect.\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nMaximum Value\nThe maximum value, at which point the counter will set its carry output.\nAction On Overflow\nThe behavior when the counter attempts to increment beyond the maximum value\nor decrement beyond 0. Four possible actions are supported:\nWrap around\nThe next value is 0 (if incrementing - the maximum value if decrementing)\nStay at value\nThe counter's value remains at the maximum (or 0 if decrementing)\nContinue counting\nThe counter continues incrementing/decrementing, keeping the number of bits\nas provided by the Data Bits attribute\nLoad next value\nThe next value is loaded from the D input.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the counter should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nClicking the counter brings keyboard focus to the component\n(indicated by a red rectangle), and typing hexadecimal digits will\nchange the value stored in the counter.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 108,
    "title": "Shift Register",
    "url": "/fr/html/libs/mem/shiftreg.html",
    "text": "Shift Register\nShift Register\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThis register consists of several stages, where each clock may lead to\neach stage receiving the value in the previous stage, while a new value is\nloaded into the first stage. The component optionally also supports parallel\nloads and stores to all stages' values.\nThe clear input resets all stages to 0 (all\nzeroes) asynchronously; that is, as long as the clear input\nis 1, all values are pinned to 0, regardless of the clock input.\nPins\n* An asterisk marks pins that exist only when the Parallel Load attribute\nis enabled.\nWest edge, top pin (input, bit width 1)\nShift: When 1 or disconnected, all stages advance with the clock trigger;\nbut if it is 0, no advance takes place. This input is ignored if the Load\ninput is 1.\nWest edge, middle pin (input, bit width matches Data Bits attribute)\nData: When advancing the stages, the value found at this input is loaded\ninto the first stage.\nWest edge, bottom pin marked with triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the\nTrigger attribute, the component may advance the stages or load new values.\n*North edge, left pin (input, bit width 1)\nLoad: When this 1, the values found on the other north-edge pins are\nloaded into all stages at the next clock trigger. When 0 or disconnected, no\nload occurs.\n*North edge, other pins (input, bit width matches Data Bits attribute)\nData: These values are loaded into all stages when the clock is triggered\nwhile the load input is 1. The leftmost input corresponds to the\nyoungest stage.\nSouth edge, left pin (input, bit width 1)\nClear: When this is 1, all stages are asynchronously reset to 0, and all\nother inputs are ignored.\n*South edge, other pins (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in each stage, with the youngest stage\nreflected on the leftmost of the pins (next to the clear input).\nEast edge (output, bit width matches Data Bits attribute)\nOutput: Emits the value stored in the final (oldest) stage.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Number of Stages attribute\nand Alt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value stored in each stage.\nNumber of Stages\nThe number of stages included in the component.\nParallel Load\nIf yes, then the component includes inputs and outputs facilitating\nparallel access to all the stages' values.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the register should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nIf the Parallel Load attribute is no, or if the Data Bits attribute is more\nthan 4, then poking the register has no effect. Otherwise, clicking the\ncomponent will bring keyboard focus to the clicked stage\n(indicated by a red rectangle), and typing a hexadecimal digit will\nchange the value stored in that stage.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 109,
    "title": "Random",
    "url": "/fr/html/libs/mem/random.html",
    "text": "Random\nRandom\nLibrary:\nMemory\nIntroduced:\n2.3.0\nAppearance:\nBehavior\nThis component iterates through a pseudorandom sequence of numbers, which\nsteps forward to the following number in the sequence each time the clock is\ntriggered while the component is enabled. Technically speaking, the algorithm\nused to compute the pseudorandom sequence is a linear\ncongruential generator: Starting from a seed\nr0, the following number\nr1 is the number\nr1 =\n(25,214,903,917 r0 + 11)\nmod 248\nThe next value r2\nis computed from r1\nusing the same computation, and so forth. This sequence is of 48-bit numbers;\nthe value seen from the component is the low-order bits as configured\nby its Data Bits attribute, after first throwing out the lower 12 bits of\nthe current seed.\nBesides the clock input, the component also includes an enable\ninput, which leads the clock input to be ignored when enable is 0,\nand the reset input, which resets the component's value asynchronously\nto the initial seed r0.\nThe initial seed is user-configurable. If it is configured at 0 (which is\nthe default), then the seed is based on the current time; when instructed\nto reset through the reset input, the component computes a new\nseed based on the new current time.\nPins\nEast edge, labeled Q (output, bit width matches Data Bits attribute)\nOutputs the value currently stored by the component.\nWest edge, top pin, labeled with a triangle (input, bit width 1)\nClock: At the instant that this is triggered as specified by the Trigger\nattribute, the component steps to the following number in its sequence.\nWest edge, bottom pin (input, bit width 1)\nEnable: The component is enabled when this input is disconnected or 1;\nbut if it is 0, then the clock input is ignored.\nSouth edge (input, bit width 1)\nReset: When this is 1, the pseudorandom sequence asynchronously resets to\nthe initial seed. (If seed is 0, this new seed should be different from the\ninitial seed used previously.)\nAttributes\nWhen the component is selected or being added,\nAlt-0 through Alt-9 alter its Data Bits attribute.\nData Bits\nThe bit width of the value emitted by the component.\nSeed\nThe starting value used for the pseudorandom sequence. If this is 0\n(the default), then the starting value is based on the time that the random\nsequence began.\nTrigger\nConfigures how the clock input is interpreted. The value rising edge\nindicates that the component should update its value at the instant when the\nclock rises from 0 to 1. The falling edge value indicates that it should\nupdate at the instant the clock falls from 1 to 0.\nLabel\nThe text within the label associated with the component.\nLabel Font\nThe font with which to render the label.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 110,
    "title": "RAM",
    "url": "/fr/html/libs/mem/ram.html",
    "text": "RAM\nRAM\nLibrary:\nMemory\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThe RAM component, easily the most complex component in Logisim's\nbuilt-in libraries, stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). The circuit can load and\nstore values in RAM. Also, the user can modify individual values\ninteractively via the Poke Tool, or the user can modify the entire\ncontents via the Menu Tool.\nCurrent values are displayed in the component. Addresses displayed\nare listed in gray to the left of the display area. Inside, each value\nis listed using hexadecimal. The value at the currently selected address\nwill be displayed in inverse text (white on black).\nThe RAM component supports three different interfaces, depending on the\nData Interface attribute.\nOne synchronous load/store port (default)\nThe component includes a single port on its east side that serves for both\nloading and storing data. Which it performs depends on the input labeled\nld: 1 (or floating) indicates to load the data at the address\ndesignated on the component's west side, and 0 indicates to store the data\ngiven on the port. To transmit data into and out of the component, you will\nneed to use a Controlled Buffer component, as illustrated below.\nOne asynchronous load/store port\nThis is the same as above, except that there is no clock. The value\nfound on the data bus is stored into memory whenever the ld input is\n0. If, while the ld input is 0, the address or data changes, then an\nadditional store occurs. This option is meant to more closely approximate the\ninterface of many available random-access memories.\nSeparate load and store ports\nTwo data ports are provided - one on the west side for storing data,\nand another on the east side for loading data. This option removes the\nnecessity of dealing with the Controlled Buffer and so it is easier to\nuse.\nPins\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values in memory is currently being accessed by the\ncircuit.\nD on west edge (input, bit width matches Data Bit Width attribute)\nThis input is present only if \"separate load and store ports\" is selected\nfor the Data Interface attribute. When a store is requested (via the clock changing\nfrom 0 to 1 while sel and str are both 1 or floating), the\nvalue found at this port is stored into memory at the currently selected address.\nD on east edge (input/output or output, bit width matches Data Bit Width attribute)\nIf sel and ld are 1 or floating, then the RAM\ncomponent emits the value found at the currently selected address on this port.\nIf there is a single load/store port, the value read from this port is\nstored whenever a store is requested.\nstr on south edge (input, bit width 1)\nStore: This input is present only if \"separate load and store ports\" is selected\nfor the Data Interface attribute. When it is 1 or floating, a clock pulse will result\nin storing the data found on the west edge into memory (provided the\nsel input is also 1 or floating).\nsel on south edge (input, bit width 1)\nChip select: This input enables or disables the entire RAM module, based on\nwhether the value is 1/floating or 0. The input is meant primarily for\nsituations where you have multiple RAM units, only one of which would be\nenabled at any time.\ntriangle on south edge (input, bit width 1)\nClock input: This is absent when the Data Interface attribute's value is \"One\nasynchronous load/store port.\" In other circumstances, when ld is 0,\nand this input rises from 0 to 1 (and sel is 1/undefined and\nclr is 0), then the value at the currently selected address\nchanges to whatever value is\nat the D pin. As long as the clock input remains 0 or 1,\nthough, the D value will not be stored into memory.\nld on south edge (input, bit width 1)\nLoad: Selects whether the RAM should emit (on D)\nthe value at the current address (A). This output behavior\nis enabled if out is 1 or undefined; if out\nis 0, then no value is pushed onto D - but if there is a combined\nload/store port, stores will be enabled.\nclr on south edge (input, bit width 1)\nClear: When this is 1, all values\nin memory are pinned to 0, no matter what the other inputs are.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nRAM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nData Interface\nConfigures which of the three interfaces are used for communicating data\ninto and out of the component.\nPoke Tool Behavior\nSee poking memory\nin the User's Guide.\nText Tool Behavior\nNone.\nMenu Tool Behavior\nSee pop-up menus and files\nin the User's Guide."
  },
  {
    "id": 111,
    "title": "ROM",
    "url": "/fr/html/libs/mem/rom.html",
    "text": "ROM\nROM\nLibrary:\nMemory\nIntroduced:\n2.1.0\nAppearance:\nBehavior\nThe ROM component stores up to 16,777,216 values (specified in the Address\nBit Width attribute), each of which can include up to to 32 bits\n(specified in the Data Bit Width attribute). A circuit can access\nthe current values in ROM, but it cannot change them. The user can modify individual values\ninteractively via the Poke Tool, or the user can modify the entire\ncontents via the Menu Tool.\nUnlike the RAM component, the ROM component's current contents are\nstored as an attribute of the component. Thus, if a circuit containing\na ROM component is used twice, then both ROM components will hold the\nsame values. Also because of this behavior, the current ROM contents are\nstored in files created by Logisim.\nCurrent values are displayed in the component. Addresses displayed\nare listed in gray to the left of the display area. Inside, each value\nis listed using hexadecimal. The value at the currently selected address\nwill be displayed in inverse text (white on black).\nPins\nA on west edge (input, bit width matches Address Bit Width attribute)\nSelects which of the values are currently being accessed by the\ncircuit.\nD on east edge (input/output, bit width matches Data Bit Width attribute)\nOutputs the value at the currently selected address at the\nD pin if sel is 1 or floating. If sel\nis 0, then D will be floating.\nsel on south edge (input, bit width 1)\nIf you have just one ROM module, ignore this input.\nIf you have multiple ROM modules in parallel, you can use this input\nto enable or disable the entire ROM module, based on whether the value is\n1 or 0. In other words, when this is 0, no value is emitted on\nthe D output.\nAttributes\nWhen the component is selected or being added,\nthe digits '0' through '9' alter its Address Bit Width attribute\nand Alt-0 through Alt-9 alter its Data Bit Width attribute.\nAddress Bit Width\nThe bit width of the address bits. The number of values stored in\nROM is 2addrBitWidth.\nData Bit Width\nThe bit width of each individual value in memory.\nContents\nStores the contents of memory.\nPoke Tool Behavior\nSee poking memory\nin the User's Guide.\nText Tool Behavior\nNone.\nMenu Tool Behavior\nSee pop-up menus and files\nin the User's Guide."
  },
  {
    "id": 112,
    "title": "Input/Output library",
    "url": "/fr/html/libs/io/index.html",
    "text": "Input/Output Library\nInput/Output library\nThe Input/Output library includes components that are meant to\ncorrespond to typical components found in electronics for interfacing\nwith a user.\nButton\nJoystick\nKeyboard\nLED\n7-Segment Display\nHex Digit Display\nLED Matrix\nTTY"
  },
  {
    "id": 113,
    "title": "Button",
    "url": "/fr/html/libs/io/button.html",
    "text": "Button\nButton\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nOutputs 0 normally; but when the user is pressing the\nthe button using the Poke Tool, the output is 1.\nPins\nA button has only one pin, a 1-bit output, which is 0 except when the\nuser is pressing the button using the Poke Tool, when it is 1.\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe location of the output pin relative to the component.\nColor\nThe color with which to display the button.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nPoke Tool Behavior\nWhen the mouse button is pressed, the component's output will be 1.\nUpon releasing the mouse button, the output reverts back to 0.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 114,
    "title": "Joystick",
    "url": "/fr/html/libs/io/joystick.html",
    "text": "Joystick\nJoystick\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThe user can drag the red knob within the rounded-square area, and the outputs\nupdate to indicate the knob's current x- and\ny-coordinates. This is meant to emulate the joysticks known from\nthe days of classical arcade games.\nPins\nWest edge, north pin (output, bit width matches Bit Width attribute)\nIndicates knob's x-coordinate, to be interpreted as an unsigned\ninteger whose value will never be 0. Thus, a value of 1 represents the far left,\nand the maximum value for the bit width indicates the far right. When the knob\nis at rest (in the center), the value has the bit pattern 10...00.\nWest edge, south pin (output, bit width matches Bit Width attribute)\nIndicates knob's y-coordinate, whose value ranges as with the\nx-coordinate pin. When the knob is pulled to the top, this output's\nvalue is 1, and when the knob is pulled to the bottom, the output is the\nmaximum value for the bit width selected.\nAttributes\nWhen the component is selected or being added,\nAlt-2 through Alt-5 alter its Bit Width attribute.\nBit Width\nThe number of bits used to indicate each of the knob's coordinates.\nColor\nThe knob's color as it is drawn on the screen.\nPoke Tool Behavior\nPressing the mouse button while within the joystick area moves the knob to\nthat location and updates the outputs. Dragging the mouse continues to move\nthe knob and update the outputs, keeping the knob within the joystick's area.\nReleasing the mouse button reverts the knob back to its rest position.\nText Tool Behavior\nNone."
  },
  {
    "id": 115,
    "title": "Keyboard",
    "url": "/fr/html/libs/io/keyboard.html",
    "text": "Keyboard\nKeyboard\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThis component allows the circuit to read keys typed from the keyboard -\nas long as the keys are representable in the 7-bit ASCII code.\nAfter clicking the component using the poke tool, the user can type characters,\nwhich accumulate in a buffer. At all times, the ASCII value for the leftmost\ncharacter in the buffer is sent out the rightmost output. When the clock input\nis triggered, the leftmost character disappears from the buffer and the new\nleftmost character is sent on the rightmost output.\nThe supported characters for the buffer include all the printable ASCII\ncharacters, as well as space, newline, backspace, and control-L. In addition,\nthe left-arrow and right-arrow keys move the cursor within the buffer, and the\ndelete key deletes the character to the right of the cursor (if any).\nThe component is asynchronous in the sense that when the buffer is empty and\nthe user types a character, that character is sent immediately as an output,\nwithout any wait for a clock pulse.\nPins\nWest edge, marked by a triangle (input, bit width 1)\nClock - when triggered while the read-enable pin isn't 0, the leftmost\ncharacter from the buffer is deleted,\nand the outputs are updated to reflect the buffer's new status.\nSouth edge, leftmost pin (input, bit width 1)\nRead Enable - when 1 (or floating or error), a clock edge will consume\nthe leftmost character from the buffer. The clock input is ignored when\nRead Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the buffer is emptied and does not accept further\ncharacters.\nSouth edge, second pin from right (output, bit width 1)\nAvailable - this is 1 when the buffer contains at least one character\nand 0 when the buffer is empty.\nSouth edge, rightmost pin (output, bit width 7)\nData - the 7-bit ASCII code for the leftmost character in the buffer,\nor 0 if the buffer is empty.\nAttributes\nBuffer Length\nThe number of characters that the buffer can hold at once.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the leftmost character is consumed (when enabled by the Read\nEnable input). If it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nPoke Tool Behavior\nPressing the mouse button into the component gives keyboard focus to the\ncomponent, and a vertical-bar cursor will be displayed.\nEach character typed will then be inserted into the buffer, as long as the\nbuffer hasn't reached its capacity and the character is one of those that the\ncomponent supports: the printable characters within the 7-bit ASCII code, as\nwell as space, backspace, newline, and control-L. Additionally, the user may\ntype the left-arrow and right-arrow keys to change the location of the cursor\nwithin the buffer, and the user may type the delete key to delete the buffer\ncharacter (if any) just to the right of the cursor.\nText Tool Behavior\nNone."
  },
  {
    "id": 116,
    "title": "LED",
    "url": "/fr/html/libs/io/led.html",
    "text": "LED\nLED\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nDisplays the value of its input by coloring the LED (as specified\nby its Color attribute) or not depending on whether the input is 1 or 0.\n(The LED component is basically redundant with an output pin, except\nfor a somewhat different appearance. Some users, though, thought it would\nbe nice to include.)\nPins\nA LED has only one pin, a 1-bit input which is used to determine whether\nto display the LED colored (when the input is 1) or darkened (when the input\nis anything else).\nAttributes\nWhen the component is selected or being added,\nthe arrow keys alter its Facing attribute.\nFacing\nThe location of the input pin relative to the component.\nColor\nThe color to display when the input value is 1.\nActive On High?\nIf yes, then the LED is colored when the input is 1.\nIf no, it is colored when the input is 0.\nLabel\nThe text within the label associated with the component.\nLabel Location\nThe location of the label relative to the component.\nLabel Font\nThe font with which to render the label.\nLabel Color\nThe color with which to draw the label.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the label associated with the component to be edited."
  },
  {
    "id": 117,
    "title": "7-Segment Display",
    "url": "/fr/html/libs/io/7seg.html",
    "text": "7-Segment Display\n7-Segment Display\nLibrary:\nInput/Output\nIntroduced:\n2.1.3\nAppearance:\nBehavior\nDisplays the values of its eight one-bit inputs. Segments are either\ncolored or light gray depending on the inputs. The correspondence is as\nfollows.\n(Manufacturers vary as to how they map inputs to segments; the\ncorrespondence used here is based on Texas Instruments'\nTIL321.)\nPins\nNorth edge, first from left (input, bit width 1)\nControls the middle horizontal segment.\nNorth edge, second from left (input, bit width 1)\nControls the upper vertical segment on the left side.\nNorth edge, third from left (input, bit width 1)\nControls the upper horizontal segment.\nNorth edge, fourth from left (input, bit width 1)\nControls the upper vertical segment on the right side.\nSouth edge, first from left (input, bit width 1)\nControls the lower vertical segment on the left side.\nSouth edge, second from left (input, bit width 1)\nControls the bottom horizontal segment.\nSouth edge, third from left (input, bit width 1)\nControls the lower vertical segment on the right side.\nSouth edge, fourth from left (input, bit width 1)\nControls the decimal point.\nAttributes\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nActive On High?\nIf yes, then the segments light when the corresponding input is 1.\nIf no, they light when the corresponding input is 0.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 118,
    "title": "Hex Digit Display",
    "url": "/fr/html/libs/io/hexdig.html",
    "text": "Hex Digit Display\nHex Digit Display\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nUsing a seven-segment display, shows the hexadecimal digit corresponding to\nthe four-bit input. If any of the inputs are not 0/1 (either floating or error),\nthen the display shows a dash ('-'). A separate one-bit input controls the\ndisplay of the decimal point.\nPins\nSouth edge, first from left (input, bit width 4)\nThis input is interpreted as an unsigned four-bit number, and the\ncorresponding hexadecimal digit is displayed. If any of the bits are floating\nor error, then a dash ('-') is displayed.\nSouth edge, second from left (input, bit width 1)\nControls the decimal point. If this is left unconnected, the decimal point\nremains off.\nAttributes\nOn Color\nThe color with which to draw the display segments and decimal point when\nthey are on.\nOff Color\nThe color with which to draw the display segments and decimal point when\nthey are off.\nBackground\nThe color with which to draw the display's background (transparent by default).\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 119,
    "title": "LED Matrix",
    "url": "/fr/html/libs/io/dotmat.html",
    "text": "LED Matrix\nLED Matrix\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nDisplays a small grid of pixels, whose values are determined by the current\ninputs. The grid can have up to 32 rows and 32 columns.\nPins\nThe interface to the component varies depending on the value of the\nInput Format attribute. It has three possible values.\nColumns\nThe inputs are lined along the component's south edge, with one\nmultibit input for each column of the matrix. Each input has as many bits\nas there are rows in the matrix, with the low-order bit corresponding to the\nsouthmost pixel in the column. A 1 indicates to light the corresponding pixel,\nwhile a 0 indicates to keep the pixel dim. If any of the bits for a column are\neither floating or error values, then all pixels in the column are lit.\nRows\nThe inputs are lined along the component's west edge, with one multibit\ninput for each row of the matrix. Each input has as many bits as there are\ncolumns in the matrix, with the low-order bit corresponding to the rightmost\npixel in the row. As with the Columns format, a 1 indicates to light the\ncorresponding pixel, and a 0 indicates to keep the pixel dim. If any bits for\na row are floating or error values, then all pixels in the row are lit.\nSelect Rows/Columns\nThere are two inputs on the component's west edge. The upper multibit\ninput has as many bits as there are columns in the matrix, with the low-order\nbit corresponding to the rightmost column. The lower multibit input has as\nmany bits as there are rows in the matrix, with the low-order bit corresponding\nto the bottom row. If any bits in either input are floating or error\nvalues, all pixels in the matrix are lit. Normally, though, a pixel at a\nparticular row-column location is lit if the corresponding column bit in the\nupper input is 1 and the corresponding row bit in the lower input is 1.\nFor example, for a 5x7 matrix, if the first input is 01010 and the second is\n0111010, then the second and fourth columns are lit for the second, third,\nfourth, and sixth rows; the result appears to be a pair of exclamation points.\n(This input format may seem unintuitive, but LED matrixes are sold commercially\nwith exactly this interface. Lite-On sells such components, for example.)\nAttributes\nInput Format (read-only after component is created)\nSelects how the pins correspond to pixels, as outlined above.\nMatrix Columns\nSelects how many columns are in the matrix, which may range from 1 up to\n32.\nMatrix Rows\nSelects how many rows are in the matrix, which may range from 1 up to\n32.\nOn Color\nSelects the color of a pixel when it is lit.\nOff Color\nSelects the color of a pixel when it is dim.\nLight Persistence\nWhen this is other than 0, a pixel that is lit remains lit\nfor the given number of clock ticks after the component's inputs indicate\nthat the pixel should become dim.\nDot Shape\nThe square option means that each pixel is drawn as a 10x10 square, filling\nthe component with no gaps between pixels. The circle option means that each\npixel is drawn as a diameter-8 circle, with gaps between each circle. The circle\noption is more difficult to interpret, but it more closely approximates the\noff-the-shelf LED matrix components.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 120,
    "title": "TTY",
    "url": "/fr/html/libs/io/tty.html",
    "text": "TTY\nTTY\nLibrary:\nInput/Output\nIntroduced:\n2.2.0\nAppearance:\nBehavior\nThis component implements a very simple dumb terminal. It receives a sequence\nof ASCII codes and displays each printable character. When the current row\nbecomes full, the cursor moves to the following line, possibly scrolling all\ncurrent rows up if the cursor was already in the bottom row. The only supported\ncontrol sequences are: backspace (ASCII 8), which deletes the last character in\nthe final row, unless the final row is already empty; newline (ASCII 10), which\nmoves the cursor to the beginning of the following line, scrolling if necessary;\nand form-feed (ASCII 12, typed as control-L), which clears the screen.\nPins\nWest edge, upper pin (input, bit width 7)\nData - this is the ASCII value of the next character to be entered into\nthe terminal.\nWest edge, lower pin marked by triangle (input, bit width 1)\nClock - when triggered while the write-enable pin isn't 0, the\ncurrent ASCII value on the Data input is processed by the terminal.\nSouth edge, leftmost pin (input, bit width 1)\nWrite Enable - when 1 (or floating or error), a clock edge will result\nin processing a new character from the data input. The clock and data inputs are\nignored when Write Enable is 0.\nSouth edge, second pin from left (input, bit width 1)\nClear - when 1, the terminal is cleared of all data, and all other inputs\nare ignored.\nAttributes\nRows\nThe number of rows displayed in the terminal.\nColumns\nThe maximum number of characters displayed in each row of terminal.\nTrigger\nIf the value is Rising Edge, then when the clock input changes\nfrom 0 to 1, the data input is processed (when enabled by the write-enable\nand clear inputs).\nIf it is Falling Edge,, then this happens when the\nclock input changes from 1 to 0.\nColor\nThe color with which to draw the text appearing in the terminal.\nBackground\nThe color with which to draw the terminal's background.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nNone."
  },
  {
    "id": 121,
    "title": "Base library",
    "url": "/fr/html/libs/base/index.html",
    "text": "Base Library\nBase library\nThe Base library includes general-purpose tools.\nPoke Tool\nEdit Tool\nSelect Tool\nWiring Tool\nText Tool\nMenu Tool\nLabel"
  },
  {
    "id": 122,
    "title": "Poke Tool",
    "url": "/fr/html/libs/base/poke.html",
    "text": "Poke Tool\nPoke Tool\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nBehavior\nThe Poke Tool is for manipulating the current values associated with\ncomponents. The precise behavior of the Poke Tool varies depending on\nwhich component is clicked; this behavior is documented in the `Poke\nTool Behavior' section of each individual component.\nThe following components all have support for the Poke Tool.\nBase library\nPin\nClock\nMemory library\nD/T/J-K/S-R Flip-Flop\nRegister\nCounter\nShift Register\nRAM\nROM\nInput/Output library\nButton\nJoystick\nKeyboard\nAlso, clicking a wire segment using the Poke tool displays the value\ncurrently carried by the wire, as described on the Wiring Tool's page.\nAttributes\nNone.\nClicking on a component supporting the Poke Tool, though, will\ndisplay that component's attributes."
  },
  {
    "id": 123,
    "title": "Edit Tool",
    "url": "/fr/html/libs/base/edit.html",
    "text": "Edit Tool\nEdit Tool\nLibrary:\nBase\nIntroduced:\n2.3.0\nBehavior\nThe Edit tool allows the user to rearrange existing components and to add\nwires. Exactly what the tool does depends on where the user presses the mouse\non the canvas.\nWhen the mouse is over a wiring point for an existing component,\nor if it is atop a current wire, the Edit Tool will display a small green circle\naround the mouse's location. Pressing the button there initiates the addition of\na new wire. But if the user doesn't drag the mouse far enough to initiate a\nwire before releasing the button, the press is treated as a mouse click, and so\nthe wire is simply added into the current selection.\nThe bit width of an added wire is inferred from the components to which it\nis connected. If it is not attached to any components, the wire will be drawn\ngray to indicate that its bit width is unknown; if the components at the\nlocations that the wire helps to connect disagree on the bit width, then the\nwire will be drawn orange to indicate the conflict, and the wire will in fact\nrefuse to carry any values at all until the user resolves the conflict.\nAll wires in Logisim are either horizontal or vertical, never diagonal.\nWires are non-directional; that is, they carry values from\neither endpoint to the other. Indeed, a wire can carry values\nin both directions simultaneously: In the below example, a bit flows from the\nupper input at left through the center wire, then it circles back through the\ncenter wire, and then it circles forward again through the center wire before\nreaching the output at lower right.\nA single drag of the mouse can create multiple wire segments. The\nprecise process is a little confusing in its description; but it works\nquite intuitively in practice: If you request a particular wire segment\nusing the Wiring Tool, that segment will be split apart wherever it hits\na pin for an existing component, or wherever it hits the endpoint of an\nexisting wire segment. Also, if an endpoint of any of the new wire\nsegments hit somewhere in the middle of an existing wire, then that wire\nwill be split into multiple segments itself.\nYou can also shorten or delete an existing wire segment by initiating a drag\nat the terminus of the segment and then drawing backwards across the segment.\nDuring the drag, the shortening is indicated by drawing a white line over of the\nportion of the wire that will be removed.\nSome components draw short stubs to which wires can connect, such as the\nOR gate and controlled buffer. Logisim will\nsilently correct attempts to create wires that slightly overshoot the\nstub's end.\nIf, however, the user presses the Alt key at a point in the middle of\nthe wire, then the green circle will disappear. A mouse press selects the wire,\nand a mouse drag moves it.\nPressing the mouse button while it is within a currently selected\ncomponent begins a drag moving all elements of the selection.\nBy default, Logisim will compute a way to add new wires\nso that no existing connections are lost during the move.\n(Sometimes it will delete or shorten existing wires.)\nIf you're performing a move where you do not want these changes to be made,\nyou can press the shift key during the move.\nIf you want to disable this behavior entirely,\ngo to Project > Options, select the Canvas tab,\nand uncheck the Keep Connections When Moving box;\nin this case, the connections are computed only when the shift key is down.\nDragging a selection can lead to unexpected behavior from wires: If\nyou drag a selection including some wires on top of some other wires,\nall wires are merged, and the merged wires are placed into the\nselection.\nAs a result, if you drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior\nis necessary to keep with the intuitive behavior of wires in Logisim, where\nwires never overlap. And\nit does not normally constitute a major problem: Logisim will draw the\nfull selection in the midst of dropping, and you should not drop it\nuntil you are sure it is in the correct location.\nPressing the mouse within an unselected component (but not at one of\nthe component's wiring points) drops all components from the current selection\nand selects instead the component(s) containing the clicked location.\nShift-clicking the mouse within a component toggles that component's\npresence within the selection. If multiple components include the same\nlocation, all components' presence will be toggled.\nDragging the mouse starting at a location not contained within any\ncomponents drops all components from the current selection and\ninitiates a rectangular selection.\nAll component(s) contained by the rectangle will be placed into the\nselection.\nShift-dragging the mouse starting at a location not contained\nwithin any components initiates a rectangular selection.\nThe presence in the selection of all component(s) contained by the\nrectangle will be toggled.\nHowever, if the Alt key is pressed at a location not contained within\nany components, this initiates the addition of a new wire. A small green circle\nis drawn in such a circumstance to indicate this.\nAfter selecting the desired items in the selection, you can of course\ncut/copy/paste/delete/duplicate all the items via the\nEdit menu.\nSome keys have an effect with the Edit Tool.\nThe arrow keys change the Facing attribute for all components in the\nselection that have such an attribute.\nThe Delete and Backspace keys will delete everything in the selection\nfrom the circuit.\nThe Insert and MenuKey-D keys will create a duplicate of the currently\nselected components.\nLogisim's behavior when duplicating a selection or pasting the clipboard into\na circuit is somewhat peculiar: It will not immediately place the components into the\ncircuit; instead, the selection will be a collection of \"ghosts,\" which\nwill be dropped into the circuit as soon as they are either dragged to\nanother location or removed from the selection. (This peculiar behavior\nis necessary because pasting will otherwise merge the wires of the\nselection into the current circuit at once, and the wires there\npreviously will be dragged with the pasted clipboard if the user wants\nto move the pasted components somewhere else.)\nAttributes\nNone. Selecting a component, though, will display its attributes.\nWith multiple components selected, attributes shared by all are shown,\nblank if they have different values and otherwise with the value they\nall have in common. (Wires are ignored if there are any non-wires in\nthe selection.) Changes to the attribute value affect all selected\ncomponents."
  },
  {
    "id": 124,
    "title": "Select Tool",
    "url": "/fr/html/libs/base/select.html",
    "text": "Select Tool\nSelect Tool\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nBehavior\nAllows individual components to be placed into the current selection.\nThere are a number of actions possible with this tool.\nPressing the mouse button while it is within a currently selected\ncomponent begins a drag moving all components of the selection.\nBy default, Logisim will compute a way to add new wires\nso that no existing connections are lost during the move.\n(Sometimes it will delete or shorten existing wires.)\nIf you're performing a move where you do not want these changes to be made,\nyou can press the shift key during the move.\nIf you want to disable this behavior entirely,\ngo to Project > Options, select the Canvas tab,\nand uncheck the Keep Connections When Moving box;\nin this case, the connections are computed only when the shift key is down.\nDragging a selection can lead to unexpected behavior from wires: If\nyou drag a selection including some wires on top of some other wires,\nall wires are merged, and the merged wires are placed into the\nselection.\nAs a result, if you drag the selection a second time, the\nwires previously at the location will not be left behind. This behavior\nis necessary to keep with the expected behavior of wires in Logisim. And\nit does not normally constitute a major problem: Logisim will draw the\nfull selection in the midst of dropping, and you should not drop it\nuntil you are sure it is in the correct location.\nOtherwise, clicking the mouse within a component drops all\ncomponents from the current selection and selects instead the\ncomponent(s) containing the clicked location.\nShift-clicking the mouse within a component toggles that component's\npresence within the selection. If multiple components include the same\nlocation, all components' presence will be toggled. None of this will\nhappen, though, if shift-clicking is mapped to another tool instead (via\nthe project options window's Mouse\ntab).\nDragging the mouse starting at a location not contained within any\ncomponents drops all components from the current selection and\ninitiates a rectangular selection.\nAll component(s) contained by the rectangle will be placed into the\nselection.\nShift-dragging the mouse starting at a location not contained\nwithin any components initiates a rectangular selection.\nThe presence in the selection of all component(s) contained by the\nrectangle will be toggled. This will not happen, though, if\nshift-clicking is mapped to another tool instead.\nAfter selecting the desired items in the selection, you can of course\ncut/copy/paste/delete all the items via the Edit menu.\nLogisim's behavior when pasting the clipboard into a circuit is\nsomewhat peculiar: It will not immediately place the components into the\ncircuit; instead, the selection will be a collection of \"ghosts,\" which\nwill be dropped into the circuit as soon as they are either dragged to\nanother location or removed from the selection. (This peculiar behavior\nis necessary because pasting will otherwise merge the wires of the\nselection into the current circuit at once, and the wires there\npreviously will be dragged with the pasted clipboard if the user wants\nto move the pasted components somewhere else.)\nAttributes\nNone. Selecting a component, though, will display its attributes.\nWith multiple components selected, attributes shared by all are shown,\nblank if they have different values and otherwise with the value they\nall have in common. (Wires are ignored if there are any non-wires in\nthe selection.) Changes to the attribute value affect all selected\ncomponents."
  },
  {
    "id": 125,
    "title": "Wiring Tool",
    "url": "/fr/html/libs/base/wiring.html",
    "text": "Wiring Tool\nWiring Tool\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nBehavior\nThe wiring tool is the tool for creating wire segments that carry\nvalues from one endpoint to another.\nThe bit width of these values can\nbe anything; exactly which bit width is automatically inferred from the\ncomponents to which the wires are ultimately attached.\nIf it is not\nattached to any components, the wire will be drawn gray to indicate that\nits bit width is unknown; if the components at the locations that the\nwire helps to connect disagree on the bit width, then the wire will be\ndrawn orange to indicate the conflict, and the wire will in fact refuse\nto carry any values at all until the user resolves the conflict.\nA single drag of the mouse can create multiple wire segments. The\nprecise process is a little confusing in its description; but it works\nquite intuitively in practice: If you request a particular wire segment\nusing the Wiring Tool, that segment will be split apart wherever it hits\na pin for an existing component, or wherever it hits the endpoint of an\nexisting wire segment. Also, if an endpoint of any of the new wire\nsegments hit somewhere in the middle of an existing wire, then that wire\nwill be split into multiple segments itself.\nFor some components that draw short stubs to which wires can connect\n(such as an OR gate or a controlled buffer), Logisim will\nsilently correct attempts to create wires that slightly overshoot the\nstub's end.\nYou can also shorten an existing wire segment using the Wiring Tool,\nusing a drag that starts or ends at a terminus of the segment, and that\noverlaps the existing segment.\nAll wires in Logisim are either horizontal or vertical.\nWires are also non-directional; that is, they carry values from\neither endpoint to the other. Indeed, a wire can carry values\nin both directions simultaneously; the center wire in the below example\nis doing this.\nAttributes\nThe wiring tool does not itself have attributes, but the wires that\nit creates do.\nDirection\nIndicates whether the wire is horizontal or vertical.\nThe value of this attribute cannot be changed.\nLength\nIndicates how many pixels long the wire is.\nThe value of this attribute cannot be changed.\nPoke Tool Behavior\nWhen you click an existing wire segment using the Poke Tool, Logisim\ndisplays the current value traveling through that wire.\nThe behavior is particularly useful for multi-bit wires, whose black\ncolor provide no visual feedback about what value the wire is\ncarrying.\nFor multi-bit values, you can configure exactly how the value\nis displayed (in binary, decimal, or hexadecimal, for example) using\nthe Layout\npane of the Logisim Preferences dialog box."
  },
  {
    "id": 126,
    "title": "Text Tool",
    "url": "/fr/html/libs/base/text.html",
    "text": "Text Tool\nText Tool\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nBehavior\nThe text tool allows you to create and edit labels associated with\ncomponents. Which components support labels are indicated in the 'Text\nTool Behavior' section of their documentation. As of the current\nrelease, the following components in the built-in libraries support labels.\nBase library\nPin\nClock\nLabel\nProbe\nMemory library\nD/T/JK/SR Flip-Flop\nRegister\nCounter\nShift Register\nRandom\nInput/Output library\nButton\nLED\nFor components that can take a label but have none assigned to it currently,\nyou can click anywhere within the component to add a label. If there is already\na label, you need to click within the label. If you click at a point where there\nis not currently a label to be edited, Logisim will initiate the addition of a\nnew Label component.\nIn the current version of Logisim, text editing features are\nstill fairly primitive.\nSelections of a region of text within a label is impossible.\nThere is no way to insert a line break into a label.\nAttributes\nThe attributes for the tool are the same as for the label component. These attributes have no effect\nwhen editing the label on an existing component, but they are imparted\nto any labels created using the text tool.\nClicking on a component supporting the Text Tool will\ndisplay that component's attributes."
  },
  {
    "id": 127,
    "title": "Menu Tool",
    "url": "/fr/html/libs/base/menu.html",
    "text": "Menu Tool\nMenu Tool\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nBehavior\nThe menu tool permits the user to pull up a pop-up menu for\ncomponents that already exist. By default, right-clicking or\ncontrol-clicking a component will bring up this pop-up menu; however, the Mouse tab of the project options allows a user to\nconfigure the mouse buttons to work differently.\nThe pop-up menu for most components has two items.\nDelete: Removes the component from the circuit.\nShow Attributes: Places the component's attributes into the\nwindow's attribute table, so that the attribute values can be viewed and\nchanged.\nFor some components, however, the menu has additional items.\nSubcircuits (that is, instances of using one circuit as a \"black box\"\nwithin another) are one example of this: In addition to the above two\nitems, the pop-up menu includes another item.\nView XXX: Changes the circuit layout being viewed and\nedited to be the subcircuit's layout instead. The values seen in the\nlayout will be part of the same hierarchy as those of the supercircuit.\n(See the\n`Debugging subcircuits'\nsection of the User's Guide.)\nOther components may extend the pop-up menu also.\nIn the built-in libraries of the current version of Logisim, the only\nsuch components are RAM and\nROM.\nAttributes\nNone."
  },
  {
    "id": 128,
    "title": "Text",
    "url": "/fr/html/libs/base/label.html",
    "text": "Label\nLabel\nLibrary:\nBase\nIntroduced:\n2.0 Beta 1\nAppearance:\nBehavior\nThis is a simple text label that can be placed anywhere in the\ncircuit. It does not interact with values traveling through the circuit\nin any way, except inasmuch as it will be visible when the circuit is\ndrawn.\nIn contrast to all other components in the current built-in\nlibraries, label components can be placed anywhere on the canvas;\nthey do not snap to the grid.\nPins\nNone.\nAttributes\nText\nThe text appearing in the label. This value can be edited in the\nattribute table or, using the text tool, on the canvas.\nFont\nThe font to use when drawing the label.\nHorizontal Alignment\nThe horizontal positioning technique for the text relative to the label's official location\n(where the mouse was clicked in creating the label).\n\"Left\"\nmeans that the text should be drawn so that its left edge\nis at the location; \"right\" means that the text should be\ndrawn so that its right edge is at the location; and \"center\" means that\nthe text should be drawn so that its center (horizontally) is at the\nlocation.\nVertical Alignment\nThe vertical positioning technique for the text relative to the\nlabel's official location (where the mouse was clicked in creating the\nlabel). \"Base\" means that the baseline should intersect the location;\n\"Top\" means that the text's top should intersect the location; \"Bottom\"\nmeans that the text's bottom should intersect the location; and \"Center\"\nmeans that the text should be centered (vertically) at the location.\nThe text's top and bottom is computed based on the font's\nstandard ascent and descent values; thus, even if the actual text\ncontains no tall letters (such as b) or descending letters\n(such as g), it is assumed to contain such letters for the\npurposes of vertical positioning.\nPoke Tool Behavior\nNone.\nText Tool Behavior\nAllows the text appearing within the label to be edited."
  }
]
